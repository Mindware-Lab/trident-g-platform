<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zone Coach - Mindware Lab</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind is optional now; keeping it for layout utilities only -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Shared branding CSS (controls colours, type, cards, buttons, topbar) -->
 <link rel="stylesheet" href="../../../../branding/brand.css?v=2" />

  <style>
    /* Keep these minimal so brand.css remains the source of truth */
    body { margin: 0; padding: 0; font-family: var(--font, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif); }
    input[type="range"] { accent-color: #143a73; }
    .sliderLabel { font-weight: 900; font-size: 28px; color: rgba(0,0,0,0.85); }
    .sliderValue { font-weight: 900; font-size: 24px; color: var(--deep); }
    .sliderControl {
      width: 100%;
      margin-top: 8px;
      height: 12px;
      border-radius: 999px;
      background: #143a73;
      appearance: none;
      -webkit-appearance: none;
      outline: none;
    }
    .sliderControl::-webkit-slider-runnable-track {
      height: 12px;
      border-radius: 999px;
      background: #143a73;
    }
    .sliderControl::-webkit-slider-thumb {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: limegreen;
      border: 2px solid #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.55);
      -webkit-appearance: none;
      margin-top: -7px;
    }
    .sliderControl::-moz-range-thumb {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: limegreen;
      border: 2px solid #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.55);
    }
    .sliderControl::-moz-range-track {
      height: 12px;
      border-radius: 999px;
      background: #143a73;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <!-- SINGLE Babel script: everything lives here -->
  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // -----------------------------
    // Canonical keys (pipeline-ready)
    // -----------------------------
    const LS_KEYS = Object.freeze({
      ZONE_LAST: 'iqmw.zone.lastCheck',
      ZONE_HISTORY: 'iqmw.zone.history',
      CAPACITY_FROM_ZONE: 'iqmw.capacity.handoffFromZone',
      PVTB_HISTORY: 'iqmw.zone.pvtb.history'
    });

    // Optional cross-app fallback key (helps interoperability)
    const FALLBACK_CAPACITY_KEY = 'lastCapacitySession';

    // -----------------------------
    // Mode prototypes + classifier params
    // -----------------------------
    const PROTOTYPES = Object.freeze({
      SUB: Object.freeze({ E: 2, S: 3, F: 4, N: 5, O: 3, C: 3, R: 7 }),
      PSI: Object.freeze({ E: 5, S: 3, F: 8, N: 2, O: 4, C: 3, R: 2 }),
      ENT: Object.freeze({ E: 6, S: 6, F: 5, N: 8, O: 7, C: 8, R: 3 }),
      MIT: Object.freeze({ E: 6, S: 8, F: 8, N: 3, O: 7, C: 2, R: 9 }),
      DEP: Object.freeze({ E: 2, S: 7, F: 4, N: 7, O: 8, C: 6, R: 6 })
    });

    const WEIGHTS = Object.freeze({ E: 0.08, S: 0.10, F: 0.20, N: 0.18, O: 0.14, C: 0.10, R: 0.20 });
    const TAU = 6;

    const MODE_LABELS = Object.freeze({
      SUB: 'Subcritical',
      PSI: 'In the G Zone',
      ENT: 'Supercritical - scattered',
      MIT: 'Supercritical - rigid',
      DEP: 'Depleted overload'
    });

    const ZONE_UI = Object.freeze({
      too_hot: { title: 'Overloaded', hint: 'High strain. Keep it simple and stabilise first.' },
      in_band: { title: 'In the G Zone', hint: 'Trainable. Good time to learn and adapt.' },
      too_cold: { title: 'Underpowered', hint: 'Low activation. Start gently and build engagement.' },
      shaky: { title: 'Unsteady', hint: 'Variable. Reduce volatility before increasing difficulty.' }
    });

    const CONF_UI = Object.freeze({
      High: 'High confidence',
      Medium: 'Medium confidence',
      Low: 'Low confidence'
    });

    const SIGNAL_COLORS = Object.freeze({
      Good: '#1f7a1f',
      Mixed: '#b56a00',
      Poor: '#b00020'
    });

    // Map classifier output to the simple gate used across the ecosystem
    const toZoneGate = (primaryMode) => {
      if (primaryMode === 'PSI') return 'in_band';
      if (primaryMode === 'SUB') return 'too_cold';
      return 'too_hot';
    };

    // Suggest Type-1 capacity focus for the downstream Capacity Training Coach
    const suggestedCapacityFromMode = (primaryMode) => {
      switch (primaryMode) {
        case 'SUB': return { primary: 'Hold', secondary: 'Update' };
        case 'PSI': return { primary: 'Update', secondary: 'Hold' };
        case 'ENT': return { primary: 'Stop', secondary: 'Shield' };
        case 'MIT': return { primary: 'Clear', secondary: 'Recover' };
        case 'DEP': return { primary: 'Recover', secondary: 'Stop' };
        default: return { primary: 'Recover', secondary: null };
      }
    };

    // -----------------------------
    // Breathing patterns (generated once)
    // -----------------------------

  const makeRepeat = (n, seq) => Array.from({ length: n }, () => seq).flat();

  const BREATH_PATTERNS = Object.freeze({
    upshift: Object.freeze({
      id: 'upshift',
      name: 'Upshift',
      description: 'Inhale-led breathing to gently raise engagement. Breathe in through your nose, breathe out through your nose (or softly through your mouth if needed).',
      attentionCue: 'Anchor attention on the in-breath sensation. Return gently when distracted.',
      safety: 'If you feel dizzy or unwell, stop and return to normal breathing.',
      phases: [
        ...makeRepeat(10, [
          { label: 'Inhale', durationMs: 2000, kind: 'inhale' },
          { label: 'Exhale', durationMs: 2000, kind: 'exhale' }
        ]),
        ...makeRepeat(14, [
          { label: 'Inhale', durationMs: 3000, kind: 'inhale' },
          { label: 'Exhale', durationMs: 2000, kind: 'exhale' }
        ]),
        ...makeRepeat(10, [
          { label: 'Inhale', durationMs: 4000, kind: 'inhale' },
          { label: 'Exhale', durationMs: 3000, kind: 'exhale' }
        ])
      ]
    }),

    amplify: Object.freeze({
      id: 'amplify',
      name: 'Amplify',
      description: 'Slow-paced breathing to stabilise. Inhale through your nose, exhale through your nose (or softly through your mouth if needed).',
      attentionCue: 'Track the smooth rhythm. Thoughts are normal. Notice them and return to the breath.',
      safety: 'If you feel dizzy or unwell, stop and return to normal breathing.',
      phases: makeRepeat(18, [
        { label: 'Inhale', durationMs: 4000, kind: 'inhale' },
        { label: 'Exhale', durationMs: 6000, kind: 'exhale' }
      ])
    }),

    downshift: Object.freeze({
      id: 'downshift',
      name: 'Downshift',
      description: 'Cyclic sighing to reduce arousal and overload. Take two small "sip" inhales through your nose, then a long sigh out through your mouth.',
      attentionCue: 'Count the pattern: sip, sip, long sigh. If your mind races, return to the count.',
      safety: 'If you feel dizzy or unwell, stop and return to normal breathing.',
      phases: makeRepeat(20, [
        { label: 'Inhale (1)', durationMs: 1000, kind: 'inhale' },
        { label: 'Inhale (2)', durationMs: 1000, kind: 'inhale' },
        { label: 'Sigh out', durationMs: 7000, kind: 'exhale' }
      ])
    })
  });
    const selectBreathingPattern = (primaryMode) => {
      if (primaryMode === 'SUB') return 'upshift';
      if (primaryMode === 'PSI') return 'amplify';
      return 'downshift';
    };

    // -----------------------------
    // Ratings items
    // -----------------------------
    const SLIDERS = Object.freeze([
      { key: 'E', label: 'Energy', desc: 'How much usable energy do you have right now to start and keep going?' },
      { key: 'S', label: 'Tension', desc: 'How tense or "on edge" do you feel in your body and mind?' },
      { key: 'F', label: 'Focus steadiness', desc: 'How easy is it to stay with one thing without forcing it?' },
      { key: 'N', label: 'Mental chatter', desc: 'How noisy is your mind with thoughts, worries, or distractions?' },
      { key: 'O', label: 'Mental load', desc: 'How overloaded do you feel by what you are juggling right now?' },
      { key: 'C', label: 'Plan switching', desc: 'Are you sticking to one plan, or do you keep changing direction and second-guessing?' },
      { key: 'R', label: 'Stuckness', desc: 'Do you feel flexible, or stuck in one way of doing things even if it is not working?' }
    ]);

    // IMPORTANT: Use an absolute URL if this relative path ever 404s.
    const CAPACITY_TRAINING_COACH_URL = '../game-switcher/';

    // -----------------------------
    // Classifier helpers
    // -----------------------------
    function computeDistance(ratings, prototype, weights) {
      let sum = 0;
      for (const k in prototype) {
        const diff = ratings[k] - prototype[k];
        sum += weights[k] * diff * diff;
      }
      return Math.sqrt(sum);
    }

    function classifyMode(ratings, externalDistractions) {
      const N_eff = externalDistractions ? Math.min(10, ratings.N + 2) : ratings.N;
      const adjusted = { ...ratings, N: N_eff };

      const scores = {};
      for (const mode in PROTOTYPES) {
        const d = computeDistance(adjusted, PROTOTYPES[mode], WEIGHTS);
        scores[mode] = Math.exp(-(d * d) / TAU);
      }

      const total = Object.values(scores).reduce((a, b) => a + b, 0);
      const probs = {};
      for (const mode in scores) probs[mode] = scores[mode] / total;

      const primaryMode = Object.keys(probs).reduce((a, b) => (probs[a] > probs[b] ? a : b));
      const top = probs[primaryMode];
      const confidence = top >= 0.60 ? 'High' : top >= 0.45 ? 'Medium' : 'Low';

      return { primaryMode, modeProbs: probs, confidence, N_eff };
    }

    function computeStateConfidence({ signalClarity, probe, interruptions, ratings }) {
      const clarity = (signalClarity ?? 7);

      const tabSwitches = interruptions?.tabSwitches ?? 0;
      const blurs = interruptions?.blurs ?? 0;
      const interruptScore = tabSwitches + blurs;

      const hits = probe?.rts?.length ?? 0;
      const trials = probe?.trials ?? 0;
      const falseStarts = probe?.falseStarts ?? 0;
      const lapses = probe?.lapses ?? 0;

      const lowData = (trials > 0) && (hits < Math.max(10, Math.floor(trials * 0.6)));
      const noisyProbe = falseStarts >= 4 || lapses >= 3;

      const selfSaysSteady = ratings && (ratings.F >= 6 && ratings.N <= 4 && ratings.O <= 5);
      const variability = probe?.madScaledMs ?? probe?.madMs ?? null;
      const behaviourSaysNoisy = noisyProbe || (variability !== null && variability >= 260);

      const disagreement = selfSaysSteady && behaviourSaysNoisy;

      if (clarity <= 4 || interruptScore >= 2 || lowData || disagreement) return 'Low';
      if (clarity <= 6 || interruptScore === 1 || noisyProbe) return 'Medium';
      return 'High';
    }

    function computeOverallConfidence(modeConfidence, stateConfidence) {
      if (stateConfidence === 'Low') return 'Low';
      if (stateConfidence === 'Medium' && modeConfidence === 'High') return 'Medium';
      return modeConfidence;
    }

    function computeSignalQuality({ probe, interruptions, ratings }) {
      const tabSwitches = interruptions?.tabSwitches ?? 0;
      const blurs = interruptions?.blurs ?? 0;
      const interruptScore = tabSwitches + blurs;

      const hits = probe?.rts?.length ?? 0;
      const trials = probe?.trials ?? 0;
      if (!trials) return { label: 'Poor', reason: 'no probe data' };

      const hitRate = hits / trials;
      const lapses = probe?.lapses ?? 0;
      const falseStarts = probe?.falseStarts ?? 0;
      let variability = probe?.madScaledMs ?? probe?.madMs ?? null;
      if (variability === null && Array.isArray(probe?.rts) && probe.rts.length) {
        const mean = probe.rts.reduce((a, b) => a + b, 0) / probe.rts.length;
        const sd = Math.sqrt(probe.rts.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / probe.rts.length);
        variability = Math.round(sd);
      }

      const selfSaysSteady = ratings && (ratings.F >= 6 && ratings.N <= 4 && ratings.O <= 5);
      const behaviourSaysNoisy = lapses >= 2 || falseStarts >= 2 || hitRate < 0.85 || (variability !== null && variability >= 260);
      const disagreement = selfSaysSteady && behaviourSaysNoisy;

      const lowHits = hitRate < 0.8;
      const someHitLoss = hitRate < 0.9;
      const manyLapses = lapses >= 3;
      const someLapses = lapses >= 1;
      const manyFalseStarts = falseStarts >= 3;
      const someFalseStarts = falseStarts >= 1;
      const highVariability = variability !== null && variability >= 260;
      const midVariability = variability !== null && variability >= 200;

      const objectivePoor = lowHits || manyLapses || manyFalseStarts || interruptScore >= 2 || highVariability;
      const mixedFromProbe = someHitLoss || someLapses || someFalseStarts || midVariability;

      let label = 'Good';
      if (objectivePoor) {
        label = 'Poor';
      } else if (mixedFromProbe) {
        label = 'Mixed';
      }

      const reasons = [];
      if (interruptScore >= 2) {
        reasons.push('Multiple interruptions');
      } else if (interruptScore === 1) {
        reasons.push('1 interruption');
      }
      if (lowHits) reasons.push('Low hit rate');
      else if (someHitLoss) reasons.push('Reduced hit rate');
      if (manyLapses) reasons.push('Several lapses');
      else if (someLapses) reasons.push('Some lapses');
      if (manyFalseStarts) reasons.push('Multiple early taps');
      else if (someFalseStarts) reasons.push('Early taps');
      if (highVariability) reasons.push('High RT variability');
      else if (midVariability) reasons.push('Elevated RT variability');

      if (label === 'Good' && disagreement) {
        label = 'Mixed';
        return { label, reason: 'Self-report and probe differ today' };
      }

      if (label === 'Good') {
        return { label, reason: 'Few interruptions, consistent responses' };
      }

      if (label === 'Mixed' && reasons.length === 0) {
        return { label, reason: 'Self-report and probe differ today' };
      }

      const reason = reasons.length ? reasons.slice(0, 2).join(' + ') : 'Mixed signals today';
      return { label, reason };
    }

    // -----------------------------
    // Breathing Coach component (branded + safe audio)
    // -----------------------------
    function BreathingCoach({ patternId, onComplete, brand }) {
      const pattern = BREATH_PATTERNS[patternId];

      const size = 260;
      const centre = size / 2;
      const minR = 54;
      const maxR = 96;
      const stroke = 10;

      const targetMs = 180000; // 3 minutes

      const [running, setRunning] = useState(false);
      const [elapsedMs, setElapsedMs] = useState(0);
      const [phaseLabel, setPhaseLabel] = useState('Ready');
      const [phaseKind, setPhaseKind] = useState('inhale');
      const [phaseProgress, setPhaseProgress] = useState(0);
      const [pingEnabled, setPingEnabled] = useState(true);
      const [audioReady, setAudioReady] = useState(false);

      const rafRef = useRef(null);
      const startRef = useRef(null);
      const pingerRef = useRef(null);
      const lastPhaseIndexRef = useRef(-1);

      const cycleMs = useMemo(
        () => pattern.phases.reduce((s, p) => s + p.durationMs, 0),
        [pattern]
      );

      const getPhaseAt = useCallback((tMs) => {
        const t = (tMs % cycleMs + cycleMs) % cycleMs;
        let acc = 0;

        for (let i = 0; i < pattern.phases.length; i++) {
          const p = pattern.phases[i];
          const next = acc + p.durationMs;

          if (t >= acc && t < next) {
            return {
              index: i,
              label: p.label,
              kind: p.kind,
              progress: p.durationMs > 0 ? (t - acc) / p.durationMs : 0
            };
          }
          acc = next;
        }

        const last = pattern.phases[pattern.phases.length - 1];
        return { index: pattern.phases.length - 1, label: last.label, kind: last.kind, progress: 1 };
      }, [cycleMs, pattern]);

      const ensurePinger = async () => {
        if (pingerRef.current) return true;
        try {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          if (!AudioCtx) return false;

          const ctx = new AudioCtx();
          if (ctx.state === 'suspended') await ctx.resume();

          pingerRef.current = {
            ctx,
            ping: (freqHz = 440) => {
              const t0 = ctx.currentTime;
              const osc = ctx.createOscillator();
              const g = ctx.createGain();

              osc.type = 'sine';
              osc.frequency.setValueAtTime(freqHz, t0);

              g.gain.setValueAtTime(0.0001, t0);
              g.gain.exponentialRampToValueAtTime(0.08, t0 + 0.01);
              g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.09);

              osc.connect(g);
              g.connect(ctx.destination);

              osc.start(t0);
              osc.stop(t0 + 0.11);
            }
          };

          return true;
        } catch {
          return false;
        }
      };

      const stop = () => {
        setRunning(false);
        if (rafRef.current) cancelAnimationFrame(rafRef.current);
        rafRef.current = null;
      };

      const start = async () => {
        const ok = await ensurePinger();
        setAudioReady(ok);
        lastPhaseIndexRef.current = -1;
        startRef.current = performance.now();
        setElapsedMs(0);
        setRunning(true);
      };

      useEffect(() => {
        if (!running) return;

        const tick = () => {
          const now = performance.now();
          const elapsed = now - startRef.current;

          if (elapsed >= targetMs) {
            setElapsedMs(targetMs);
            stop();
            onComplete?.();
            return;
          }

          setElapsedMs(elapsed);

          const ph = getPhaseAt(elapsed);

          if (ph.index !== lastPhaseIndexRef.current) {
            if (pingEnabled && pingerRef.current && audioReady) {
              pingerRef.current.ping(ph.kind === 'inhale' ? 440 : 660);
            }
            lastPhaseIndexRef.current = ph.index;
          }

          setPhaseLabel(ph.label);
          setPhaseKind(ph.kind);
          setPhaseProgress(ph.progress);

          rafRef.current = requestAnimationFrame(tick);
        };

        rafRef.current = requestAnimationFrame(tick);
        return () => {
          if (rafRef.current) cancelAnimationFrame(rafRef.current);
        };
      }, [running, targetMs, getPhaseAt, pingEnabled, audioReady]);

      const displayRadius =
        minR + (maxR - minR) * (phaseKind === 'inhale' ? phaseProgress : 1 - phaseProgress);

      const overallProgress = Math.min(1, elapsedMs / targetMs);
      const remainingMs = Math.max(0, targetMs - elapsedMs);
      const mm = Math.floor(remainingMs / 60000);
      const ss = Math.floor((remainingMs % 60000) / 1000);

      const ringR = (maxR + 18);
      const ringC = 2 * Math.PI * ringR;
      const ringFill = ringC * overallProgress;
      const ringRest = ringC - ringFill;

      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon">
                <img
                  src={brand?.logoSrc}
                  alt="Trident logo"
                  onError={(e) => { e.target.style.display = 'none'; }}
                />
              </div>
              <div>
                <p className="title">{brand?.appName || 'Zone Coach'}</p>
                <p className="subtitle">{brand?.subtitle || 'Quick state check -> mindful reset -> start training'}</p>
              </div>
            </div>
            <div className="chip">Reset</div>
          </div>

          <div className="content">
            <div className="card" style={{ maxWidth: 820, margin: '0 auto' }}>
              <div className="h1">{pattern.name}</div>
              <p className="p">{pattern.description}</p>
              <div style={{ display: 'flex', flexDirection: 'row', justifyContent: 'center', gap: 12, marginTop: 10 }}>
                <div className="card" style={{ boxShadow: 'none' }}>
                  <div className="p" style={{ fontWeight: 800, color: 'var(--deep)' }}>Time remaining</div>
                  <div className="h1" style={{ fontSize: 28, marginTop: 6, color: 'var(--deep)' }}>
                    {mm}:{String(ss).padStart(2, '0')}
                  </div>
                  <p className="p" style={{ marginTop: 6 }}>{pattern.attentionCue}</p>
                </div>

                <div className="card" style={{ boxShadow: 'none' }}>
                  <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                    <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
                      <circle cx={centre} cy={centre} r={maxR} fill="none" stroke="rgba(0,0,0,0.12)" strokeWidth={stroke} />
                      <circle cx={centre} cy={centre} r={ringR} fill="none" stroke="rgba(0,0,0,0.10)" strokeWidth={6} />
                      <circle
                        cx={centre}
                        cy={centre}
                        r={ringR}
                        fill="none"
                        stroke="var(--deep)"
                        strokeOpacity="0.55"
                        strokeWidth={6}
                        strokeLinecap="round"
                        strokeDasharray={`${ringFill} ${ringRest}`}
                        transform={`rotate(-90 ${centre} ${centre})`}
                      />
                      <circle
                        cx={centre}
                        cy={centre}
                        r={displayRadius}
                        fill="none"
                        stroke="var(--deep)"
                        strokeOpacity="0.95"
                        strokeWidth={stroke}
                      />
                      <text x={centre} y={centre} textAnchor="middle" fontSize="20" fontWeight="800" fill="rgba(0,0,0,0.85)">
                        {phaseLabel}
                      </text>
                    </svg>
                  </div>

                  <label style={{ display: 'flex', alignItems: 'center', gap: 10, marginTop: 10, cursor: 'pointer' }}>
                    <input
                      type="checkbox"
                      checked={pingEnabled}
                      onChange={(e) => setPingEnabled(e.target.checked)}
                    />
                    <span className="p" style={{ margin: 0, color: 'rgba(0,0,0,0.80)', fontWeight: 800 }}>
                      Ping at high/low points
                    </span>
                  </label>

                  {!audioReady && pingEnabled && (
                    <div className="p" style={{ marginTop: 8 }}>
                      Audio pings may be unavailable in this browser until interaction is allowed.
                    </div>
                  )}
                </div>
              </div>

              <div className="card" style={{ marginTop: 12, background: 'rgba(204,255,102,0.18)', border: '1px solid rgba(0,0,0,0.06)' }}>
                <div className="p" style={{ fontWeight: 900, color: 'rgba(0,0,0,0.85)' }}>Safety</div>
                <div className="p" style={{ marginTop: 6, color: 'rgba(0,0,0,0.78)' }}>{pattern.safety}</div>
              </div>

              <div className="btnRow" style={{ flexDirection: 'row', justifyContent: 'center' }}>
                {!running ? (
                  <button onClick={start} className="btn btnPrimary" style={{ flex: '0 1 200px', padding: '12px 20px' }}>
                    Start 3-minute reset
                  </button>
                ) : (
                  <button onClick={stop} className="btn btnSecondary" style={{ flex: '0 1 200px', padding: '12px 20px' }}>
                    Stop
                  </button>
                )}

                <button onClick={() => { stop(); onComplete?.(); }} className="btn btnSecondary" style={{ flex: '0 1 200px', padding: '12px 20px' }}>
                  I'm done
                </button>
              </div>
            </div>
          </div>

          <div className="footer">
            <span>Mindware Lab | Trident</span>
            <a className="link" href={CAPACITY_TRAINING_COACH_URL} target="_blank" rel="noreferrer">Capacity Coach</a>
          </div>
        </div>
      );
    }
    // -----------------------------
    // PVT-style readiness probe (no HR/BLE dependency)
    // -----------------------------
    function DotProbe({ label, onComplete, brand, durationSec = 180, isRecheck = false }) {
      const PRACTICE_TRIALS = 6;
      const FOREPERIOD_MIN_MS = 1000;
      const FOREPERIOD_MAX_MS = 4000;
      const RESPONSE_WINDOW_MS = 30000;
      const LAPSE_THRESHOLD_MS = 500;

      const [stage, setStage] = useState('intro'); // intro | practice | practice_done | run | done
      const [status, setStatus] = useState('Ready');
      const [elapsedSec, setElapsedSec] = useState(0);
      const [trialLabel, setTrialLabel] = useState('');
      const [showTarget, setShowTarget] = useState(false);
      const [summary, setSummary] = useState(null);

      const runningRef = useRef(false);
      const stageRef = useRef('intro');
      const startPerfRef = useRef(0);
      const trialCounterRef = useRef(0);
      const currentTrialRef = useRef(null);
      const inForeperiodRef = useRef(false);
      const targetVisibleRef = useRef(false);
      const logsRef = useRef([]);
      const timersRef = useRef({ foreperiod: null, response: null, tick: null });

      const clearTimer = (key) => {
        if (timersRef.current[key]) {
          clearTimeout(timersRef.current[key]);
          timersRef.current[key] = null;
        }
      };

      const clearAllTimers = () => {
        clearTimer('foreperiod');
        clearTimer('response');
        clearTimer('tick');
      };

      const median = (arr) => {
        if (!arr.length) return null;
        const sorted = arr.slice().sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 1 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
      };

      const mean = (arr) => (arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : null);

      const sd = (arr) => {
        if (arr.length < 2) return 0;
        const m = mean(arr);
        const variance = arr.reduce((acc, x) => acc + Math.pow(x - m, 2), 0) / arr.length;
        return Math.sqrt(variance);
      };

      const mad = (arr) => {
        if (!arr.length) return null;
        const med = median(arr);
        const absDeviations = arr.map((x) => Math.abs(x - med));
        return median(absDeviations);
      };

      const readPvtHistory = () => {
        try {
          const parsed = JSON.parse(localStorage.getItem(LS_KEYS.PVTB_HISTORY) || '[]');
          return Array.isArray(parsed) ? parsed : [];
        } catch {
          return [];
        }
      };

      const savePvtHistory = (entry) => {
        try {
          const history = readPvtHistory();
          history.push(entry);
          while (history.length > 120) history.shift();
          localStorage.setItem(LS_KEYS.PVTB_HISTORY, JSON.stringify(history));
        } catch {}
      };

      const meanOrNull = (arr) => (arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : null);

      const sdOrNull = (arr, m) => {
        if (arr.length < 2 || !Number.isFinite(m)) return null;
        const variance = arr.reduce((acc, x) => acc + Math.pow(x - m, 2), 0) / arr.length;
        const out = Math.sqrt(variance);
        return Number.isFinite(out) ? out : null;
      };

      const classifyReadiness = ({ lapses, rtCv, falseStarts }) => {
        const history = readPvtHistory();
        const comparable = history.filter((h) =>
          Number(h?.duration_s) === Number(durationSec)
          && Number.isFinite(Number(h?.summary?.rtCv))
        );
        const baselineCount = comparable.length;
        if (baselineCount < 7 || !Number.isFinite(rtCv)) {
          return { band: 'calibrating', readinessIndex: null, baselineCount };
        }

        const lapsesLogArr = comparable.map((h) => Math.log(Number(h?.summary?.lapses ?? 0) + 1));
        const rtCvArr = comparable.map((h) => Number(h.summary.rtCv));
        const falseStartsLogArr = comparable.map((h) => Math.log(Number(h?.summary?.falseStarts ?? 0) + 1));

        const currentLapsesLog = Math.log(Number(lapses ?? 0) + 1);
        const currentFalseStartsLog = Math.log(Number(falseStarts ?? 0) + 1);

        const z = (value, arr) => {
          const m = meanOrNull(arr);
          const s = sdOrNull(arr, m);
          if (!Number.isFinite(value) || !Number.isFinite(m) || !Number.isFinite(s) || s <= 0) return 0;
          return (value - m) / s;
        };

        const readinessIndex =
          -z(currentLapsesLog, lapsesLogArr)
          -z(rtCv, rtCvArr)
          -z(currentFalseStartsLog, falseStartsLogArr);

        const rounded = Number(readinessIndex.toFixed(3));
        const band = rounded >= -0.5 ? 'green' : (rounded > -1.5 ? 'amber' : 'red');
        return { band, readinessIndex: rounded, baselineCount };
      };

      const remainingSec = Math.max(0, durationSec - elapsedSec);

      const runTicker = useCallback(() => {
        if (!runningRef.current) return;
        if (stageRef.current !== 'run') return;

        const elapsed = Math.floor((performance.now() - startPerfRef.current) / 1000);
        setElapsedSec(elapsed);

        if (elapsed >= durationSec) {
          runningRef.current = false;
          setShowTarget(false);
          targetVisibleRef.current = false;
          inForeperiodRef.current = false;
          clearAllTimers();

          const all = logsRef.current.slice();
          const stimTrials = all.filter((t) => !t.false_start);
          const hits = stimTrials.filter((t) => Number.isFinite(t.rt_ms) && !t.timeout);
          const rts = hits.map((t) => t.rt_ms);
          const rtMean = mean(rts);
          const rtMedian = median(rts);
          const rtSd = sd(rts);
          const rtCv = rtMean ? rtSd / rtMean : null;
          const rtMad = mad(rts);
          const rtMadScaled = rtMad === null ? null : rtMad * 1.4826;
          const lapses = stimTrials.filter((t) => t.lapse).length;
          const falseStarts = all.filter((t) => t.false_start).length;
          const timeouts = stimTrials.filter((t) => t.timeout).length;
          const responseSpeed = rts.length ? rts.reduce((acc, rt) => acc + (1000 / rt), 0) / rts.length : null;

          const summaryCore = {
            test_id: 'pvtb_readiness_v1',
            duration_s: durationSec,
            trials: stimTrials.length,
            hits: hits.length,
            rts,
            meanMs: rtMean !== null ? Math.round(rtMean) : null,
            medianMs: rtMedian !== null ? Math.round(rtMedian) : null,
            rtSdMs: rtSd !== null ? Math.round(rtSd) : null,
            rtCv: rtCv !== null ? Number(rtCv.toFixed(3)) : null,
            madMs: rtMad !== null ? Math.round(rtMad) : null,
            madScaledMs: rtMadScaled !== null ? Math.round(rtMadScaled) : null,
            lapses,
            falseStarts,
            timeouts,
            responseSpeed: responseSpeed !== null ? Number(responseSpeed.toFixed(3)) : null,
            trialLog: all
          };

          const readiness = classifyReadiness({
            lapses: summaryCore.lapses,
            rtCv: summaryCore.rtCv,
            falseStarts: summaryCore.falseStarts
          });

          const runEntry = {
            ts: new Date().toISOString(),
            test_id: 'pvtb_readiness_v1',
            duration_s: durationSec,
            device_mode: 'keyboard_or_tap',
            summary: {
              medianMs: summaryCore.medianMs,
              meanMs: summaryCore.meanMs,
              rtCv: summaryCore.rtCv,
              lapses: summaryCore.lapses,
              falseStarts: summaryCore.falseStarts,
              responseSpeed: summaryCore.responseSpeed
            },
            band: readiness.band
          };
          savePvtHistory(runEntry);

          setSummary({
            ...summaryCore,
            readinessBand: readiness.band,
            readinessIndex: readiness.readinessIndex,
            baselineCount: readiness.baselineCount
          });

          setStage('done');
          setStatus('Complete');
          return;
        }

        timersRef.current.tick = setTimeout(runTicker, 200);
      }, [durationSec]);

      const scheduleNextTrial = useCallback(() => {
        if (!runningRef.current) return;
        if (stageRef.current !== 'practice' && stageRef.current !== 'run') return;

        if (stageRef.current === 'practice' && trialCounterRef.current >= PRACTICE_TRIALS) {
          runningRef.current = false;
          setShowTarget(false);
          targetVisibleRef.current = false;
          inForeperiodRef.current = false;
          setStage('practice_done');
          setStatus('Practice complete');
          setTrialLabel(`Practice: ${PRACTICE_TRIALS}/${PRACTICE_TRIALS}`);
          return;
        }

        setShowTarget(false);
        targetVisibleRef.current = false;
        inForeperiodRef.current = true;
        setStatus('Wait for signal');

        const foreperiodMs = Math.floor(
          Math.random() * (FOREPERIOD_MAX_MS - FOREPERIOD_MIN_MS + 1)
        ) + FOREPERIOD_MIN_MS;

        if (stageRef.current === 'practice') {
          setTrialLabel(`Practice: ${trialCounterRef.current + 1}/${PRACTICE_TRIALS}`);
        } else {
          setTrialLabel(`Trials logged: ${trialCounterRef.current}`);
        }

        timersRef.current.foreperiod = setTimeout(() => {
          if (!runningRef.current) return;

          inForeperiodRef.current = false;
          targetVisibleRef.current = true;
          setShowTarget(true);
          setStatus('Respond now');

          trialCounterRef.current += 1;
          const stimOnsetPerf = performance.now();
          const stimOnsetTs = Date.now();
          currentTrialRef.current = {
            trial_index: trialCounterRef.current,
            foreperiod_ms: foreperiodMs,
            stim_onset_perf: stimOnsetPerf,
            stim_onset_ts: stimOnsetTs
          };

          timersRef.current.response = setTimeout(() => {
            if (!runningRef.current || !targetVisibleRef.current) return;
            targetVisibleRef.current = false;
            setShowTarget(false);
            setStatus('Timeout');

            const base = currentTrialRef.current;
            logsRef.current.push({
              trial_index: base?.trial_index ?? trialCounterRef.current,
              foreperiod_ms: base?.foreperiod_ms ?? foreperiodMs,
              stim_onset_ts: base?.stim_onset_ts ?? null,
              response_ts: null,
              rt_ms: null,
              false_start: false,
              timeout: true,
              lapse: true
            });
            currentTrialRef.current = null;
            scheduleNextTrial();
          }, RESPONSE_WINDOW_MS);
        }, foreperiodMs);
      }, [PRACTICE_TRIALS]);

      const startStage = (nextStage) => {
        clearAllTimers();
        stageRef.current = nextStage;
        setStage(nextStage);
        setSummary(null);
        setStatus('Ready');
        setElapsedSec(0);
        setTrialLabel('');
        setShowTarget(false);
        targetVisibleRef.current = false;
        inForeperiodRef.current = false;
        currentTrialRef.current = null;
        trialCounterRef.current = 0;

        if (nextStage === 'run') {
          logsRef.current = [];
        }

        runningRef.current = nextStage === 'practice' || nextStage === 'run';
        if (!runningRef.current) return;

        startPerfRef.current = performance.now();
        if (nextStage === 'run') runTicker();
        scheduleNextTrial();
      };

      const handleResponse = useCallback(() => {
        if (!runningRef.current) return;

        if (!targetVisibleRef.current) {
          if (inForeperiodRef.current && stageRef.current !== 'practice') {
            logsRef.current.push({
              trial_index: trialCounterRef.current + 1,
              foreperiod_ms: null,
              stim_onset_ts: null,
              response_ts: Date.now(),
              rt_ms: null,
              false_start: true,
              timeout: false,
              lapse: false
            });
            setStatus('Too early');
          }
          return;
        }

        clearTimer('response');
        targetVisibleRef.current = false;
        setShowTarget(false);

        const nowPerf = performance.now();
        const nowTs = Date.now();
        const base = currentTrialRef.current;
        const rtMs = Math.max(0, Math.round(nowPerf - (base?.stim_onset_perf ?? nowPerf)));
        const lapse = rtMs >= LAPSE_THRESHOLD_MS;

        if (stageRef.current !== 'practice') {
          logsRef.current.push({
            trial_index: base?.trial_index ?? trialCounterRef.current,
            foreperiod_ms: base?.foreperiod_ms ?? null,
            stim_onset_ts: base?.stim_onset_ts ?? null,
            response_ts: nowTs,
            rt_ms: rtMs,
            false_start: false,
            timeout: false,
            lapse
          });
        }

        currentTrialRef.current = null;
        setStatus(lapse ? 'Late response' : 'Good');
        scheduleNextTrial();
      }, [LAPSE_THRESHOLD_MS, scheduleNextTrial]);

      useEffect(() => {
        const onKeyDown = (e) => {
          if (e.code === 'Space' || e.key === ' ') {
            if (e.repeat) return;
            e.preventDefault();
            handleResponse();
          }
        };
        window.addEventListener('keydown', onKeyDown);
        return () => window.removeEventListener('keydown', onKeyDown);
      }, [handleResponse]);

      useEffect(() => () => {
        runningRef.current = false;
        clearAllTimers();
      }, []);

      const logoSrc = brand?.logoSrc || '../../../../branding/Trident-G-Icon.svg';
      const appName = brand?.appName || 'Zone Coach';
      const subtitle = brand?.subtitle || 'Quick state check -> mindful reset -> start training';

      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon">
                <img src={logoSrc} alt="Trident logo" onError={(e) => { e.target.style.display = 'none'; }} />
              </div>
              <div>
                <p className="title">{appName}</p>
                <p className="subtitle">{subtitle}</p>
              </div>
            </div>
            <div className="chip">{label}</div>
          </div>

          <div className="content">
            <div className="card" style={{ maxWidth: 760, margin: '0 auto', textAlign: 'center' }}>
              <div className="h1">{isRecheck ? 'Quick recheck' : `Readiness check (${durationSec}s)`}</div>
              <p className="p" style={{ marginTop: 6 }}>
                Press <b>Space</b> or tap as soon as the target appears. Avoid early taps.
              </p>

              {stage === 'intro' && (
                <>
                  <p className="p" style={{ marginTop: 10 }}>
                    This is a local-only readiness probe. No HR/Bluetooth sensor is required.
                  </p>
                  <div className="btnRow" style={{ justifyContent: 'center' }}>
                    <button className="btn btnSecondary" style={{ width: 'min(360px, 100%)' }} onClick={() => startStage('practice')}>
                      Start practice ({PRACTICE_TRIALS} trials)
                    </button>
                    <button className="btn btnPrimary" style={{ width: 'min(360px, 100%)' }} onClick={() => startStage('run')}>
                      Skip practice and start
                    </button>
                  </div>
                </>
              )}

              {stage === 'practice_done' && (
                <>
                  <p className="p" style={{ marginTop: 10 }}>Practice complete. Start the timed probe when ready.</p>
                  <div className="btnRow" style={{ justifyContent: 'center' }}>
                    <button className="btn btnPrimary" style={{ width: 'min(360px, 100%)' }} onClick={() => startStage('run')}>
                      Start timed probe
                    </button>
                  </div>
                </>
              )}

              {(stage === 'practice' || stage === 'run') && (
                <>
                  <div style={{ marginTop: 12, color: 'var(--deep)', fontWeight: 800 }}>
                    {stage === 'run' ? `Time left: ${remainingSec}s` : 'Practice mode'} | {status}
                  </div>
                  <div style={{ marginTop: 6, color: 'rgba(0,0,0,0.75)', fontWeight: 700 }}>{trialLabel}</div>

                  <div
                    onClick={handleResponse}
                    style={{
                      margin: '18px auto 0',
                      height: 240,
                      borderRadius: 20,
                      background: 'rgba(0,0,0,0.08)',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      cursor: 'pointer',
                      userSelect: 'none'
                    }}
                  >
                    {showTarget
                      ? <div style={{ width: 60, height: 60, borderRadius: '50%', background: 'var(--deep)' }} />
                      : <div style={{ color: 'rgba(0,0,0,0.55)', fontWeight: 800 }}>Wait...</div>
                    }
                  </div>

                  <div className="btnRow" style={{ justifyContent: 'center' }}>
                    <button
                      className="btn btnSecondary"
                      style={{ width: 'min(360px, 100%)' }}
                      onClick={() => {
                        runningRef.current = false;
                        clearAllTimers();
                        setStage('intro');
                        setStatus('Stopped');
                      }}
                    >
                      Stop
                    </button>
                  </div>
                </>
              )}

              {stage === 'done' && summary && (
                <>
                  <div className="card" style={{ boxShadow: 'none', marginTop: 12, textAlign: 'left' }}>
                    <div className="p" style={{ fontWeight: 900, color: 'rgba(0,0,0,0.85)' }}>Readiness metrics</div>
                    <p className="p" style={{ marginTop: 6 }}>
                      Median RT: <span style={{ fontWeight: 900 }}>{summary.medianMs ?? '-'}</span> ms
                      <span style={{ color: '#111' }}> | RT CV: </span>
                      <span style={{ fontWeight: 900 }}>{summary.rtCv ?? '-'}</span>
                      <span style={{ color: '#111' }}> | Lapses: </span>
                      <span style={{ fontWeight: 900 }}>{summary.lapses ?? 0}</span>
                      <span style={{ color: '#111' }}> | False starts: </span>
                      <span style={{ fontWeight: 900 }}>{summary.falseStarts ?? 0}</span>
                    </p>
                    <p className="p" style={{ marginTop: 6 }}>
                      Readiness band: <span style={{ fontWeight: 900 }}>{summary.readinessBand || 'calibrating'}</span>
                      {summary.readinessIndex !== null ? (
                        <span style={{ color: '#111' }}> | Index: <span style={{ fontWeight: 900 }}>{summary.readinessIndex}</span></span>
                      ) : null}
                      <span style={{ color: '#111' }}> | Baseline checks: </span>
                      <span style={{ fontWeight: 900 }}>{summary.baselineCount ?? 0}</span>
                    </p>
                  </div>

                  <div className="btnRow" style={{ justifyContent: 'center' }}>
                    <button className="btn btnSecondary" style={{ width: 'min(360px, 100%)' }} onClick={() => startStage('run')}>
                      Run again
                    </button>
                    <button className="btn btnPrimary" style={{ width: 'min(360px, 100%)' }} onClick={() => onComplete?.(summary)}>
                      Continue
                    </button>
                  </div>
                </>
              )}
            </div>
          </div>

          <div className="footer">
            <span>Mindware Lab | Trident</span>
            <a className="link" href={CAPACITY_TRAINING_COACH_URL} target="_blank" rel="noreferrer">Capacity Coach</a>
          </div>
        </div>
      );
    }

 // -----------------------------
// ZoneCoach app (BRANDED)
// -----------------------------
function ZoneCoach() {
  const [showSplash, setShowSplash] = useState(true);
  const [step, setStep] = useState('ratings');

  const [ratings, setRatings] = useState({ E: 5, S: 5, F: 5, N: 5, O: 5, C: 5, R: 5 });
  const [externalDistractions, setExternalDistractions] = useState(false);

  const [probePre, setProbePre] = useState(null);
  const [probePost, setProbePost] = useState(null);

  const [classification, setClassification] = useState(null);
  const [breathPattern, setBreathPattern] = useState(null);
  const [postBreathReport, setPostBreathReport] = useState(null);

  const interruptionsRef = useRef({ tabSwitches: 0, blurs: 0 });

  useEffect(() => {
    const onBlur = () => { interruptionsRef.current.blurs += 1; };
    const onVisibilityChange = () => {
      if (document.hidden) interruptionsRef.current.tabSwitches += 1;
    };

    window.addEventListener('blur', onBlur);
    document.addEventListener('visibilitychange', onVisibilityChange);
    return () => {
      window.removeEventListener('blur', onBlur);
      document.removeEventListener('visibilitychange', onVisibilityChange);
    };
  }, []);

  const brand = useMemo(() => ({
    appName: 'Zone Coach',
    subtitle: 'Quick state check -> mindful reset -> start training',
    accent: 'var(--deep)',
    logoSrc: '../../../../branding/Trident-G-Icon.svg'
  }), []);

  const safeJsonParse = (s, fallback) => {
    try { return JSON.parse(s); } catch { return fallback; }
  };

  const writeZoneTelemetry = (zoneTelemetry, zoneHandoffSlim) => {
    try {
      const history = safeJsonParse(localStorage.getItem(LS_KEYS.ZONE_HISTORY) || '[]', []);
      history.push(zoneTelemetry);
      while (history.length > 30) history.shift();
      localStorage.setItem(LS_KEYS.ZONE_HISTORY, JSON.stringify(history));

      localStorage.setItem(LS_KEYS.ZONE_LAST, JSON.stringify(zoneTelemetry));

      // Slim handoff for capacity coach
      localStorage.setItem(LS_KEYS.CAPACITY_FROM_ZONE, JSON.stringify(zoneHandoffSlim));

      // Cross-app fallback handoff (helps older/newer coach variants)
      const fallback = {
        schemaVersion: 'mw_handoff_v1',
        timestamp: zoneTelemetry.timestamp,
        zone: zoneHandoffSlim.gate.zone, // too_cold | in_band | too_hot
        recommendation: zoneHandoffSlim.gate.recommendation, // proceed | light
        capacityFocus: zoneTelemetry.suggest?.capacityFocus || null,
        rigourBudget: zoneTelemetry.suggest?.rigourBudget || null,
        timeboxMins: zoneTelemetry.suggest?.timeboxMins || null
      };
      localStorage.setItem(FALLBACK_CAPACITY_KEY, JSON.stringify(fallback));
    } catch (e) {
      console.error('Storage error:', e);
    }
  };

  const handleRatingsSubmit = () => {
    const result = classifyMode(ratings, externalDistractions);
    const pattern = selectBreathingPattern(result.primaryMode);
    setClassification(result);
    setBreathPattern(pattern);
    setStep('probePre');
  };

  const handleStartBreathing = () => setStep('breathing');
  const handleBreathingComplete = () => setStep('probePost');

  const handlePostBreathSubmit = (report) => {
    setPostBreathReport(report);

    const zoneGate = toZoneGate(classification.primaryMode);

    const preInBand = classification.primaryMode === 'PSI';
    const postInBand = report === 'Psi-band';
    const stateConfidence = computeStateConfidence({
      signalClarity: null,
      probe: probePre,
      interruptions: interruptionsRef.current,
      ratings
    });
    const overallConfidence = computeOverallConfidence(classification.confidence, stateConfidence);
    const signalQualityLocal = computeSignalQuality({
      probe: probePre,
      interruptions: interruptionsRef.current,
      ratings
    });
    const proceedNormal =
      (postInBand || preInBand)
      && overallConfidence !== 'Low'
      && signalQualityLocal.label !== 'Poor';

    const derived = {
      N_eff: classification.N_eff,
      pressure: (ratings.S + ratings.O) / 2,
      interference: (ratings.N + ratings.C) / 2,
      load: (ratings.O + ratings.C + ratings.R) / 3,
      stability: (ratings.F + (10 - ratings.R)) / 2
    };

    const suggestedCapacity = suggestedCapacityFromMode(classification.primaryMode);

    const zoneTelemetry = {
      schemaVersion: 'zone_v1',
      timestamp: new Date().toISOString(),
      ratings,
      externalDistractions,
      derived,
      classifier: {
        primaryMode: classification.primaryMode,
        label: MODE_LABELS[classification.primaryMode],
        modeProbs: classification.modeProbs,
        confidence: classification.confidence,
        modeConfidence: classification.confidence,
        stateConfidence,
        overallConfidence
      },
      signalQuality: signalQualityLocal,
      interruptions: { ...interruptionsRef.current },
      breathing: {
        patternId: breathPattern,
        patternName: BREATH_PATTERNS[breathPattern].name,
        completed: true,
        postBreathSelfReport: report
      },
      probe: {
        pre: probePre,
        post: probePost
      },
      gate: {
        zone: zoneGate, // too_cold|in_band|too_hot
        preInBand,
        postInBand,
        recommendation: proceedNormal ? 'proceed' : 'light'
      },
      suggest: {
        rigourBudget: zoneGate === 'in_band' ? 'medium' : 'low',
        timeboxMins: zoneGate === 'in_band' ? 10 : 8,
        capacityFocus: suggestedCapacity
      }
    };

    const zoneHandoffSlim = {
      schemaVersion: 'zone_to_capacity_v1',
      timestamp: zoneTelemetry.timestamp,
      gate: {
        zone: zoneTelemetry.gate.zone,
        preInBand: zoneTelemetry.gate.preInBand,
        postInBand: zoneTelemetry.gate.postInBand,
        recommendation: zoneTelemetry.gate.recommendation
      },
      suggest: zoneTelemetry.suggest
    };

    writeZoneTelemetry(zoneTelemetry, zoneHandoffSlim);
    setStep('complete');
  };

  const stateConfidence = classification
    ? computeStateConfidence({
      signalClarity: null,
      probe: probePre,
      interruptions: interruptionsRef.current,
      ratings
    })
    : null;
  const overallConfidence = classification
    ? computeOverallConfidence(classification.confidence, stateConfidence)
    : null;
  const signalQuality = classification
    ? computeSignalQuality({
      probe: probePre,
      interruptions: interruptionsRef.current,
      ratings
    })
    : null;

  const startNewCheck = () => {
    setStep('ratings');
    interruptionsRef.current = { tabSwitches: 0, blurs: 0 };
    setPostBreathReport(null);
    setClassification(null);
    setBreathPattern(null);
    setProbePre(null);
    setProbePost(null);
  };

  // ----- Shared frame (topbar + footer) -----
  const Frame = ({ chip, children }) => (
    <div className="screen">
      <div className="topbar">
        <div className="brandleft">
          <div className="icon">
            <img
              src={brand.logoSrc}
              alt="Trident logo"
              onError={(e) => { e.target.style.display = 'none'; }}
            />
          </div>
          <div>
            <p className="title">{brand.appName}</p>
            <p className="subtitle">{brand.subtitle}</p>
          </div>
        </div>
        <div className="chip">{chip}</div>
      </div>

      <div className="content">{children}</div>

      <div className="footer">
        <span>Mindware Lab | Trident</span>
        <a className="link" href={CAPACITY_TRAINING_COACH_URL} target="_blank" rel="noreferrer">
          Capacity Coach
        </a>
      </div>
    </div>
  );

  // ----- Splash -----
  if (showSplash) {
    return (
      <div className="screen">
        <div className="topbar">
          <div className="brandleft">
            <div className="icon">
              <img
                src={brand.logoSrc}
                alt="Trident logo"
                onError={(e) => { e.target.style.display = 'none'; }}
              />
            </div>
            <div>
              <p className="title">{brand.appName}</p>
              <p className="subtitle">{brand.subtitle}</p>
            </div>
          </div>
          <div className="chip">Start</div>
        </div>

        <div className="content" style={{ justifyContent: 'center' }}>
          <div className="card" style={{ maxWidth: 560, margin: '0 auto', textAlign: 'center' }}>
            <div style={{ display: 'flex', justifyContent: 'center', marginBottom: 14 }}>
              <div className="icon">
                <img
                  src={brand.logoSrc}
                  alt="Trident logo"
                  onError={(e) => { e.target.style.display = 'none'; }}
                />
              </div>
            </div>

            <div className="h1" style={{ fontSize: 26, marginBottom: 8 }}>{brand.appName}</div>
            <p className="p" style={{ fontSize: 14 }}>{brand.subtitle}</p>

            <div className="btnRow" style={{ justifyContent: 'center' }}>
              <button className="btn btnPrimary" style={{ width: 'min(360px, 100%)' }} onClick={() => setShowSplash(false)}>
                Continue
              </button>
            </div>

            <p className="p" style={{ marginTop: 10 }}>Mindware Lab | Trident</p>
          </div>
        </div>
      </div>
    );
  }

  // ----- Probe pre -----
  if (!showSplash && step === 'probePre') {
    return (
      <DotProbe
        label="Probe"
        brand={brand}
        durationSec={180}
        onComplete={(result) => {
          setProbePre(result);
          setStep('results');
        }}
      />
    );
  }

  // ----- Breathing -----
  if (step === 'breathing') {
    return (
      <BreathingCoach
        patternId={breathPattern}
        onComplete={handleBreathingComplete}
        brand={brand}
      />
    );
  }

  // ----- Probe post -----
  if (step === 'probePost') {
    return (
      <DotProbe
        label="Recheck"
        brand={brand}
        durationSec={90}
        isRecheck={true}
        onComplete={(result) => {
          setProbePost(result);
          setStep('postBreath');
        }}
      />
    );
  }

  // ----- Main flow -----
  return (
    <Frame chip={step === 'ratings' ? 'Check' : step === 'results' ? 'Result' : step === 'postBreath' ? 'Report' : 'Next'}>
      <div className="card" style={{ maxWidth: 820, margin: '0 auto' }}>

        {step === 'ratings' && (
          <>
            <div className="h1">Zone check</div>
            <p className="p">Rate how you feel right now (0 = not at all, 10 = extremely).</p>

            <div style={{ marginTop: 10 }}>
              {SLIDERS.map(s => (
                <div key={s.key} className="card" style={{ boxShadow: 'none', marginTop: 12 }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'baseline', gap: 10 }}>
                    <div className="sliderLabel">{s.label}</div>
                    <div className="sliderValue">{ratings[s.key]}</div>
                  </div>
                  <p className="p" style={{ marginTop: 6, marginBottom: 10 }}>{s.desc}</p>

                  <input
                    type="range"
                    min="0"
                    max="10"
                    value={ratings[s.key]}
                    onChange={(e) => setRatings({ ...ratings, [s.key]: parseInt(e.target.value, 10) })}
                    className="sliderControl"
                  />
                </div>
              ))}
            </div>

            <div className="card" style={{ boxShadow: 'none', marginTop: 12 }}>
              <label style={{ display: 'flex', alignItems: 'flex-start', gap: 10, cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={externalDistractions}
                  onChange={(e) => setExternalDistractions(e.target.checked)}
                  style={{ marginTop: 2 }}
                />
                <span className="p" style={{ margin: 0, color: 'rgba(0,0,0,0.80)', fontWeight: 800 }}>
                  Notifications, noise, people, or interruptions are affecting me right now
                </span>
              </label>
            </div>

            <div className="btnRow">
              <button onClick={handleRatingsSubmit} className="btn btnPrimary" style={{ width: '100%' }}>
                Continue to readiness check
              </button>
            </div>
          </>
        )}

        {step === 'results' && classification && (
          <>
            <div className="h1">Your current state</div>

            <div className="card" style={{ boxShadow: 'none', background: 'rgba(34,170,255,0.08)', border: '1px solid rgba(39,100,183,0.18)', marginTop: 12 }}>
              <div style={{ fontWeight: 900, fontSize: 36, color: 'rgba(0,0,0,0.90)' }}>
                {MODE_LABELS[classification.primaryMode]}
              </div>
              <p className="p" style={{ marginTop: 6 }}>
                Confidence: <span style={{ fontWeight: 900, color: 'var(--deep)' }}>{CONF_UI[overallConfidence || classification.confidence] || overallConfidence || classification.confidence}</span>
              </p>
              {signalQuality && (
                <>
                  <p className="p" style={{ marginTop: 6 }}>
                    Signal quality (reliability):{' '}
                    <span
                      style={{ fontWeight: 900, color: SIGNAL_COLORS[signalQuality.label] || 'var(--deep)' }}
                      title={signalQuality.reason}
                    >
                      {signalQuality.label}
                    </span>
                  </p>
                  <p className="p" style={{ marginTop: 2, color: '#111' }}>
                    {signalQuality.reason}
                  </p>
                </>
              )}
            </div>

            <div className="card" style={{ boxShadow: 'none', marginTop: 12 }}>
              <div style={{ fontWeight: 900, fontSize: 20, color: 'rgba(0,0,0,0.85)' }}>Recommended reset</div>
              <div style={{ fontWeight: 900, fontSize: 16, color: 'var(--deep)', marginTop: 6 }}>
                {BREATH_PATTERNS[breathPattern].name}
              </div>
              <p className="p" style={{ marginTop: 6 }}>{BREATH_PATTERNS[breathPattern].description}</p>
              <p className="p" style={{ marginTop: 8 }}>Do the 3-minute reset, then we will decide the best training intensity.</p>

              <div className="btnRow">
                <button onClick={handleStartBreathing} className="btn btnPrimary" style={{ width: '100%' }}>
                  Start 3-minute reset
                </button>
                <button onClick={startNewCheck} className="btn btnSecondary" style={{ width: '100%' }}>
                  Back
                </button>
              </div>
            </div>
          </>
        )}

        {step === 'postBreath' && (
          <>
            <div className="h1">How do you feel now?</div>
            <p className="p">Quick check after your breathing reset.</p>

            <div style={{ display: 'flex', flexDirection: 'row', justifyContent: 'center', gap: 10, marginTop: 12 }}>
              {[
                { label: 'Flat / low drive', value: 'Subcritical' },
                { label: 'In the G Zone', value: 'Psi-band' },
                { label: 'Overloaded & scattered', value: 'Supercritical - explore' },
                { label: 'Over-tight & stuck', value: 'Supercritical - rigid control' },
                { label: 'Not sure', value: 'Not sure' }
              ].map(opt => (
                <button
                  key={opt.value}
                  onClick={() => handlePostBreathSubmit(opt.value)}
                  className="btn btnSecondary"
                  style={{ textAlign: 'left', width: '100%' }}
                >
                  {opt.label}
                </button>
              ))}
            </div>
          </>
        )}

        {step === 'complete' && classification && (
          <>
            <div className="h1">Reset complete</div>

            <div className="card" style={{ boxShadow: 'none', background: 'rgba(34,170,255,0.08)', border: '1px solid rgba(39,100,183,0.18)', marginTop: 12 }}>
              <div style={{ fontWeight: 900, fontSize: 16, color: 'rgba(0,0,0,0.90)' }}>
                Post-breath: <span style={{ color: 'var(--deep)' }}>{postBreathReport}</span>
              </div>
            </div>

            {(() => {
              const zoneGate = toZoneGate(classification.primaryMode);
              const preInBand = classification.primaryMode === 'PSI';
              const postInBand = postBreathReport === 'Psi-band';
              const proceedNormal =
                (preInBand || postInBand)
                && overallConfidence !== 'Low'
                && (!signalQuality || signalQuality.label !== 'Poor');

              const suggestion = suggestedCapacityFromMode(classification.primaryMode);

              return (
                <div className="card" style={{ boxShadow: 'none', marginTop: 12 }}>
                  <div style={{ fontWeight: 900, fontSize: 14, color: 'rgba(0,0,0,0.85)' }}>Next step</div>

                  <p className="p" style={{ marginTop: 8 }}>
                    Zone gate: <span style={{ fontWeight: 900, color: 'rgba(0,0,0,0.90)' }}>{ZONE_UI[zoneGate]?.title || '-'}</span>
                    <span style={{ color: '#111' }}> | Suggested focus: </span>
                    <span style={{ fontWeight: 900, color: 'rgba(0,0,0,0.90)' }}>{suggestion.primary}</span>
                    {suggestion.secondary ? <span style={{ color: '#111' }}> then </span> : null}
                    {suggestion.secondary ? <span style={{ fontWeight: 900, color: 'rgba(0,0,0,0.90)' }}>{suggestion.secondary}</span> : null}
                  </p>

                  {proceedNormal ? (
                    <>
                      <p className="p" style={{ marginTop: 8, color: 'rgba(0,0,0,0.80)', fontWeight: 800 }}>
                        Proceed with training.
                      </p>
                      <div className="btnRow">
                        <button
                          onClick={() => window.open(CAPACITY_TRAINING_COACH_URL, '_blank')}
                          className="btn btnPrimary"
                          style={{ width: '100%' }}
                        >
                          Go to Capacity Training Coach
                        </button>
                      </div>
                      <p className="p" style={{ marginTop: 8 }}>
                        Your zone handoff has been saved for the coach/switcher.
                      </p>
                    </>
                  ) : (
                    <>
                      <p className="p" style={{ marginTop: 8, color: 'rgba(0,0,0,0.80)', fontWeight: 800 }}>
                        Light session recommended.
                      </p>
                      <p className="p" style={{ marginTop: 6 }}>
                        You were not fully in band today. Keep it short and stabilising.
                      </p>

                      <div className="btnRow">
                        <button
                          onClick={() => window.open(CAPACITY_TRAINING_COACH_URL, '_blank')}
                          className="btn btnPrimary"
                          style={{ width: '100%' }}
                        >
                          Proceed with a light session (Recover focus)
                        </button>
                      </div>

                      <div className="card" style={{ boxShadow: 'none', marginTop: 10 }}>
                        <p className="p" style={{ margin: 0 }}>
                          If you still feel overloaded: walk, hydration, low stimulation, early night. Try again tomorrow.
                        </p>
                      </div>

                      <p className="p" style={{ marginTop: 8 }}>
                        Your zone handoff has been saved for the coach/switcher.
                      </p>
                    </>
                  )}

                  <div className="btnRow">
                    <button onClick={startNewCheck} className="btn btnSecondary" style={{ width: '100%' }}>
                      Start new check
                    </button>
                  </div>
                </div>
              );
            })()}
          </>
        )}

      </div>
    </Frame>
  );
}

// React 18 root
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<ZoneCoach />);
