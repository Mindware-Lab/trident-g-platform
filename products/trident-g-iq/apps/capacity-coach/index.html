<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Capacity Training Coach</title>
  <link rel="stylesheet" href="../../../../branding/brand.css">
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

<script type="text/babel" data-presets="env,react">
  const { useEffect, useMemo, useState } = React;

  const STORAGE = {
    PROGRESS: 'iqmw.progress.v1',
    PROGRESS_LEGACY: 'trainingProgress',
    CAPACITY_LAST_GAME: 'iqmw.capacity.lastGameSelection',
    CAPACITY_LAST_SESSION: 'iqmw.capacity.lastSession',
    SETTINGS_V11: 'iqmw.capacity.settings.v1',
    PROGRAM_V11: 'iqmw.capacity.program.v1',
    SESSIONS_V11: 'iqmw.capacity.sessions.v1',
    MISSIONS_V11: 'iqmw.capacity.missions.v1'
  };

  const PROGRAM_TARGET = 24;
  const SESSION_TYPES = ['TUNE', 'EXPLORE', 'TIGHTEN', 'PROBE', 'RECHECK', 'RESET'];
  const GAME_ENUM = {
    classic: 'CLASSIC',
    emotional: 'EMOTIONAL',
    non_categorical: 'NONCAT',
    logic_gated: 'OUTPUT_GATED'
  };
  const GAME_ID_FROM_ENUM = {
    CLASSIC: 'classic',
    EMOTIONAL: 'emotional',
    NONCAT: 'non_categorical',
    OUTPUT_GATED: 'logic_gated'
  };
  const DEFAULT_SETTINGS_V11 = {
    schemaVersion: 'capacity_settings_v1_1',
    thresholds: {
      plateau_epsilon: 0.25,
      churn_volatility: 5,
      probe_swap_cost_min: -1,
      probe_recovery_delta_min: -0.5,
      probe_end_hold_min: -1,
      recheck_mean_tolerance: 1.0
    },
    defaults: {
      pulse_block_index: 4,
      recovery_blocks: [5, 6],
      end_hold_block: 10
    }
  };
  // Planned opportunities only: these slots can be deferred when out-of-band or data-quality is compromised.
  const makeScaffold = () => Array.from({ length: PROGRAM_TARGET }, (_, i) => ({
    program_day: i + 1,
    probe_slot: (i + 1) % 4 === 0,
    recheck_slot: i + 1 === 12 || i + 1 === 24
  }));
  const DEFAULT_PROGRAM_V11 = {
    schemaVersion: 'capacity_program_v1_1',
    // Legacy-only counter kept for back-compat with earlier app state.
    // Do not use as source of truth for new flow logic.
    program_day_completed: 0,
    // Authoritative training-session counter (increments on TRAINING entries only).
    program_session_index: 0,
    calendar_entry_count: 0,
    consecutive_rest_count: 0,
    anchor_lane: 'CLASSIC',
    last_probe_radius_passed: null,
    scaffold: makeScaffold()
  };

  const GAMES = [
    { id: 'classic', label: 'Classic n-back', note: 'Default start for Type-1 stability.' },
    { id: 'emotional', label: 'Emotional n-back', note: 'Add salience control under load.' },
    { id: 'non_categorical', label: 'Non-categorical n-back', note: 'Train broad runtime control.' },
    { id: 'logic_gated', label: 'Logic-gated n-back', note: 'Rule discipline and clean updating.' }
  ];
  const GAME_LABEL = GAMES.reduce((acc, g) => ({ ...acc, [g.id]: g.label }), {});

  const BREATH_ROUTINES = {
    upshift: {
      name: 'Upshift',
      description: 'Inhale-led breathing to raise engagement.',
      cue: 'Inhale 3s, exhale 2s.'
    },
    amplify: {
      name: 'Amplify',
      description: 'Slow-paced breathing to stabilise.',
      cue: 'Inhale 4s, exhale 6s.'
    },
    downshift: {
      name: 'Downshift',
      description: 'Cyclic sighing to reduce overload.',
      cue: 'Two short inhales, one long sigh out.'
    }
  };

  const safeParse = (raw, fallback) => {
    try { return JSON.parse(raw); } catch { return fallback; }
  };
  const mean = (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
  const uid = () => 'id_' + Math.random().toString(36).slice(2, 10) + '_' + Date.now().toString(36);
  const saveJson = (key, value) => {
    try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
  };
  const loadProgramV11 = () => {
    const raw = safeParse(localStorage.getItem(STORAGE.PROGRAM_V11), {});
    return {
      ...DEFAULT_PROGRAM_V11,
      ...raw,
      program_session_index: Number(raw.program_session_index ?? raw.program_day_completed ?? 0),
      scaffold: Array.isArray(raw.scaffold) && raw.scaffold.length === PROGRAM_TARGET ? raw.scaffold : makeScaffold()
    };
  };
  const loadSessionsV11 = () => {
    const rows = safeParse(localStorage.getItem(STORAGE.SESSIONS_V11), []);
    return Array.isArray(rows) ? rows : [];
  };
  const loadMissionsV11 = () => {
    const rows = safeParse(localStorage.getItem(STORAGE.MISSIONS_V11), []);
    return Array.isArray(rows) ? rows : [];
  };
  const loadSettingsV11 = () => {
    const raw = safeParse(localStorage.getItem(STORAGE.SETTINGS_V11), {});
    return {
      ...DEFAULT_SETTINGS_V11,
      ...raw,
      thresholds: { ...DEFAULT_SETTINGS_V11.thresholds, ...(raw.thresholds || {}) },
      defaults: { ...DEFAULT_SETTINGS_V11.defaults, ...(raw.defaults || {}) }
    };
  };
  const getTrainingSessions = (rows) => rows.filter((x) => x.entry_type === 'TRAINING');
  const nextProbeRadius = (lastPassed) => {
    if (!lastPassed) return 'NEAR';
    if (lastPassed === 'NEAR') return 'MID';
    return 'FAR';
  };
  const probeTargetFor = (anchor, radius) => {
    const map = {
      CLASSIC: { NEAR: 'EMOTIONAL', MID: 'NONCAT', FAR: 'OUTPUT_GATED' },
      EMOTIONAL: { NEAR: 'CLASSIC', MID: 'OUTPUT_GATED', FAR: 'NONCAT' },
      NONCAT: { NEAR: 'CLASSIC', MID: 'OUTPUT_GATED', FAR: 'EMOTIONAL' },
      OUTPUT_GATED: { NEAR: 'CLASSIC', MID: 'NONCAT', FAR: 'EMOTIONAL' }
    };
    return map[anchor]?.[radius] || 'CLASSIC';
  };
  const computeDerivedFromNTrace = (nTrace, pulseCfg = { block_index: 4, recovery_blocks: [5, 6] }) => {
    const n = nTrace.map((x) => Number(x));
    const volatility = n.slice(1).reduce((acc, v, i) => acc + (v !== n[i] ? 1 : 0), 0);
    const dropDeltas = n.slice(1).map((v, i) => n[i] - v).filter((d) => d > 0);
    const baselineMean = mean([n[0], n[1]]);
    const recBlocks = (pulseCfg?.recovery_blocks || [5, 6]).map((ix) => n[Math.max(0, Math.min(9, ix - 1))]);
    const recoveryMean = mean(recBlocks);
    return {
      mean_n: Number(mean(n).toFixed(2)),
      volatility,
      drop_count: dropDeltas.length,
      max_drop: dropDeltas.length ? Math.max(...dropDeltas) : 0,
      end_hold_delta: Number((n[9] - baselineMean).toFixed(2)),
      baseline_mean: Number(baselineMean.toFixed(2)),
      recovery_delta: Number((recoveryMean - baselineMean).toFixed(2))
    };
  };
  const trendFlags = (sameLaneSessions, epsilon = 0.25) => {
    const last3 = sameLaneSessions.slice(-3);
    if (last3.length < 3) return { plateau: false, churn: false, breakthrough: false };
    const [a, b, c] = last3.map((s) => s.derived || {});
    const plateau = (Number(c.mean_n || 0) - Number(a.mean_n || 0)) < epsilon && mean([a.volatility || 0, b.volatility || 0, c.volatility || 0]) <= 2;
    const churn = (c.volatility || 0) > 5 || (c.end_hold_delta || 0) < -1;
    const breakthrough = (Number(c.mean_n || 0) - Number(b.mean_n || 0)) >= 1 || (((b.volatility || 0) > 0) && ((c.volatility || 99) <= Math.max(1, (b.volatility || 1) / 2)) && ((c.end_hold_delta || -99) > (b.end_hold_delta || -99)));
    return { plateau, churn, breakthrough };
  };

  const loadProgress = () => {
    const fromNew = safeParse(localStorage.getItem(STORAGE.PROGRESS), null);
    const fromLegacy = safeParse(localStorage.getItem(STORAGE.PROGRESS_LEGACY), null);
    const raw = fromNew || fromLegacy || {};

    const completed = Number(raw.totalSessionsCompleted)
      || Number(raw.anchorSessionsCompleted) + Number(raw.swapSessionsCompleted)
      || 0;

    return {
      schemaVersion: 'progress_v1',
      totalSessionsCompleted: completed,
      totalSessionsTarget: PROGRAM_TARGET,
      lastSessionDate: raw.lastSessionDate || null,
      programStartDate: raw.programStartDate || new Date().toISOString(),
      programCompleted: completed >= PROGRAM_TARGET,
      programCompletionDate: raw.programCompletionDate || null
    };
  };

  const saveProgress = (next) => {
    const json = JSON.stringify(next);
    localStorage.setItem(STORAGE.PROGRESS, json);
    localStorage.setItem(STORAGE.PROGRESS_LEGACY, json);
  };

  function App() {
    const [screen, setScreen] = useState('home');
    const [progress, setProgress] = useState(() => loadProgress());
    const [settingsV11] = useState(() => loadSettingsV11());
    const [programV11, setProgramV11] = useState(() => loadProgramV11());
    const [sessionsV11, setSessionsV11] = useState(() => loadSessionsV11());
    const [missionsV11, setMissionsV11] = useState(() => loadMissionsV11());
    const [zoneMode, setZoneMode] = useState('in_band');
    const [planType, setPlanType] = useState('type1_build');
    const [stateRatings, setStateRatings] = useState({ load: 4, drift: 4, mismatch: 4 });
    const [lastStateReason, setLastStateReason] = useState('');
    const [selectedGame, setSelectedGame] = useState('classic');
    const [speedPreset, setSpeedPreset] = useState('calm');
    const [interferencePreset, setInterferencePreset] = useState('low');
    const [bridgeObs, setBridgeObs] = useState('');
    const [bridgeMove, setBridgeMove] = useState('');
    const [breathRoutine, setBreathRoutine] = useState('amplify');
    const [breathRunning, setBreathRunning] = useState(false);
    const [breathRemaining, setBreathRemaining] = useState(0);
    const [restConfirm, setRestConfirm] = useState(false);
    const [restReason, setRestReason] = useState('');
    const [sessionType, setSessionType] = useState('TUNE');
    const [baselineMode, setBaselineMode] = useState('ADAPTIVE');
    const [fixedN, setFixedN] = useState(2);
    const [pulseType, setPulseType] = useState('');
    const [pulseBlockIndex, setPulseBlockIndex] = useState(4);
    const [recoveryBlocksCsv, setRecoveryBlocksCsv] = useState('5,6');
    const [endHoldBlock, setEndHoldBlock] = useState(10);
    const [outputGateMode, setOutputGateMode] = useState('OR');
    const [nTraceInput, setNTraceInput] = useState(Array.from({ length: 10 }, () => ''));
    const [blockDone, setBlockDone] = useState(Array.from({ length: 10 }, () => false));
    const [noResponseBlocks, setNoResponseBlocks] = useState([]);
    const [fixedNBlocks, setFixedNBlocks] = useState([]);
    const [planConfirmed, setPlanConfirmed] = useState(false);
    const [temptationPressure, setTemptationPressure] = useState('');

    const selectedGameObj = useMemo(
      () => GAMES.find((g) => g.id === selectedGame) || GAMES[0],
      [selectedGame]
    );

    const trainingSessionsV11 = useMemo(() => getTrainingSessions(sessionsV11), [sessionsV11]);
    const sessionsRemaining = Math.max(0, PROGRAM_TARGET - (programV11.program_session_index || 0));
    const pendingMission = useMemo(() => missionsV11.find((m) => !m.outcome) || null, [missionsV11]);
    const recommendationV11 = useMemo(() => {
      const zoneRecommendation = zoneMode === 'reset' ? 'RESET' : (zoneMode === 'light' ? 'LIGHT' : 'FULL');
      const lane = programV11.anchor_lane || 'CLASSIC';
      const sameLane = trainingSessionsV11.filter((s) => s.game === lane);
      const tf = trendFlags(sameLane, settingsV11.thresholds.plateau_epsilon);
      const row = programV11.scaffold[Math.max(0, programV11.program_session_index)] || { probe_slot: false, recheck_slot: false };
      const latestTraining = [...trainingSessionsV11].reverse().find(Boolean);
      const dataQualityAllowsProbe = !latestTraining || latestTraining.data_quality !== 'COMPROMISED';
      let session_type = 'TUNE';
      let reason = 'Stable training day.';
      let game = lane;
      let probe_radius = null;
      let probe_target_game = null;

      if (zoneRecommendation === 'RESET') {
        session_type = 'RESET';
        reason = 'Zone gate recommends reset conditions.';
      } else if (zoneRecommendation === 'LIGHT') {
        session_type = 'TIGHTEN';
        reason = 'Zone gate recommends lighter stabilisation.';
      }
      if (tf.churn && zoneRecommendation !== 'RESET') {
        session_type = 'TIGHTEN';
        reason = 'Recent churn signal. Stabilise before pushing.';
      }
      if ((tf.breakthrough || row.probe_slot) && zoneRecommendation === 'FULL' && dataQualityAllowsProbe) {
        session_type = 'PROBE';
        probe_radius = nextProbeRadius(programV11.last_probe_radius_passed);
        probe_target_game = probeTargetFor(lane, probe_radius);
        game = probe_target_game;
        reason = tf.breakthrough ? 'Breakthrough cue detected; run state-gated probe.' : 'Planned probe opportunity.';
      }
      if (row.recheck_slot && zoneRecommendation === 'FULL' && dataQualityAllowsProbe) {
        const lastCleanTune = [...trainingSessionsV11].reverse().find((s) => s.session_type === 'TUNE' && s.data_quality !== 'COMPROMISED');
        if (lastCleanTune) {
          session_type = 'RECHECK';
          game = lastCleanTune.game;
          reason = 'Planned delay re-check opportunity.';
        }
      }
      if (tf.plateau && zoneRecommendation === 'FULL' && stateRatings.drift >= 6) {
        session_type = 'EXPLORE';
        game = lane === 'CLASSIC' ? 'EMOTIONAL' : 'CLASSIC';
        reason = 'Plateau + drift signal; controlled explore day.';
      }
      return { recommended_session_type: session_type, recommendation_reason: reason, recommended_game: game, probe_radius, probe_target_game };
    }, [zoneMode, programV11, trainingSessionsV11, settingsV11, stateRatings]);

    const computePlanType = (zone) => {
      if (zone !== 'in_band') return 'type1_light';
      return 'type1_build';
    };

    const estimateZoneFromRatings = () => {
      const vals = [stateRatings.load, stateRatings.drift, stateRatings.mismatch];
      const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
      const peak = Math.max(...vals);
      let nextZone = 'in_band';
      let reason = 'Low volatility and manageable load.';
      if (peak >= 8 || avg >= 7) {
        nextZone = 'reset';
        reason = 'High strain detected. Downshift before hard training.';
      } else if (avg >= 5) {
        nextZone = 'light';
        reason = 'Moderate instability. Keep session light and clean.';
      }
      setZoneMode(nextZone);
      setPlanType(computePlanType(nextZone));
      setLastStateReason(reason);
      if (nextZone === 'reset') setBreathRoutine('downshift');
      else if (nextZone === 'light') setBreathRoutine('amplify');
      else setBreathRoutine('upshift');
    };

    useEffect(() => {
      if (!breathRunning || breathRemaining <= 0) return;
      const id = setInterval(() => setBreathRemaining((s) => s - 1), 1000);
      return () => clearInterval(id);
    }, [breathRunning, breathRemaining]);

    useEffect(() => {
      if (breathRunning && breathRemaining <= 0) setBreathRunning(false);
    }, [breathRunning, breathRemaining]);

    useEffect(() => {
      const mapped = GAME_ID_FROM_ENUM[recommendationV11.recommended_game];
      if (mapped) setSelectedGame(mapped);
    }, [recommendationV11.recommended_game]);

    useEffect(() => {
      setSessionType(recommendationV11.recommended_session_type);
    }, [recommendationV11.recommended_session_type]);

    useEffect(() => {
      saveJson(STORAGE.SETTINGS_V11, settingsV11);
    }, [settingsV11]);

    useEffect(() => {
      saveJson(STORAGE.PROGRAM_V11, programV11);
      // Legacy mirror only: keep old progress keys readable by older surfaces.
      const legacy = {
        ...progress,
        totalSessionsCompleted: programV11.program_session_index,
        totalSessionsTarget: PROGRAM_TARGET,
        programCompleted: programV11.program_session_index >= PROGRAM_TARGET
      };
      saveProgress(legacy);
      setProgress(legacy);
    }, [programV11]);

    useEffect(() => {
      saveJson(STORAGE.SESSIONS_V11, sessionsV11);
    }, [sessionsV11]);

    useEffect(() => {
      saveJson(STORAGE.MISSIONS_V11, missionsV11);
    }, [missionsV11]);

    const planLabel = recommendationV11.recommended_session_type + ' session';

    const parseRecoveryBlocks = () => {
      const parsed = recoveryBlocksCsv
        .split(',')
        .map((x) => Number(x.trim()))
        .filter((x) => Number.isFinite(x) && x >= 1 && x <= 10);
      return parsed.length ? parsed : [5, 6];
    };

    const getNTraceOrNull = () => {
      const parsed = nTraceInput.map((x) => Number(x));
      if (parsed.some((x) => !Number.isFinite(x) || x < 0)) return null;
      return parsed;
    };

    const toggleBlockTag = (current, blockIndex) => (
      current.includes(blockIndex)
        ? current.filter((x) => x !== blockIndex)
        : [...current, blockIndex].sort((a, b) => a - b)
    );

    const launchExternalGame = () => {
      const handoff = {
        localDate: new Date().toISOString().slice(0, 10),
        timestamp: Date.now(),
        gameId: selectedGame,
        gameLabel: selectedGameObj.label,
        planType: recommendationV11.recommended_session_type,
        recommended_session_type: recommendationV11.recommended_session_type,
        zoneMode,
        settings: {
          speedPreset,
          interferencePreset
        },
        breathing: {
          routineId: breathRoutine,
          routineName: BREATH_ROUTINES[breathRoutine].name
        }
      };
      localStorage.setItem(STORAGE.CAPACITY_LAST_GAME, JSON.stringify(handoff));
      alert('Launch i3 Mindware (Adobe AIR), choose "' + selectedGameObj.label + '", run your block(s), then return here.');
      setScreen('results');
    };

    const saveRestDay = () => {
      if ((programV11.consecutive_rest_count || 0) >= 2 && !restConfirm) {
        alert('Reset recommended after 2 consecutive rest logs. Confirm rest again to proceed.');
        return;
      }
      const restEntry = {
        id: uid(),
        ts: new Date().toISOString(),
        entry_type: 'REST',
        is_training: false,
        program_day: programV11.program_session_index,
        reason: restReason || null
      };
      setSessionsV11((prev) => [...prev, restEntry]);
      setProgramV11((prev) => ({
        ...prev,
        calendar_entry_count: (prev.calendar_entry_count || 0) + 1,
        consecutive_rest_count: (prev.consecutive_rest_count || 0) + 1
      }));
      setRestConfirm(false);
      setRestReason('');
    };

    const completeSession = () => {
      const nTrace = getNTraceOrNull();
      if (!nTrace) {
        alert('Enter all 10 n-trace values first.');
        return;
      }
      if (!bridgeObs.trim() || !bridgeMove.trim()) {
        alert('Bridge fields are required.');
        return;
      }
      if (sessionType === 'PROBE' && !pulseType) {
        alert('PROBE sessions require one boundary probe pulse.');
        return;
      }

      const nextCompleted = Math.min(PROGRAM_TARGET, (progress.totalSessionsCompleted || 0) + 1);
      const nowIso = new Date().toISOString();
      const next = {
        ...progress,
        totalSessionsCompleted: nextCompleted,
        totalSessionsTarget: PROGRAM_TARGET,
        lastSessionDate: nowIso,
        programCompleted: nextCompleted >= PROGRAM_TARGET,
        programCompletionDate: nextCompleted >= PROGRAM_TARGET ? nowIso : progress.programCompletionDate
      };
      saveProgress(next);
      setProgress(next);

      const recoveryBlocks = parseRecoveryBlocks();
      const derived = computeDerivedFromNTrace(nTrace, { block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks });
      const dataQuality = noResponseBlocks.length ? 'COMPROMISED' : 'OK';
      const anchorLane = programV11.anchor_lane || 'CLASSIC';
      const lastCleanAnchor = [...trainingSessionsV11].reverse().find((s) => s.game === anchorLane && s.derived && s.data_quality !== 'COMPROMISED');
      const swapCost = lastCleanAnchor ? Number((derived.baseline_mean - lastCleanAnchor.derived.baseline_mean).toFixed(2)) : null;
      const probePass = sessionType === 'PROBE' && dataQuality !== 'COMPROMISED' && swapCost !== null
        ? swapCost >= settingsV11.thresholds.probe_swap_cost_min
          && derived.recovery_delta >= settingsV11.thresholds.probe_recovery_delta_min
          && derived.end_hold_delta >= settingsV11.thresholds.probe_end_hold_min
        : null;

      const recheckTarget = [...trainingSessionsV11].reverse().find((s) => s.session_type === 'TUNE' && s.data_quality !== 'COMPROMISED');
      const recheckPass = sessionType === 'RECHECK' && recheckTarget && dataQuality !== 'COMPROMISED'
        ? derived.mean_n >= (recheckTarget.derived.mean_n - settingsV11.thresholds.recheck_mean_tolerance)
          && derived.end_hold_delta >= (recheckTarget.derived.end_hold_delta - 1)
        : null;

      const handoff = {
        localDate: nowIso.slice(0, 10),
        timestamp: Date.now(),
        planType: sessionType,
        recommended_session_type: recommendationV11.recommended_session_type,
        session_type: sessionType,
        gameId: selectedGame,
        gameLabel: selectedGameObj.label,
        game_enum: GAME_ENUM[selectedGame] || 'CLASSIC',
        zoneMode,
        settings: {
          speedPreset,
          interferencePreset,
          baselineMode,
          fixedN: baselineMode === 'FIXED' ? Number(fixedN) : null
        },
        pulse: pulseType ? { type: pulseType, block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks } : null,
        bridge: {
          observation: bridgeObs.trim(),
          move: bridgeMove.trim()
        }
      };
      localStorage.setItem(STORAGE.CAPACITY_LAST_SESSION, JSON.stringify(handoff));
      localStorage.setItem(STORAGE.CAPACITY_LAST_GAME, JSON.stringify(handoff));

      const trainingEntry = {
        id: uid(),
        ts: nowIso,
        entry_type: 'TRAINING',
        is_training: true,
        program_day: (programV11.program_session_index || 0) + 1,
        recommended_session_type: recommendationV11.recommended_session_type,
        session_type: sessionType,
        recommendation_reason: recommendationV11.recommendation_reason,
        game: GAME_ENUM[selectedGame] || 'CLASSIC',
        output_gate_mode: selectedGame === 'logic_gated' ? outputGateMode : null,
        zone: {
          load: stateRatings.load,
          drift: stateRatings.drift,
          mismatch: stateRatings.mismatch,
          recommendation: zoneMode === 'reset' ? 'RESET' : (zoneMode === 'light' ? 'LIGHT' : 'FULL')
        },
        plan: {
          baseline: {
            speed: speedPreset.toUpperCase(),
            interference: interferencePreset.toUpperCase(),
            mode: baselineMode,
            fixed_n: baselineMode === 'FIXED' ? Number(fixedN) : null
          },
          pulse: pulseType ? { type: pulseType, block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks } : null,
          end_hold_block: Number(endHoldBlock)
        },
        log: {
          n_trace: nTrace,
          no_response_blocks: noResponseBlocks.slice(),
          fixed_n_blocks: fixedNBlocks.slice(),
          block_done: blockDone.slice(),
          plan_confirmed: Boolean(planConfirmed),
          temptation_pressure: temptationPressure === '' ? null : Number(temptationPressure)
        },
        derived,
        data_quality: dataQuality,
        probe: {
          probe_radius: recommendationV11.probe_radius,
          probe_target_game: recommendationV11.probe_target_game,
          swap_cost: swapCost,
          pass: probePass
        },
        recheck: {
          of_session_id: recheckTarget ? recheckTarget.id : null,
          pass: recheckPass
        },
        bridge: {
          what_changed: bridgeObs.trim(),
          how_ill_use_it: bridgeMove.trim()
        }
      };
      setSessionsV11((prev) => [...prev, trainingEntry]);
      setProgramV11((prev) => ({
        ...prev,
        program_day_completed: Math.min(PROGRAM_TARGET, (prev.program_day_completed || 0) + 1),
        program_session_index: Math.min(PROGRAM_TARGET, (prev.program_session_index || 0) + 1),
        calendar_entry_count: (prev.calendar_entry_count || 0) + 1,
        consecutive_rest_count: 0,
        last_probe_radius_passed: probePass === true ? recommendationV11.probe_radius : prev.last_probe_radius_passed
      }));

      const wantsMission = window.confirm('Set a tiny cue-fired mission now? (Recommended)');
      if (wantsMission) {
        const cue = window.prompt('Mission cue (when/where it should fire):', '') || '';
        const successSignal = window.prompt('Mission success signal (binary):', '') || '';
        const valueTag = (window.prompt('Optional value tag (risk/opportunity/urgency/social_cost):', '') || '').trim();
        if (cue.trim() && successSignal.trim()) {
          const missionObj = {
            id: uid(),
            created_ts: nowIso,
            created_from_session_id: trainingEntry.id,
            cue: cue.trim(),
            success_signal: successSignal.trim(),
            value_tag: valueTag || null,
            outcome: null
          };
          setMissionsV11((prev) => [...prev, missionObj]);
        }
      }

      setScreen('home');
      setBridgeObs('');
      setBridgeMove('');
      setNTraceInput(Array.from({ length: 10 }, () => ''));
      setBlockDone(Array.from({ length: 10 }, () => false));
      setNoResponseBlocks([]);
      setFixedNBlocks([]);
      setPlanConfirmed(false);
      setTemptationPressure('');
    };

    if (screen === 'results') {
      const bridgeReady = bridgeObs.trim() && bridgeMove.trim();
      const parsed = getNTraceOrNull();
      const derivedPreview = parsed
        ? computeDerivedFromNTrace(parsed, { block_index: Number(pulseBlockIndex), recovery_blocks: parseRecoveryBlocks() })
        : null;
      const badgePreview = sessionType === 'PROBE'
        ? ((derivedPreview && derivedPreview.recovery_delta >= -0.5 && derivedPreview.end_hold_delta >= -1) ? 'probe likely pass' : 'probe needs consolidation')
        : (sessionType === 'TIGHTEN'
          ? ((derivedPreview && derivedPreview.volatility <= 4) ? 'volatility down' : 'tighten in progress')
          : (sessionType === 'RECHECK'
            ? 'delay hold test'
            : (sessionType === 'RESET' ? 'protected learning day' : 'stable + recovered')));
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><span className="iconText">T</span></div>
              <div>
                <p className="title">Capacity Training Coach</p>
                <p className="subtitle">Type-1 transfer session</p>
              </div>
            </div>
            <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
          </div>

          <main className="content">
            <section className="card">
              <h1 className="h1">Post-Session Review</h1>
              <p className="p">Played: {selectedGameObj.label} | Session type: {sessionType}</p>
              <p className="p" style={{ marginTop: '8px' }}>Outcome badge: {badgePreview}</p>
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 10px 0', fontWeight: 900 }}>Session plan (override allowed)</p>
              <div className="btnRow" style={{ marginTop: 0 }}>
                <select value={sessionType} onChange={(e) => setSessionType(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  {SESSION_TYPES.map((t) => <option key={t} value={t}>{t}</option>)}
                </select>
                <select value={baselineMode} onChange={(e) => setBaselineMode(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="ADAPTIVE">Adaptive n</option>
                  <option value="FIXED">Fixed n</option>
                </select>
                {baselineMode === 'FIXED' ? (
                  <input type="number" min="1" max="9" value={fixedN} onChange={(e) => setFixedN(Number(e.target.value || 1))} style={{ width: '88px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                ) : null}
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <select value={speedPreset} onChange={(e) => setSpeedPreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="slow">Speed: Slow</option>
                  <option value="normal">Speed: Normal</option>
                  <option value="fast">Speed: Fast</option>
                </select>
                <select value={interferencePreset} onChange={(e) => setInterferencePreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="low">Interference: Low</option>
                  <option value="normal">Interference: Normal</option>
                  <option value="high">Interference: High</option>
                </select>
                <select value={pulseType} onChange={(e) => setPulseType(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Pulse: None</option>
                  <option value="SPEED">Pulse: Speed</option>
                  <option value="INTERFERENCE">Pulse: Interference</option>
                </select>
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <input type="number" min="1" max="10" value={pulseBlockIndex} onChange={(e) => setPulseBlockIndex(Number(e.target.value || 4))} style={{ width: '90px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                <input type="text" value={recoveryBlocksCsv} onChange={(e) => setRecoveryBlocksCsv(e.target.value)} placeholder="Recovery blocks e.g. 5,6" style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                <input type="number" min="1" max="10" value={endHoldBlock} onChange={(e) => setEndHoldBlock(Number(e.target.value || 10))} style={{ width: '90px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
              </div>
              {selectedGame === 'logic_gated' ? (
                <div className="btnRow" style={{ marginTop: '10px' }}>
                  <select value={outputGateMode} onChange={(e) => setOutputGateMode(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                    <option value="OR">Output gate: OR</option>
                    <option value="XOR">Output gate: XOR</option>
                    <option value="AND">Output gate: AND</option>
                  </select>
                </div>
              ) : null}
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 8px 0', fontWeight: 900 }}>Fast n-trace grid (10 blocks)</p>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(5,minmax(0,1fr))', gap: '8px' }}>
                {nTraceInput.map((v, idx) => (
                  <input
                    key={idx}
                    type="number"
                    min="0"
                    max="9"
                    value={v}
                    onChange={(e) => {
                      const next = nTraceInput.slice();
                      next[idx] = e.target.value;
                      setNTraceInput(next);
                    }}
                    placeholder={'B' + (idx + 1)}
                    style={{ padding: '10px', borderRadius: '10px', border: '1px solid #E0E0E0' }}
                  />
                ))}
              </div>
              <label style={{ display: 'block', marginTop: '10px', fontSize: '13px' }}>
                <input type="checkbox" checked={planConfirmed} onChange={(e) => setPlanConfirmed(e.target.checked)} /> Plan confirmed for this session
              </label>
              <div style={{ display: 'grid', gap: '6px', marginTop: '8px' }}>
                {Array.from({ length: 10 }, (_, i) => (
                  <div key={i} style={{ fontSize: '13px' }}>
                    <b>Block {i + 1}:</b>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={blockDone[i]} onChange={(e) => {
                      const next = blockDone.slice(); next[i] = e.target.checked; setBlockDone(next);
                    }} /> done</label>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={noResponseBlocks.includes(i + 1)} onChange={() => setNoResponseBlocks((p) => toggleBlockTag(p, i + 1))} /> no response</label>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={fixedNBlocks.includes(i + 1)} onChange={() => setFixedNBlocks((p) => toggleBlockTag(p, i + 1))} /> fixed n</label>
                  </div>
                ))}
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <select value={temptationPressure} onChange={(e) => setTemptationPressure(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Temptation pressure: not logged</option>
                  <option value="0">Temptation pressure: 0</option>
                  <option value="1">Temptation pressure: 1</option>
                  <option value="2">Temptation pressure: 2</option>
                  <option value="3">Temptation pressure: 3</option>
                </select>
              </div>
              {derivedPreview ? (
                <p style={{ margin: '10px 0 0 0', fontSize: '13px', color: '#333333' }}>
                  mean_n {derivedPreview.mean_n} | volatility {derivedPreview.volatility} | end_hold_delta {derivedPreview.end_hold_delta} | recovery_delta {derivedPreview.recovery_delta}
                </p>
              ) : null}
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the game it looked like...</label>
              <input
                type="text"
                value={bridgeObs}
                onChange={(e) => setBridgeObs(e.target.value)}
                placeholder="One concise observation"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '12px' }}
              />

              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the next task I will use it by...</label>
              <input
                type="text"
                value={bridgeMove}
                onChange={(e) => setBridgeMove(e.target.value)}
                placeholder="One concrete transfer move"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0' }}
              />

              <div className="btnRow">
                <button className="btn btnPrimary" onClick={completeSession} disabled={!bridgeReady}>
                  Complete session ({Math.min(PROGRAM_TARGET, progress.totalSessionsCompleted + 1)}/{PROGRAM_TARGET})
                </button>
                <button className="btn btnSecondary" onClick={() => setScreen('home')}>Back</button>
              </div>
            </section>
          </main>
        </div>
      );
    }

    return (
      <div className="screen">
        <div className="topbar">
          <div className="brandleft">
            <div className="icon"><span className="iconText">T</span></div>
            <div>
              <p className="title">Capacity Training Coach</p>
              <p className="subtitle">i3 Mindware session coordinator</p>
            </div>
          </div>
          <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
        </div>

        <main className="content">
          <section className="card">
            <h1 className="h1">Type-1 Program</h1>
            <p className="p">24 sessions total. No anchor wheel. Choose any of the 4 n-back variants each session.</p>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Progress</p>
            <p style={{ marginTop: '8px' }}>{programV11.program_session_index}/{PROGRAM_TARGET} complete | {sessionsRemaining} remaining</p>
            <p style={{ marginTop: '6px', fontSize: '13px', color: '#555555' }}>
              Calendar entries: {programV11.calendar_entry_count} | Consecutive rests: {programV11.consecutive_rest_count}
            </p>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Flow recommendation</p>
            <p style={{ marginTop: '8px' }}>
              Session type: <b>{recommendationV11.recommended_session_type}</b> | Game: <b>{GAME_LABEL[GAME_ID_FROM_ENUM[recommendationV11.recommended_game]] || recommendationV11.recommended_game}</b>
            </p>
            <p style={{ marginTop: '4px', fontSize: '13px', color: '#555555' }}>{recommendationV11.recommendation_reason}</p>
            {recommendationV11.probe_radius ? (
              <p style={{ marginTop: '4px', fontSize: '13px', color: '#555555' }}>
                Probe radius: {recommendationV11.probe_radius} | Target: {recommendationV11.probe_target_game}
              </p>
            ) : null}
            {pendingMission ? (
              <p style={{ marginTop: '8px', fontSize: '13px', color: '#2764B7', fontWeight: 700 }}>
                Pending mission outcome should be logged before next session.
              </p>
            ) : null}
            <div className="btnRow">
              <button className="btn" style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }} onClick={saveRestDay}>
                Take rest day
              </button>
              {pendingMission ? (
                <button
                  className="btn"
                  style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }}
                  onClick={() => {
                    const cueFired = window.prompt('Mission outcome: cue fired? (YES/NO)', 'YES');
                    const successMet = window.prompt('Mission outcome: success met? (YES/PARTLY/NO)', 'PARTLY');
                    const blocker = window.prompt('Main blocker? (state/capacity/context/unsure)', 'unsure');
                    const payload = {
                      cue_fired: (cueFired || 'YES').toUpperCase(),
                      success_met: (successMet || 'PARTLY').toUpperCase(),
                      blocker: (blocker || 'unsure').toLowerCase(),
                      value_tag: null
                    };
                    setMissionsV11((prev) =>
                      prev.map((m) =>
                        m.id === pendingMission.id
                          ? { ...m, outcome: payload, outcome_ts: new Date().toISOString() }
                          : m
                      )
                    );
                  }}
                >
                  Log mission outcome
                </button>
              ) : null}
            </div>
            {programV11.consecutive_rest_count >= 2 ? (
              <div style={{ marginTop: '10px' }}>
                <p style={{ margin: 0, color: '#9a5b00', fontWeight: 700 }}>
                  Reset recommended: 2+ consecutive rest logs.
                </p>
                <label style={{ display: 'block', marginTop: '6px', fontSize: '13px' }}>
                  <input type="checkbox" checked={restConfirm} onChange={(e) => setRestConfirm(e.target.checked)} /> Confirm another rest day
                </label>
                <input
                  type="text"
                  value={restReason}
                  onChange={(e) => setRestReason(e.target.value)}
                  placeholder="Optional reason"
                  style={{ marginTop: '6px' }}
                />
              </div>
            ) : null}
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>State gate</p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#333333' }}>
              Estimate state from quick ratings, then optionally override manually.
            </p>
            {[
              ['load', 'Load'],
              ['drift', 'Drift'],
              ['mismatch', 'Mismatch']
            ].map(([k, label]) => (
              <div key={k} style={{ marginBottom: '10px' }}>
                <label style={{ fontWeight: 700 }}>{label}: {stateRatings[k]}</label>
                <input
                  type="range"
                  min="0"
                  max="10"
                  value={stateRatings[k]}
                  onChange={(e) => setStateRatings((prev) => ({ ...prev, [k]: Number(e.target.value) }))}
                  style={{ width: '100%' }}
                />
              </div>
            ))}
            <div className="btnRow" style={{ marginTop: 8 }}>
              <button className="btn" style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }} onClick={estimateZoneFromRatings}>
                Estimate state
              </button>
            </div>
            {lastStateReason ? (
              <p style={{ margin: '8px 0 0 0', fontSize: '13px', color: '#333333' }}>
                {lastStateReason}
              </p>
            ) : null}
            <div className="btnRow">
              {[
                { id: 'in_band', label: 'In-band (Full)' },
                { id: 'light', label: 'Light' },
                { id: 'reset', label: 'Reset' }
              ].map((z) => (
                <button
                  key={z.id}
                  className="btn"
                  onClick={() => {
                    setZoneMode(z.id);
                    setPlanType(computePlanType(z.id));
                  }}
                  style={{
                    background: zoneMode === z.id ? '#E8F4FF' : '#FFFFFF',
                    border: '1px solid ' + (zoneMode === z.id ? '#2764B7' : '#E0E0E0'),
                    color: '#111111'
                  }}
                >
                  {z.label}
                </button>
              ))}
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Optional breathing reset</p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#333333' }}>
              Simplified from Zone Coach (no HR capture).
            </p>
            <select
              value={breathRoutine}
              onChange={(e) => setBreathRoutine(e.target.value)}
              style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }}
            >
              <option value="upshift">Upshift</option>
              <option value="amplify">Amplify</option>
              <option value="downshift">Downshift</option>
            </select>
            <p style={{ margin: '0 0 4px 0', fontWeight: 700 }}>{BREATH_ROUTINES[breathRoutine].name}</p>
            <p style={{ margin: '0 0 4px 0', fontSize: '13px' }}>{BREATH_ROUTINES[breathRoutine].description}</p>
            <p style={{ margin: 0, fontSize: '13px', color: '#555555' }}>{BREATH_ROUTINES[breathRoutine].cue}</p>
            <div className="btnRow">
              <button
                className="btn"
                style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }}
                onClick={() => {
                  setBreathRemaining(90);
                  setBreathRunning(true);
                }}
              >
                Start 90s routine
              </button>
              {breathRunning ? (
                <button
                  className="btn"
                  style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', color: '#333333' }}
                  onClick={() => {
                    setBreathRunning(false);
                    setBreathRemaining(0);
                  }}
                >
                  Stop
                </button>
              ) : null}
            </div>
            {breathRunning ? (
              <p style={{ margin: '8px 0 0 0', fontWeight: 900 }}>
                {Math.max(0, breathRemaining)}s remaining
              </p>
            ) : null}
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Preset controls</p>
            <div className="btnRow">
              <select value={speedPreset} onChange={(e) => setSpeedPreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                <option value="slow">Speed: Slow</option>
                <option value="normal">Speed: Normal</option>
                <option value="fast">Speed: Fast</option>
              </select>
              <select value={interferencePreset} onChange={(e) => setInterferencePreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                <option value="low">Interference: Low</option>
                <option value="normal">Interference: Normal</option>
                <option value="high">Interference: High</option>
              </select>
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Choose today's i3 Mindware game</p>
            <div style={{ display: 'grid', gap: '10px' }}>
              {GAMES.map((g) => (
                <button
                  key={g.id}
                  className="btn"
                  onClick={() => setSelectedGame(g.id)}
                  style={{
                    width: '100%',
                    textAlign: 'left',
                    background: selectedGame === g.id ? '#E8F4FF' : '#FFFFFF',
                    border: '1px solid ' + (selectedGame === g.id ? '#2764B7' : '#E0E0E0'),
                    color: '#111111'
                  }}
                >
                  <div style={{ fontWeight: 900 }}>{g.label}{g.id === 'classic' ? ' (Suggested start)' : ''}</div>
                  <div style={{ fontSize: '13px', marginTop: '6px', opacity: 0.85 }}>{g.note}</div>
                </button>
              ))}
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Today's plan: {planLabel}</p>
            <p style={{ marginTop: '8px' }}>Open i3 Mindware, run {selectedGameObj.label}, then return for wrap-up.</p>
            <div className="btnRow">
              <button className="btn btnPrimary" onClick={launchExternalGame}>Launch external app flow</button>
              <button className="btn btnSecondary" onClick={() => setScreen('results')}>I already ran it</button>
            </div>
          </section>
        </main>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>
</body>
</html>
