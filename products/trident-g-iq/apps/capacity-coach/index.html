<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Capacity Training Coach</title>
  <link rel="stylesheet" href="../../../../branding/brand.css">
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

<script type="text/babel" data-presets="env,react">
  const { useEffect, useMemo, useState } = React;

  const STORAGE = {
    PROGRESS: 'iqmw.progress.v1',
    PROGRESS_LEGACY: 'trainingProgress',
    CAPACITY_LAST_GAME: 'iqmw.capacity.lastGameSelection',
    CAPACITY_LAST_SESSION: 'iqmw.capacity.lastSession',
    SETTINGS_V11: 'iqmw.capacity.settings.v1',
    PROGRAM_V11: 'iqmw.capacity.program.v1',
    SESSIONS_V11: 'iqmw.capacity.sessions.v1',
    MISSIONS_V11: 'iqmw.capacity.missions.v1'
  };

  const PROGRAM_TARGET = 24;
  const SESSION_TYPES = ['TUNE', 'EXPLORE', 'TIGHTEN', 'PROBE', 'RECHECK', 'RESET'];
  const GAME_ENUM = {
    classic: 'CLASSIC',
    emotional: 'EMOTIONAL',
    non_categorical: 'NONCAT',
    logic_gated: 'OUTPUT_GATED'
  };
  const GAME_ID_FROM_ENUM = {
    CLASSIC: 'classic',
    EMOTIONAL: 'emotional',
    NONCAT: 'non_categorical',
    OUTPUT_GATED: 'logic_gated'
  };
  const DEFAULT_SETTINGS_V11 = {
    schemaVersion: 'capacity_settings_v1_1',
    thresholds: {
      plateau_epsilon: 0.25,
      churn_volatility: 5,
      probe_swap_cost_min: -1,
      probe_recovery_delta_min: -0.5,
      probe_end_hold_min: -1,
      recheck_mean_tolerance: 1.0
    },
    defaults: {
      pulse_block_index: 4,
      recovery_blocks: [5, 6],
      end_hold_block: 10
    }
  };
  // Planned opportunities only: these slots can be deferred when out-of-band or data-quality is compromised.
  const makeScaffold = () => Array.from({ length: PROGRAM_TARGET }, (_, i) => ({
    program_day: i + 1,
    probe_slot: (i + 1) % 4 === 0,
    recheck_slot: i + 1 === 12 || i + 1 === 24
  }));
  const DEFAULT_PROGRAM_V11 = {
    schemaVersion: 'capacity_program_v1_1',
    // Legacy-only counter kept for back-compat with earlier app state.
    // Do not use as source of truth for new flow logic.
    program_day_completed: 0,
    // Authoritative training-session counter (increments on TRAINING entries only).
    program_session_index: 0,
    calendar_entry_count: 0,
    consecutive_rest_count: 0,
    anchor_lane: 'CLASSIC',
    last_probe_radius_passed: null,
    scaffold: makeScaffold()
  };

  const GAMES = [
    { id: 'classic', label: 'Classic n-back', note: 'Good default starting point.' },
    { id: 'emotional', label: 'Emotional n-back', note: 'Add salience control under load.' },
    { id: 'non_categorical', label: 'Non-categorical n-back', note: 'Train broad runtime control.' },
    { id: 'logic_gated', label: 'Logic-gated n-back', note: 'Rule discipline and clean updating.' }
  ];
  const GAME_LABEL = GAMES.reduce((acc, g) => ({ ...acc, [g.id]: g.label }), {});
  const VALUE_TAGS = ['risk', 'opportunity', 'urgency', 'social_cost'];
  const SESSION_LABELS = {
    TUNE: 'Build',
    EXPLORE: 'Explore',
    TIGHTEN: 'Stabilise',
    PROBE: 'Switch test',
    RECHECK: 'Later check',
    RESET: 'Reset day'
  };
  const SWITCH_SIZE_LABELS = {
    NEAR: 'Small switch',
    MID: 'Medium switch',
    FAR: 'Big switch'
  };

  const BREATH_ROUTINES = {
    upshift: {
      name: 'Upshift',
      description: 'Inhale-led breathing to raise engagement.',
      cue: 'Inhale 3s, exhale 2s.'
    },
    amplify: {
      name: 'Amplify',
      description: 'Slow-paced breathing to stabilise.',
      cue: 'Inhale 4s, exhale 6s.'
    },
    downshift: {
      name: 'Downshift',
      description: 'Cyclic sighing to reduce overload.',
      cue: 'Two short inhales, one long sigh out.'
    }
  };

  const safeParse = (raw, fallback) => {
    try { return JSON.parse(raw); } catch { return fallback; }
  };
  const mean = (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
  const uid = () => 'id_' + Math.random().toString(36).slice(2, 10) + '_' + Date.now().toString(36);
  const saveJson = (key, value) => {
    try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
  };
  const asObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : {});
  const loadProgramV11 = () => {
    const raw = asObject(safeParse(localStorage.getItem(STORAGE.PROGRAM_V11), {}));
    return {
      ...DEFAULT_PROGRAM_V11,
      ...raw,
      program_session_index: Number(raw.program_session_index ?? raw.program_day_completed ?? 0),
      scaffold: Array.isArray(raw.scaffold) && raw.scaffold.length === PROGRAM_TARGET ? raw.scaffold : makeScaffold()
    };
  };
  const loadSessionsV11 = () => {
    const rows = safeParse(localStorage.getItem(STORAGE.SESSIONS_V11), []);
    return Array.isArray(rows) ? rows : [];
  };
  const loadMissionsV11 = () => {
    const rows = safeParse(localStorage.getItem(STORAGE.MISSIONS_V11), []);
    return Array.isArray(rows) ? rows : [];
  };
  const loadSettingsV11 = () => {
    const raw = asObject(safeParse(localStorage.getItem(STORAGE.SETTINGS_V11), {}));
    return {
      ...DEFAULT_SETTINGS_V11,
      ...raw,
      thresholds: { ...DEFAULT_SETTINGS_V11.thresholds, ...asObject(raw.thresholds) },
      defaults: { ...DEFAULT_SETTINGS_V11.defaults, ...asObject(raw.defaults) }
    };
  };
  const getTrainingSessions = (rows) => rows.filter((x) => x.entry_type === 'TRAINING');
  const isEvidenceEligible = (s) => (
    Boolean(s && s.derived) &&
    s.data_quality === 'OK' &&
    (s.log?.plan_confirmed ?? true)
  );
  const nextProbeRadius = (lastPassed) => {
    if (!lastPassed) return 'NEAR';
    if (lastPassed === 'NEAR') return 'MID';
    return 'FAR';
  };
  const probeTargetFor = (anchor, radius) => {
    const map = {
      CLASSIC: { NEAR: 'EMOTIONAL', MID: 'NONCAT', FAR: 'OUTPUT_GATED' },
      EMOTIONAL: { NEAR: 'CLASSIC', MID: 'OUTPUT_GATED', FAR: 'NONCAT' },
      NONCAT: { NEAR: 'CLASSIC', MID: 'OUTPUT_GATED', FAR: 'EMOTIONAL' },
      OUTPUT_GATED: { NEAR: 'CLASSIC', MID: 'NONCAT', FAR: 'EMOTIONAL' }
    };
    return map[anchor]?.[radius] || 'CLASSIC';
  };
  const computeDerivedFromNTrace = (nTrace, pulseCfg = { block_index: 4, recovery_blocks: [5, 6] }) => {
    const n = nTrace.map((x) => Number(x));
    const volatility = n.slice(1).reduce((acc, v, i) => acc + (v !== n[i] ? 1 : 0), 0);
    const dropDeltas = n.slice(1).map((v, i) => n[i] - v).filter((d) => d > 0);
    const baselineMean = mean([n[0], n[1]]);
    const recBlocks = (pulseCfg?.recovery_blocks || [5, 6]).map((ix) => n[Math.max(0, Math.min(9, ix - 1))]);
    const recoveryMean = mean(recBlocks);
    return {
      mean_n: Number(mean(n).toFixed(2)),
      volatility,
      drop_count: dropDeltas.length,
      max_drop: dropDeltas.length ? Math.max(...dropDeltas) : 0,
      end_hold_delta: Number((n[9] - baselineMean).toFixed(2)),
      baseline_mean: Number(baselineMean.toFixed(2)),
      recovery_delta: Number((recoveryMean - baselineMean).toFixed(2))
    };
  };
  const trendFlags = (sameLaneSessions, epsilon = 0.25) => {
    const eligible = sameLaneSessions.filter((s) => isEvidenceEligible(s));
    const last3 = eligible.slice(-3);
    if (last3.length < 3) return { plateau: false, churn: false, breakthrough: false };
    const [a, b, c] = last3.map((s) => s.derived || {});
    const plateau = (Number(c.mean_n || 0) - Number(a.mean_n || 0)) < epsilon && mean([a.volatility || 0, b.volatility || 0, c.volatility || 0]) <= 2;
    const churn = (c.volatility || 0) > 5 || (c.end_hold_delta || 0) < -1;
    const breakthrough = (Number(c.mean_n || 0) - Number(b.mean_n || 0)) >= 1 || (((b.volatility || 0) > 0) && ((c.volatility || 99) <= Math.max(1, (b.volatility || 1) / 2)) && ((c.end_hold_delta || -99) > (b.end_hold_delta || -99)));
    return { plateau, churn, breakthrough };
  };

  const loadProgress = () => {
    const fromNew = safeParse(localStorage.getItem(STORAGE.PROGRESS), null);
    const fromLegacy = safeParse(localStorage.getItem(STORAGE.PROGRESS_LEGACY), null);
    const raw = fromNew || fromLegacy || {};

    const completed = Number(raw.totalSessionsCompleted)
      || Number(raw.anchorSessionsCompleted) + Number(raw.swapSessionsCompleted)
      || 0;

    return {
      schemaVersion: 'progress_v1',
      totalSessionsCompleted: completed,
      totalSessionsTarget: PROGRAM_TARGET,
      lastSessionDate: raw.lastSessionDate || null,
      programStartDate: raw.programStartDate || new Date().toISOString(),
      programCompleted: completed >= PROGRAM_TARGET,
      programCompletionDate: raw.programCompletionDate || null
    };
  };

  const saveProgress = (next) => {
    const json = JSON.stringify(next);
    localStorage.setItem(STORAGE.PROGRESS, json);
    localStorage.setItem(STORAGE.PROGRESS_LEGACY, json);
  };

  function App() {
    const [screen, setScreen] = useState('home');
    const [progress, setProgress] = useState(() => loadProgress());
    const [settingsV11] = useState(() => loadSettingsV11());
    const [programV11, setProgramV11] = useState(() => loadProgramV11());
    const [sessionsV11, setSessionsV11] = useState(() => loadSessionsV11());
    const [missionsV11, setMissionsV11] = useState(() => loadMissionsV11());
    const [zoneMode, setZoneMode] = useState('in_band');
    const [planType, setPlanType] = useState('type1_build');
    const [stateRatings, setStateRatings] = useState({ load: 4, drift: 4, mismatch: 4 });
    const [lastStateReason, setLastStateReason] = useState('');
    const [selectedGame, setSelectedGame] = useState('classic');
    const [speedPreset, setSpeedPreset] = useState('calm');
    const [interferencePreset, setInterferencePreset] = useState('low');
    const [bridgeObs, setBridgeObs] = useState('');
    const [bridgeMove, setBridgeMove] = useState('');
    const [breathRoutine, setBreathRoutine] = useState('amplify');
    const [breathRunning, setBreathRunning] = useState(false);
    const [breathRemaining, setBreathRemaining] = useState(0);
    const [restConfirm, setRestConfirm] = useState(false);
    const [restReason, setRestReason] = useState('');
    const [sessionType, setSessionType] = useState('TUNE');
    const [baselineMode, setBaselineMode] = useState('ADAPTIVE');
    const [fixedN, setFixedN] = useState(2);
    const [pulseType, setPulseType] = useState('');
    const [pulseBlockIndex, setPulseBlockIndex] = useState(4);
    const [recoveryBlocksCsv, setRecoveryBlocksCsv] = useState('5,6');
    const [endHoldBlock, setEndHoldBlock] = useState(10);
    const [outputGateMode, setOutputGateMode] = useState('OR');
    const [nTraceInput, setNTraceInput] = useState(Array.from({ length: 10 }, () => ''));
    const [blockDone, setBlockDone] = useState(Array.from({ length: 10 }, () => false));
    const [noResponseBlocks, setNoResponseBlocks] = useState([]);
    const [fixedNBlocks, setFixedNBlocks] = useState([]);
    const [planConfirmed, setPlanConfirmed] = useState(false);
    const [temptationPressure, setTemptationPressure] = useState('');
    const [missionCue, setMissionCue] = useState('');
    const [missionSignal, setMissionSignal] = useState('');
    const [missionValueTag, setMissionValueTag] = useState('');
    const [missionOutcome, setMissionOutcome] = useState({
      cue_fired: 'YES',
      success_met: 'PARTLY',
      blocker: '',
      value_tag: ''
    });

    const selectedGameObj = useMemo(
      () => GAMES.find((g) => g.id === selectedGame) || GAMES[0],
      [selectedGame]
    );

    const trainingSessionsV11 = useMemo(() => getTrainingSessions(sessionsV11), [sessionsV11]);
    const sessionsRemaining = Math.max(0, PROGRAM_TARGET - (programV11.program_session_index || 0));
    const pendingMission = useMemo(() => missionsV11.find((m) => !m.outcome) || null, [missionsV11]);
    const evidenceSessions = useMemo(() => trainingSessionsV11.filter((s) => isEvidenceEligible(s)), [trainingSessionsV11]);
    const proofCounters = useMemo(() => {
      const probes = evidenceSessions.filter((s) => s.session_type === 'PROBE' && s.probe?.pass === true);
      const rechecks = evidenceSessions.filter((s) => s.session_type === 'RECHECK' && s.recheck?.pass === true).length;
      const stabilityStreak = (() => {
        let streak = 0;
        for (let i = evidenceSessions.length - 1; i >= 0; i -= 1) {
          const d = evidenceSessions[i].derived;
          if (d && d.drop_count <= 2 && d.end_hold_delta >= -1) streak += 1;
          else break;
        }
        return streak;
      })();
      const missionSuccesses = missionsV11.filter((m) => m.outcome && m.outcome.cue_fired === 'YES' && m.outcome.success_met === 'YES').length;
      return {
        near: probes.some((s) => s.probe?.probe_radius === 'NEAR'),
        mid: probes.some((s) => s.probe?.probe_radius === 'MID'),
        far: probes.some((s) => s.probe?.probe_radius === 'FAR'),
        delay_holds: rechecks,
        mission_successes: missionSuccesses,
        stability_streak: stabilityStreak
      };
    }, [evidenceSessions, missionsV11]);
    const notCountedNote = useMemo(() => {
      const last = [...trainingSessionsV11].reverse().find(Boolean);
      if (!last) return '';
      if (last.data_quality === 'UNCONFIRMED_PLAN') return 'Not counted: you did not follow today\'s plan settings.';
      if (last.data_quality === 'COMPROMISED') return 'Not counted: some blocks had no responses.';
      if (last.session_type === 'RECHECK' && !last.recheck?.of_session_id) return 'Not counted: this check was not matched to a previous session.';
      return '';
    }, [trainingSessionsV11]);
    const recommendationV11 = useMemo(() => {
      const zoneRecommendation = zoneMode === 'reset' ? 'RESET' : (zoneMode === 'light' ? 'LIGHT' : 'FULL');
      const lane = programV11.anchor_lane || 'CLASSIC';
      const sameLane = trainingSessionsV11.filter((s) => s.game === lane);
      const tf = trendFlags(sameLane, settingsV11.thresholds.plateau_epsilon);
      const row = programV11.scaffold[Math.max(0, programV11.program_session_index)] || { probe_slot: false, recheck_slot: false };
      const latestTraining = [...trainingSessionsV11].reverse().find(Boolean);
      const dataQualityAllowsProbe = !latestTraining || latestTraining.data_quality === 'OK';
      let session_type = 'TUNE';
      let reason = 'Stable training day.';
      let game = lane;
      let probe_radius = null;
      let probe_target_game = null;

      if (zoneRecommendation === 'RESET') {
        session_type = 'RESET';
        reason = 'Your state is overloaded today, so easier settings are recommended.';
      } else if (zoneRecommendation === 'LIGHT') {
        session_type = 'TIGHTEN';
        reason = 'A lighter stabilising session is recommended today.';
      }
      if (tf.churn && zoneRecommendation !== 'RESET') {
        session_type = 'TIGHTEN';
        reason = 'Recent sessions were up and down, so stabilise first.';
      }
      if ((tf.breakthrough || row.probe_slot) && zoneRecommendation === 'FULL' && dataQualityAllowsProbe) {
        session_type = 'PROBE';
        probe_radius = nextProbeRadius(programV11.last_probe_radius_passed);
        probe_target_game = probeTargetFor(lane, probe_radius);
        game = probe_target_game;
        reason = tf.breakthrough ? 'Recent progress suggests trying a small switch test.' : 'Today is a planned switch-test day.';
      }
      let recheck_target_session_id = null;
      if (row.recheck_slot && zoneRecommendation === 'FULL' && dataQualityAllowsProbe) {
        const lastCleanTune = [...trainingSessionsV11].reverse().find((s) => s.session_type === 'TUNE' && isEvidenceEligible(s) && s.game === lane);
        if (lastCleanTune) {
          session_type = 'RECHECK';
          game = lastCleanTune.game;
          recheck_target_session_id = lastCleanTune.id;
          reason = 'Today is a planned later-check day.';
        }
      }
      if (tf.plateau && zoneRecommendation === 'FULL' && stateRatings.drift >= 6) {
        session_type = 'EXPLORE';
        game = lane === 'CLASSIC' ? 'EMOTIONAL' : 'CLASSIC';
        reason = 'You look flat or stuck, so a controlled explore day is suggested.';
      }
      return {
        recommended_session_type: session_type,
        recommendation_reason: reason,
        recommended_game: game,
        probe_radius,
        probe_target_game,
        recheck_target_session_id
      };
    }, [zoneMode, programV11, trainingSessionsV11, settingsV11, stateRatings]);

    const computePlanType = (zone) => {
      if (zone !== 'in_band') return 'type1_light';
      return 'type1_build';
    };

    const estimateZoneFromRatings = () => {
      const vals = [stateRatings.load, stateRatings.drift, stateRatings.mismatch];
      const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
      const peak = Math.max(...vals);
      let nextZone = 'in_band';
      let reason = 'State looks manageable for normal training.';
      if (peak >= 8 || avg >= 7) {
        nextZone = 'reset';
        reason = 'You look overloaded right now, so use easier settings today.';
      } else if (avg >= 5) {
        nextZone = 'light';
        reason = 'You look a bit stretched, so keep this session lighter.';
      }
      setZoneMode(nextZone);
      setPlanType(computePlanType(nextZone));
      setLastStateReason(reason);
      if (nextZone === 'reset') setBreathRoutine('downshift');
      else if (nextZone === 'light') setBreathRoutine('amplify');
      else setBreathRoutine('upshift');
    };

    useEffect(() => {
      if (!breathRunning || breathRemaining <= 0) return;
      const id = setInterval(() => setBreathRemaining((s) => s - 1), 1000);
      return () => clearInterval(id);
    }, [breathRunning, breathRemaining]);

    useEffect(() => {
      if (breathRunning && breathRemaining <= 0) setBreathRunning(false);
    }, [breathRunning, breathRemaining]);

    useEffect(() => {
      const mapped = GAME_ID_FROM_ENUM[recommendationV11.recommended_game];
      if (mapped) setSelectedGame(mapped);
    }, [recommendationV11.recommended_game]);

    useEffect(() => {
      setSessionType(recommendationV11.recommended_session_type);
    }, [recommendationV11.recommended_session_type]);

    useEffect(() => {
      saveJson(STORAGE.SETTINGS_V11, settingsV11);
    }, [settingsV11]);

    useEffect(() => {
      saveJson(STORAGE.PROGRAM_V11, programV11);
      // Legacy mirror only: keep old progress keys readable by older surfaces.
      const legacy = {
        ...progress,
        totalSessionsCompleted: programV11.program_session_index,
        totalSessionsTarget: PROGRAM_TARGET,
        programCompleted: programV11.program_session_index >= PROGRAM_TARGET
      };
      saveProgress(legacy);
      setProgress(legacy);
    }, [programV11]);

    useEffect(() => {
      saveJson(STORAGE.SESSIONS_V11, sessionsV11);
    }, [sessionsV11]);

    useEffect(() => {
      saveJson(STORAGE.MISSIONS_V11, missionsV11);
    }, [missionsV11]);

    const planLabel = (SESSION_LABELS[recommendationV11.recommended_session_type] || 'Build') + ' session';

    const parseRecoveryBlocks = () => {
      const parsed = recoveryBlocksCsv
        .split(',')
        .map((x) => Number(x.trim()))
        .filter((x) => Number.isFinite(x) && x >= 1 && x <= 10);
      return parsed.length ? parsed : [5, 6];
    };

    const getNTraceOrNull = () => {
      const parsed = nTraceInput.map((x) => Number(x));
      if (parsed.some((x) => !Number.isFinite(x) || x < 0)) return null;
      return parsed;
    };

    const toggleBlockTag = (current, blockIndex) => (
      current.includes(blockIndex)
        ? current.filter((x) => x !== blockIndex)
        : [...current, blockIndex].sort((a, b) => a - b)
    );

    const launchExternalGame = () => {
      const handoff = {
        localDate: new Date().toISOString().slice(0, 10),
        timestamp: Date.now(),
        gameId: selectedGame,
        gameLabel: selectedGameObj.label,
        planType: recommendationV11.recommended_session_type,
        recommended_session_type: recommendationV11.recommended_session_type,
        zoneMode,
        settings: {
          speedPreset,
          interferencePreset
        },
        breathing: {
          routineId: breathRoutine,
          routineName: BREATH_ROUTINES[breathRoutine].name
        }
      };
      localStorage.setItem(STORAGE.CAPACITY_LAST_GAME, JSON.stringify(handoff));
      alert('Launch i3 Mindware (Adobe AIR), choose "' + selectedGameObj.label + '", run your block(s), then return here.');
      setScreen('results');
    };

    const saveRestDay = () => {
      if ((programV11.consecutive_rest_count || 0) >= 2 && !restConfirm) {
        alert('Reset recommended after 2 consecutive rest logs. Confirm rest again to proceed.');
        return;
      }
      const restEntry = {
        id: uid(),
        ts: new Date().toISOString(),
        entry_type: 'REST',
        is_training: false,
        program_day: programV11.program_session_index,
        reason: restReason || null
      };
      setSessionsV11((prev) => [...prev, restEntry]);
      setProgramV11((prev) => ({
        ...prev,
        calendar_entry_count: (prev.calendar_entry_count || 0) + 1,
        consecutive_rest_count: (prev.consecutive_rest_count || 0) + 1
      }));
      setRestConfirm(false);
      setRestReason('');
    };

    const saveMissionOutcome = () => {
      if (!pendingMission) {
        setScreen('home');
        return;
      }
      const payload = {
        cue_fired: missionOutcome.cue_fired,
        success_met: missionOutcome.success_met,
        blocker: missionOutcome.blocker || 'unsure',
        value_tag: missionOutcome.value_tag || null
      };
      setMissionsV11((prev) =>
        prev.map((m) =>
          m.id === pendingMission.id
            ? { ...m, outcome: payload, outcome_ts: new Date().toISOString() }
            : m
        )
      );
      setMissionOutcome({ cue_fired: 'YES', success_met: 'PARTLY', blocker: '', value_tag: '' });
      setScreen('home');
    };

    const completeSession = () => {
      const nTrace = getNTraceOrNull();
      if (!nTrace) {
        alert('Enter all 10 block levels first.');
        return;
      }
      if (!bridgeObs.trim() || !bridgeMove.trim()) {
        alert('Bridge fields are required.');
        return;
      }
      if (sessionType === 'PROBE' && !pulseType) {
        alert('Switch-test sessions need one challenge pulse block.');
        return;
      }

      const nextCompleted = Math.min(PROGRAM_TARGET, (progress.totalSessionsCompleted || 0) + 1);
      const nowIso = new Date().toISOString();
      const next = {
        ...progress,
        totalSessionsCompleted: nextCompleted,
        totalSessionsTarget: PROGRAM_TARGET,
        lastSessionDate: nowIso,
        programCompleted: nextCompleted >= PROGRAM_TARGET,
        programCompletionDate: nextCompleted >= PROGRAM_TARGET ? nowIso : progress.programCompletionDate
      };
      saveProgress(next);
      setProgress(next);

      const recoveryBlocks = parseRecoveryBlocks();
      const derived = computeDerivedFromNTrace(nTrace, { block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks });
      const dataQuality = noResponseBlocks.length ? 'COMPROMISED' : (planConfirmed ? 'OK' : 'UNCONFIRMED_PLAN');
      const anchorLane = programV11.anchor_lane || 'CLASSIC';
      const probeTargetSession = [...trainingSessionsV11].reverse().find((s) => s.game === anchorLane && isEvidenceEligible(s));
      const swapCost = probeTargetSession ? Number((derived.baseline_mean - probeTargetSession.derived.baseline_mean).toFixed(2)) : null;
      const probePass = sessionType === 'PROBE' && dataQuality === 'OK' && swapCost !== null
        ? swapCost >= settingsV11.thresholds.probe_swap_cost_min
          && derived.recovery_delta >= settingsV11.thresholds.probe_recovery_delta_min
          && derived.end_hold_delta >= settingsV11.thresholds.probe_end_hold_min
        : null;

      const recommendedRecheckTarget = recommendationV11.recheck_target_session_id
        ? trainingSessionsV11.find((s) => s.id === recommendationV11.recheck_target_session_id)
        : null;
      const sameGamePlanTarget = [...trainingSessionsV11].reverse().find((s) =>
        isEvidenceEligible(s)
        && s.game === (GAME_ENUM[selectedGame] || 'CLASSIC')
        && s.plan?.baseline?.mode === baselineMode
        && s.plan?.baseline?.speed === speedPreset.toUpperCase()
        && s.plan?.baseline?.interference === interferencePreset.toUpperCase()
      );
      const recheckTarget = recommendedRecheckTarget || sameGamePlanTarget || null;
      const recheckPass = sessionType === 'RECHECK' && recheckTarget && dataQuality === 'OK'
        ? derived.mean_n >= (recheckTarget.derived.mean_n - settingsV11.thresholds.recheck_mean_tolerance)
          && derived.volatility <= ((recheckTarget.derived.volatility ?? 0) + 2)
          && derived.end_hold_delta >= (recheckTarget.derived.end_hold_delta - 1)
        : null;

      const handoff = {
        localDate: nowIso.slice(0, 10),
        timestamp: Date.now(),
        planType: sessionType,
        recommended_session_type: recommendationV11.recommended_session_type,
        session_type: sessionType,
        gameId: selectedGame,
        gameLabel: selectedGameObj.label,
        game_enum: GAME_ENUM[selectedGame] || 'CLASSIC',
        zoneMode,
        settings: {
          speedPreset,
          interferencePreset,
          baselineMode,
          fixedN: baselineMode === 'FIXED' ? Number(fixedN) : null
        },
        pulse: pulseType ? { type: pulseType, block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks } : null,
        bridge: {
          observation: bridgeObs.trim(),
          move: bridgeMove.trim()
        }
      };
      localStorage.setItem(STORAGE.CAPACITY_LAST_SESSION, JSON.stringify(handoff));
      localStorage.setItem(STORAGE.CAPACITY_LAST_GAME, JSON.stringify(handoff));

      const trainingEntry = {
        id: uid(),
        ts: nowIso,
        entry_type: 'TRAINING',
        is_training: true,
        program_day: (programV11.program_session_index || 0) + 1,
        recommended_session_type: recommendationV11.recommended_session_type,
        session_type: sessionType,
        recommendation_reason: recommendationV11.recommendation_reason,
        game: GAME_ENUM[selectedGame] || 'CLASSIC',
        output_gate_mode: selectedGame === 'logic_gated' ? outputGateMode : null,
        zone: {
          load: stateRatings.load,
          drift: stateRatings.drift,
          mismatch: stateRatings.mismatch,
          recommendation: zoneMode === 'reset' ? 'RESET' : (zoneMode === 'light' ? 'LIGHT' : 'FULL')
        },
        plan: {
          baseline: {
            speed: speedPreset.toUpperCase(),
            interference: interferencePreset.toUpperCase(),
            mode: baselineMode,
            fixed_n: baselineMode === 'FIXED' ? Number(fixedN) : null
          },
          pulse: pulseType ? { type: pulseType, block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks } : null,
          end_hold_block: Number(endHoldBlock)
        },
        log: {
          n_trace: nTrace,
          no_response_blocks: noResponseBlocks.slice(),
          fixed_n_blocks: fixedNBlocks.slice(),
          block_done: blockDone.slice(),
          plan_confirmed: Boolean(planConfirmed),
          temptation_pressure: temptationPressure === '' ? null : Number(temptationPressure)
        },
        derived,
        data_quality: dataQuality,
        probe: {
          probe_radius: recommendationV11.probe_radius,
          probe_target_game: recommendationV11.probe_target_game,
          target_session_id: probeTargetSession ? probeTargetSession.id : null,
          swap_cost: swapCost,
          pass: probePass
        },
        recheck: {
          of_session_id: recheckTarget ? recheckTarget.id : null,
          pass: recheckPass
        },
        bridge: {
          what_changed: bridgeObs.trim(),
          how_ill_use_it: bridgeMove.trim()
        }
      };
      setSessionsV11((prev) => [...prev, trainingEntry]);
      setProgramV11((prev) => ({
        ...prev,
        program_day_completed: Math.min(PROGRAM_TARGET, (prev.program_day_completed || 0) + 1),
        program_session_index: Math.min(PROGRAM_TARGET, (prev.program_session_index || 0) + 1),
        calendar_entry_count: (prev.calendar_entry_count || 0) + 1,
        consecutive_rest_count: 0,
        last_probe_radius_passed: probePass === true ? recommendationV11.probe_radius : prev.last_probe_radius_passed
      }));

      if (missionCue.trim() && missionSignal.trim()) {
        const missionObj = {
          id: uid(),
          created_ts: nowIso,
          created_from_session_id: trainingEntry.id,
          cue: missionCue.trim(),
          success_signal: missionSignal.trim(),
          value_tag: missionValueTag || null,
          outcome: null
        };
        setMissionsV11((prev) => [...prev, missionObj]);
      }

      setScreen('home');
      setBridgeObs('');
      setBridgeMove('');
      setMissionCue('');
      setMissionSignal('');
      setMissionValueTag('');
      setNTraceInput(Array.from({ length: 10 }, () => ''));
      setBlockDone(Array.from({ length: 10 }, () => false));
      setNoResponseBlocks([]);
      setFixedNBlocks([]);
      setPlanConfirmed(false);
      setTemptationPressure('');
    };

    if (screen === 'results') {
      const bridgeReady = bridgeObs.trim() && bridgeMove.trim();
      const parsed = getNTraceOrNull();
      const derivedPreview = parsed
        ? computeDerivedFromNTrace(parsed, { block_index: Number(pulseBlockIndex), recovery_blocks: parseRecoveryBlocks() })
        : null;
      const badgePreview = sessionType === 'PROBE'
        ? ((derivedPreview && derivedPreview.recovery_delta >= -0.5 && derivedPreview.end_hold_delta >= -1) ? 'Switch test likely passed' : 'Switch test needs another try')
        : (sessionType === 'TIGHTEN'
          ? ((derivedPreview && derivedPreview.volatility <= 4) ? 'More steady today' : 'Still getting steadier')
          : (sessionType === 'RECHECK'
            ? 'Checking if gains still hold'
            : (sessionType === 'RESET' ? 'Protected learning day' : 'Stable and recovered')));
      const steadyLabel = derivedPreview
        ? (derivedPreview.volatility <= 4 ? 'Steady' : 'Up and down today')
        : '';
      const recoveryLabel = derivedPreview
        ? (derivedPreview.recovery_delta >= -0.5 ? 'Recovered quickly' : 'Recovery was slow')
        : '';
      const finishLabel = derivedPreview
        ? (derivedPreview.end_hold_delta >= -1 ? 'Finished strong' : 'Faded by the end')
        : '';
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><span className="iconText">T</span></div>
              <div>
                <p className="title">Capacity Training Coach</p>
                <p className="subtitle">Session review</p>
              </div>
            </div>
            <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
          </div>

          <main className="content">
            <section className="card">
              <h1 className="h1">Post-Session Review</h1>
              <p className="p">Played: {selectedGameObj.label} | Session style: {SESSION_LABELS[sessionType] || 'Build'}</p>
              <p className="p" style={{ marginTop: '8px' }}>Outcome badge: {badgePreview}</p>
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 10px 0', fontWeight: 900 }}>Today's settings (you can change these)</p>
              <div className="btnRow" style={{ marginTop: 0 }}>
                <select value={sessionType} onChange={(e) => setSessionType(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  {SESSION_TYPES.map((t) => <option key={t} value={t}>{SESSION_LABELS[t] || t}</option>)}
                </select>
                <select value={baselineMode} onChange={(e) => setBaselineMode(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="ADAPTIVE">Auto level change</option>
                  <option value="FIXED">Fixed level</option>
                </select>
                {baselineMode === 'FIXED' ? (
                  <input type="number" min="1" max="9" value={fixedN} onChange={(e) => setFixedN(Number(e.target.value || 1))} style={{ width: '88px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                ) : null}
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <select value={speedPreset} onChange={(e) => setSpeedPreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="slow">Speed: Slow</option>
                  <option value="normal">Speed: Normal</option>
                  <option value="fast">Speed: Fast</option>
                </select>
                <select value={interferencePreset} onChange={(e) => setInterferencePreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="low">Distraction level: Low</option>
                  <option value="normal">Distraction level: Normal</option>
                  <option value="high">Distraction level: High</option>
                </select>
                <select value={pulseType} onChange={(e) => setPulseType(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Challenge block: None</option>
                  <option value="SPEED">Challenge block: Faster speed</option>
                  <option value="INTERFERENCE">Challenge block: More distraction</option>
                </select>
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <input type="number" min="1" max="10" value={pulseBlockIndex} onChange={(e) => setPulseBlockIndex(Number(e.target.value || 4))} style={{ width: '90px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                <input type="text" value={recoveryBlocksCsv} onChange={(e) => setRecoveryBlocksCsv(e.target.value)} placeholder="Recovery blocks e.g. 5,6" style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                <input type="number" min="1" max="10" value={endHoldBlock} onChange={(e) => setEndHoldBlock(Number(e.target.value || 10))} style={{ width: '90px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
              </div>
              {selectedGame === 'logic_gated' ? (
                <div className="btnRow" style={{ marginTop: '10px' }}>
                  <select value={outputGateMode} onChange={(e) => setOutputGateMode(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                    <option value="OR">Output gate: OR</option>
                    <option value="XOR">Output gate: XOR</option>
                    <option value="AND">Output gate: AND</option>
                  </select>
                </div>
              ) : null}
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 8px 0', fontWeight: 900 }}>10-block level log</p>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(5,minmax(0,1fr))', gap: '8px' }}>
                {nTraceInput.map((v, idx) => (
                  <input
                    key={idx}
                    type="number"
                    min="0"
                    max="9"
                    value={v}
                    onChange={(e) => {
                      const next = nTraceInput.slice();
                      next[idx] = e.target.value;
                      setNTraceInput(next);
                    }}
                    placeholder={'B' + (idx + 1)}
                    style={{ padding: '10px', borderRadius: '10px', border: '1px solid #E0E0E0' }}
                  />
                ))}
              </div>
              <label style={{ display: 'block', marginTop: '10px', fontSize: '13px' }}>
                <input type="checkbox" checked={planConfirmed} onChange={(e) => setPlanConfirmed(e.target.checked)} /> Plan confirmed for this session
              </label>
              <div style={{ display: 'grid', gap: '6px', marginTop: '8px' }}>
                {Array.from({ length: 10 }, (_, i) => (
                  <div key={i} style={{ fontSize: '13px' }}>
                    <b>Block {i + 1}:</b>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={blockDone[i]} onChange={(e) => {
                      const next = blockDone.slice(); next[i] = e.target.checked; setBlockDone(next);
                    }} /> done</label>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={noResponseBlocks.includes(i + 1)} onChange={() => setNoResponseBlocks((p) => toggleBlockTag(p, i + 1))} /> no response</label>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={fixedNBlocks.includes(i + 1)} onChange={() => setFixedNBlocks((p) => toggleBlockTag(p, i + 1))} /> fixed n</label>
                  </div>
                ))}
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <select value={temptationPressure} onChange={(e) => setTemptationPressure(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Temptation pressure: not logged</option>
                  <option value="0">Temptation pressure: 0</option>
                  <option value="1">Temptation pressure: 1</option>
                  <option value="2">Temptation pressure: 2</option>
                  <option value="3">Temptation pressure: 3</option>
                </select>
              </div>
              {derivedPreview ? (
                <div style={{ marginTop: '10px', fontSize: '13px', color: '#333333' }}>
                  <p style={{ margin: 0 }}>{steadyLabel} | {recoveryLabel} | {finishLabel}</p>
                  <details style={{ marginTop: '6px' }}>
                    <summary>Details</summary>
                    <p style={{ margin: '6px 0 0 0' }}>
                      Average level {derivedPreview.mean_n} | Level changes {derivedPreview.volatility} | End strength {derivedPreview.end_hold_delta} | Recovery shift {derivedPreview.recovery_delta}
                    </p>
                  </details>
                </div>
              ) : null}
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the game it looked like...</label>
              <input
                type="text"
                value={bridgeObs}
                onChange={(e) => setBridgeObs(e.target.value)}
                placeholder="One concise observation"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '12px' }}
              />

              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the next task I will use it by...</label>
              <input
                type="text"
                value={bridgeMove}
                onChange={(e) => setBridgeMove(e.target.value)}
                placeholder="One concrete transfer move"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0' }}
              />

              <p style={{ margin: '14px 0 8px 0', fontWeight: 900 }}>Set a tiny cue-fired mission (recommended, optional)</p>
              <p style={{ margin: '0 0 8px 0', fontSize: '13px', color: '#333333' }}>Keep it tiny: one cue, one yes/no success signal.</p>
              <input
                type="text"
                value={missionCue}
                onChange={(e) => setMissionCue(e.target.value)}
                placeholder="Cue (when/where this should fire)"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }}
              />
              <input
                type="text"
                value={missionSignal}
                onChange={(e) => setMissionSignal(e.target.value)}
                placeholder="Success signal (binary)"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }}
              />
              <select
                value={missionValueTag}
                onChange={(e) => setMissionValueTag(e.target.value)}
                style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '8px' }}
              >
                <option value="">Value tag (optional)</option>
                {VALUE_TAGS.map((v) => (
                  <option key={v} value={v}>{v}</option>
                ))}
              </select>

              <div className="btnRow">
                <button className="btn btnPrimary" onClick={completeSession} disabled={!bridgeReady}>
                  Complete session ({Math.min(PROGRAM_TARGET, progress.totalSessionsCompleted + 1)}/{PROGRAM_TARGET})
                </button>
                <button className="btn btnSecondary" onClick={() => setScreen('home')}>Back</button>
              </div>
            </section>
          </main>
        </div>
      );
    }

    if (screen === 'mission_outcome') {
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><span className="iconText">T</span></div>
              <div>
                <p className="title">Capacity Training Coach</p>
                <p className="subtitle">Mission check-in</p>
              </div>
            </div>
            <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
          </div>
          <main className="content">
            <section className="card">
              <h1 className="h1">Mission Check-In</h1>
              <p className="p">This helps the app suggest the right kind of session next time.</p>
            </section>
            {!pendingMission ? (
              <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
                <p style={{ margin: '0 0 10px 0' }}>You don't have a mission to check in on yet.</p>
                <div className="btnRow">
                  <button className="btn btnPrimary" onClick={() => setScreen('home')}>Back to Home</button>
                </div>
              </section>
            ) : (
            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 6px 0', fontWeight: 900 }}>Your cue</p>
              <p style={{ margin: '0 0 10px 0' }}>{pendingMission?.cue || '-'}</p>
              <p style={{ margin: '0 0 6px 0', fontWeight: 900 }}>Your success signal</p>
              <p style={{ margin: '0 0 10px 0' }}>{pendingMission?.success_signal || '-'}</p>
              <div className="btnRow" style={{ marginTop: 0 }}>
                <select value={missionOutcome.cue_fired} onChange={(e) => setMissionOutcome((p) => ({ ...p, cue_fired: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="YES">Did your cue happen? Yes</option>
                  <option value="NO">Did your cue happen? No</option>
                </select>
                <select value={missionOutcome.success_met} onChange={(e) => setMissionOutcome((p) => ({ ...p, success_met: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="YES">Did you complete it? Yes</option>
                  <option value="PARTLY">Did you complete it? Partly</option>
                  <option value="NO">Did you complete it? No</option>
                </select>
              </div>
              <div className="btnRow">
                <select value={missionOutcome.blocker} onChange={(e) => setMissionOutcome((p) => ({ ...p, blocker: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">What mainly got in the way? (Optional)</option>
                  <option value="state">State (hot/scattered/flat)</option>
                  <option value="capacity">Training (could not hold the rule)</option>
                  <option value="context">Time and context</option>
                  <option value="unsure">Not sure</option>
                </select>
                <select value={missionOutcome.value_tag} onChange={(e) => setMissionOutcome((p) => ({ ...p, value_tag: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Value tag: none</option>
                  {VALUE_TAGS.map((v) => (
                    <option key={v} value={v}>{v}</option>
                  ))}
                </select>
              </div>
              <div className="btnRow">
                <button className="btn btnPrimary" onClick={saveMissionOutcome}>Save check-in</button>
                <button className="btn btnSecondary" onClick={() => setScreen('home')}>Back</button>
              </div>
            </section>
            )}
          </main>
        </div>
      );
    }

    return (
      <div className="screen">
        <div className="topbar">
          <div className="brandleft">
            <div className="icon"><span className="iconText">T</span></div>
            <div>
              <p className="title">Capacity Training Coach</p>
              <p className="subtitle">i3 Mindware session coordinator</p>
            </div>
          </div>
          <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
        </div>

        <main className="content">
          <section className="card">
            <h1 className="h1">Training Program</h1>
            <p className="p">24 sessions total. No anchor wheel. Choose any of the 4 n-back variants each session.</p>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Progress</p>
            <p style={{ marginTop: '8px' }}>{programV11.program_session_index}/{PROGRAM_TARGET} complete | {sessionsRemaining} remaining</p>
            <p style={{ marginTop: '6px', fontSize: '13px', color: '#555555' }}>
              Calendar entries: {programV11.calendar_entry_count} | Consecutive rests: {programV11.consecutive_rest_count}
            </p>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Today's suggestion</p>
            <p style={{ marginTop: '8px' }}>
              Session style: <b>{SESSION_LABELS[recommendationV11.recommended_session_type] || 'Build'}</b> | Game: <b>{GAME_LABEL[GAME_ID_FROM_ENUM[recommendationV11.recommended_game]] || recommendationV11.recommended_game}</b>
            </p>
            <p style={{ marginTop: '4px', fontSize: '13px', color: '#555555' }}>{recommendationV11.recommendation_reason}</p>
            {recommendationV11.probe_radius ? (
              <p style={{ marginTop: '4px', fontSize: '13px', color: '#555555' }}>
                Switch test: {SWITCH_SIZE_LABELS[recommendationV11.probe_radius] || recommendationV11.probe_radius} | Target game: {recommendationV11.probe_target_game}
              </p>
            ) : null}
            {pendingMission ? (
              <p style={{ marginTop: '8px', fontSize: '13px', color: '#2764B7', fontWeight: 700 }}>
                You have a mission to check in on before your next session.
              </p>
            ) : null}
            <div className="btnRow">
              <button className="btn" style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }} onClick={saveRestDay}>
                Take rest day
              </button>
              {pendingMission ? (
                <button
                  className="btn"
                  style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }}
                  onClick={() => setScreen('mission_outcome')}
                >
                  Mission check-in
                </button>
              ) : null}
            </div>
            {programV11.consecutive_rest_count >= 2 ? (
              <div style={{ marginTop: '10px' }}>
                <p style={{ margin: 0, color: '#9a5b00', fontWeight: 700 }}>
                  Reset day recommended: 2 or more rest days in a row.
                </p>
                <label style={{ display: 'block', marginTop: '6px', fontSize: '13px' }}>
                  <input type="checkbox" checked={restConfirm} onChange={(e) => setRestConfirm(e.target.checked)} /> Confirm another rest day
                </label>
                <input
                  type="text"
                  value={restReason}
                  onChange={(e) => setRestReason(e.target.value)}
                  placeholder="Optional reason"
                  style={{ marginTop: '6px' }}
                />
              </div>
            ) : null}
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Progress checks</p>
            <p style={{ marginTop: '8px' }}>
              Switch tests passed: Small <b>{proofCounters.near ? 'Yes' : 'No'}</b> | Medium <b>{proofCounters.mid ? 'Yes' : 'No'}</b> | Big <b>{proofCounters.far ? 'Yes' : 'No'}</b>
            </p>
            <p style={{ marginTop: '6px' }}>
              Still holds later: <b>{proofCounters.delay_holds}</b> | Real-life cue wins: <b>{proofCounters.mission_successes}</b>
            </p>
            <p style={{ marginTop: '6px' }}>
              Steady sessions in a row: <b>{proofCounters.stability_streak}</b>
            </p>
            {notCountedNote ? (
              <p style={{ marginTop: '8px', fontSize: '13px', color: '#555555' }}>{notCountedNote}</p>
            ) : null}
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Quick state check</p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#333333' }}>
              Quick self-check before training. These are simple readiness sliders.
            </p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#555555' }}>
              Pressure/load = how overloaded you feel. Focus slips = mind wandering. Task fit = how well today's plan fits your current state.
            </p>
            {[
              ['load', 'Pressure / load'],
              ['drift', 'Focus slips (mind-wandering)'],
              ['mismatch', 'Task fit (how well today\'s plan fits)']
            ].map(([k, label]) => (
              <div key={k} style={{ marginBottom: '10px' }}>
                <label style={{ fontWeight: 700 }}>{label}: {stateRatings[k]}</label>
                <input
                  type="range"
                  min="0"
                  max="10"
                  value={stateRatings[k]}
                  onChange={(e) => setStateRatings((prev) => ({ ...prev, [k]: Number(e.target.value) }))}
                  style={{ width: '100%' }}
                />
              </div>
            ))}
            <div className="btnRow" style={{ marginTop: 8 }}>
              <button className="btn" style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }} onClick={estimateZoneFromRatings}>
                Check state
              </button>
            </div>
            {lastStateReason ? (
              <p style={{ margin: '8px 0 0 0', fontSize: '13px', color: '#333333' }}>
                {lastStateReason}
              </p>
            ) : null}
            <div className="btnRow">
              {[
                { id: 'in_band', label: 'Ready for full session' },
                { id: 'light', label: 'Go lighter today' },
                { id: 'reset', label: 'Reset day' }
              ].map((z) => (
                <button
                  key={z.id}
                  className="btn"
                  onClick={() => {
                    setZoneMode(z.id);
                    setPlanType(computePlanType(z.id));
                  }}
                  style={{
                    background: zoneMode === z.id ? '#E8F4FF' : '#FFFFFF',
                    border: '1px solid ' + (zoneMode === z.id ? '#2764B7' : '#E0E0E0'),
                    color: '#111111'
                  }}
                >
                  {z.label}
                </button>
              ))}
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Optional breathing routine</p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#333333' }}>
              Simplified from Zone Coach (no HR capture).
            </p>
            <select
              value={breathRoutine}
              onChange={(e) => setBreathRoutine(e.target.value)}
              style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }}
            >
              <option value="upshift">Upshift</option>
              <option value="amplify">Amplify</option>
              <option value="downshift">Downshift</option>
            </select>
            <p style={{ margin: '0 0 4px 0', fontWeight: 700 }}>{BREATH_ROUTINES[breathRoutine].name}</p>
            <p style={{ margin: '0 0 4px 0', fontSize: '13px' }}>{BREATH_ROUTINES[breathRoutine].description}</p>
            <p style={{ margin: 0, fontSize: '13px', color: '#555555' }}>{BREATH_ROUTINES[breathRoutine].cue}</p>
            <div className="btnRow">
              <button
                className="btn"
                style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }}
                onClick={() => {
                  setBreathRemaining(90);
                  setBreathRunning(true);
                }}
              >
                Start 90s routine
              </button>
              {breathRunning ? (
                <button
                  className="btn"
                  style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', color: '#333333' }}
                  onClick={() => {
                    setBreathRunning(false);
                    setBreathRemaining(0);
                  }}
                >
                  Stop
                </button>
              ) : null}
            </div>
            {breathRunning ? (
              <p style={{ margin: '8px 0 0 0', fontWeight: 900 }}>
                {Math.max(0, breathRemaining)}s remaining
              </p>
            ) : null}
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Session settings</p>
            <div className="btnRow">
              <select value={speedPreset} onChange={(e) => setSpeedPreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                <option value="slow">Speed: Slow</option>
                <option value="normal">Speed: Normal</option>
                <option value="fast">Speed: Fast</option>
              </select>
              <select value={interferencePreset} onChange={(e) => setInterferencePreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                <option value="low">Distraction level: Low</option>
                <option value="normal">Distraction level: Normal</option>
                <option value="high">Distraction level: High</option>
              </select>
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Choose today's i3 Mindware game</p>
            <div style={{ display: 'grid', gap: '10px' }}>
              {GAMES.map((g) => (
                <button
                  key={g.id}
                  className="btn"
                  onClick={() => setSelectedGame(g.id)}
                  style={{
                    width: '100%',
                    textAlign: 'left',
                    background: selectedGame === g.id ? '#E8F4FF' : '#FFFFFF',
                    border: '1px solid ' + (selectedGame === g.id ? '#2764B7' : '#E0E0E0'),
                    color: '#111111'
                  }}
                >
                  <div style={{ fontWeight: 900 }}>{g.label}{g.id === 'classic' ? ' (Suggested start)' : ''}</div>
                  <div style={{ fontSize: '13px', marginTop: '6px', opacity: 0.85 }}>{g.note}</div>
                </button>
              ))}
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Today's plan: {planLabel}</p>
            <p style={{ marginTop: '8px' }}>Open i3 Mindware, run {selectedGameObj.label}, then return for wrap-up.</p>
            <div className="btnRow">
              <button className="btn btnPrimary" onClick={launchExternalGame}>Launch external app flow</button>
              <button className="btn btnSecondary" onClick={() => setScreen('results')}>I already ran it</button>
            </div>
          </section>
        </main>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>
</body>
</html>
