<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IQ Capacity Coach v1</title>
  <link rel="stylesheet" href="../../../../branding/brand.css">
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    .capacityNarrow {
      width: clamp(340px, 34vw, 620px);
      margin: 0 auto;
    }
    @media (max-width: 980px) {
      .capacityNarrow {
        width: 100%;
      }
    }
    .appIcon {
      width: 28px;
      height: 28px;
      object-fit: contain;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="root"></div>

<script type="text/babel" data-presets="env,react">
  const { useEffect, useMemo, useRef, useState } = React;
  const APP_ICON = '../../../../branding/Trident-G-Icon.svg';

  const STORAGE = {
    PROGRESS: 'iqmw.progress.v1',
    PROGRESS_LEGACY: 'trainingProgress',
    CAPACITY_LAST_GAME: 'iqmw.capacity.lastGameSelection',
    CAPACITY_LAST_SESSION: 'iqmw.capacity.lastSession',
    SETTINGS_V11: 'iqmw.capacity.settings.v1',
    PROGRAM_V11: 'iqmw.capacity.program.v1',
    SESSIONS_V11: 'iqmw.capacity.sessions.v1',
    MISSIONS_V11: 'iqmw.capacity.missions.v1'
  };

  const PROGRAM_TARGET = 24;
  const SESSION_TYPES = ['TUNE', 'EXPLORE', 'TIGHTEN', 'PROBE', 'RECHECK', 'RESET'];
  const GAME_ENUM = {
    classic: 'CLASSIC',
    emotional: 'EMOTIONAL',
    non_categorical: 'NONCAT',
    logic_gated: 'OUTPUT_GATED'
  };
  const GAME_ID_FROM_ENUM = {
    CLASSIC: 'classic',
    EMOTIONAL: 'emotional',
    NONCAT: 'non_categorical',
    OUTPUT_GATED: 'logic_gated'
  };
  const DEFAULT_SETTINGS_V11 = {
    schemaVersion: 'capacity_settings_v1_1',
    thresholds: {
      plateau_epsilon: 0.25,
      churn_volatility: 5,
      probe_swap_cost_min: -1,
      probe_recovery_delta_min: -0.5,
      probe_end_hold_min: -1,
      recheck_mean_tolerance: 1.0
    },
    defaults: {
      pulse_block_index: 4,
      recovery_blocks: [5, 6],
      end_hold_block: 10
    }
  };
  // Planned opportunities only: these slots can be deferred when out-of-band or data-quality is compromised.
  const makeScaffold = () => Array.from({ length: PROGRAM_TARGET }, (_, i) => ({
    program_day: i + 1,
    probe_slot: (i + 1) % 4 === 0,
    recheck_slot: i + 1 === 12 || i + 1 === 24
  }));
  const DEFAULT_PROGRAM_V11 = {
    schemaVersion: 'capacity_program_v1_1',
    // Legacy-only counter kept for back-compat with earlier app state.
    // Do not use as source of truth for new flow logic.
    program_day_completed: 0,
    // Authoritative training-session counter (increments on TRAINING entries only).
    program_session_index: 0,
    calendar_entry_count: 0,
    consecutive_rest_count: 0,
    anchor_lane: 'CLASSIC',
    last_probe_radius_passed: null,
    last_probe_game: null,
    last_probe_radius: null,
    last_passed_probe_signature: null,
    scaffold: makeScaffold()
  };

  const GAMES = [
    { id: 'classic', label: 'Classic n-back', note: 'Good default starting point.' },
    { id: 'emotional', label: 'Emotional n-back', note: 'Add salience control under load.' },
    { id: 'non_categorical', label: 'Non-categorical n-back', note: 'Train broad runtime control.' },
    { id: 'logic_gated', label: 'Logic-gated n-back', note: 'Rule discipline and clean updating.' }
  ];
  const GAME_LABEL = GAMES.reduce((acc, g) => ({ ...acc, [g.id]: g.label }), {});
  const VALUE_TAGS = ['risk', 'opportunity', 'urgency', 'social_cost'];
  const SESSION_LABELS = {
    TUNE: 'Build',
    EXPLORE: 'Explore',
    TIGHTEN: 'Stabilise',
    PROBE: 'Switch test',
    RECHECK: 'Later check',
    RESET: 'Reset day'
  };
  const SWITCH_SIZE_LABELS = {
    NEAR: 'Small switch',
    MID: 'Medium switch',
    FAR: 'Big switch'
  };

  const makeRepeat = (n, seq) => Array.from({ length: n }, () => seq).flat();
  const BREATH_ROUTINES = {
    upshift: {
      name: 'Upshift',
      description: 'Inhale-led breathing to raise engagement.',
      cue: 'Inhale 3s, exhale 2s.',
      phases: makeRepeat(18, [
        { label: 'Inhale', durationMs: 3000, kind: 'inhale' },
        { label: 'Exhale', durationMs: 2000, kind: 'exhale' }
      ])
    },
    amplify: {
      name: 'Amplify',
      description: 'Slow-paced breathing to stabilise.',
      cue: 'Inhale 4s, exhale 6s.',
      phases: makeRepeat(9, [
        { label: 'Inhale', durationMs: 4000, kind: 'inhale' },
        { label: 'Exhale', durationMs: 6000, kind: 'exhale' }
      ])
    },
    downshift: {
      name: 'Downshift',
      description: 'Cyclic sighing to reduce overload.',
      cue: 'Two short inhales, one long sigh out.',
      phases: makeRepeat(10, [
        { label: 'Inhale (1)', durationMs: 1000, kind: 'inhale' },
        { label: 'Inhale (2)', durationMs: 1000, kind: 'inhale' },
        { label: 'Sigh out', durationMs: 7000, kind: 'exhale' }
      ])
    }
  };

  const safeParse = (raw, fallback) => {
    try { return JSON.parse(raw); } catch { return fallback; }
  };
  const mean = (arr) => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
  const uid = () => 'id_' + Math.random().toString(36).slice(2, 10) + '_' + Date.now().toString(36);
  const saveJson = (key, value) => {
    try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
  };
  const asObject = (value) => (value && typeof value === 'object' && !Array.isArray(value) ? value : {});
  const loadProgramV11 = () => {
    const raw = asObject(safeParse(localStorage.getItem(STORAGE.PROGRAM_V11), {}));
    return {
      ...DEFAULT_PROGRAM_V11,
      ...raw,
      program_session_index: Number(raw.program_session_index ?? raw.program_day_completed ?? 0),
      last_probe_game: raw.last_probe_game || null,
      last_probe_radius: raw.last_probe_radius || null,
      last_passed_probe_signature: raw.last_passed_probe_signature && Object.keys(asObject(raw.last_passed_probe_signature)).length
        ? asObject(raw.last_passed_probe_signature)
        : null,
      scaffold: Array.isArray(raw.scaffold) && raw.scaffold.length === PROGRAM_TARGET ? raw.scaffold : makeScaffold()
    };
  };
  const loadSessionsV11 = () => {
    const rows = safeParse(localStorage.getItem(STORAGE.SESSIONS_V11), []);
    return Array.isArray(rows) ? rows : [];
  };
  const loadMissionsV11 = () => {
    const rows = safeParse(localStorage.getItem(STORAGE.MISSIONS_V11), []);
    return Array.isArray(rows) ? rows : [];
  };
  const loadSettingsV11 = () => {
    const raw = asObject(safeParse(localStorage.getItem(STORAGE.SETTINGS_V11), {}));
    return {
      ...DEFAULT_SETTINGS_V11,
      ...raw,
      thresholds: { ...DEFAULT_SETTINGS_V11.thresholds, ...asObject(raw.thresholds) },
      defaults: { ...DEFAULT_SETTINGS_V11.defaults, ...asObject(raw.defaults) }
    };
  };
  const getTrainingSessions = (rows) => rows.filter((x) => x.entry_type === 'TRAINING');
  const isEvidenceEligible = (s) => (
    Boolean(s && s.derived) &&
    !s.ended_early &&
    s.data_quality === 'OK' &&
    (s.log?.plan_confirmed ?? true)
  );
  const nextProbeRadius = (lastPassed) => {
    if (!lastPassed) return 'NEAR';
    if (lastPassed === 'NEAR') return 'MID';
    return 'FAR';
  };
  const PROBE_ROTATION = {
    CLASSIC: {
      NEAR: ['EMOTIONAL', 'NONCAT'],
      MID: ['NONCAT', 'OUTPUT_GATED'],
      FAR: ['OUTPUT_GATED', 'EMOTIONAL']
    },
    EMOTIONAL: {
      NEAR: ['CLASSIC', 'NONCAT'],
      MID: ['OUTPUT_GATED', 'CLASSIC'],
      FAR: ['NONCAT', 'OUTPUT_GATED']
    },
    NONCAT: {
      NEAR: ['CLASSIC', 'EMOTIONAL'],
      MID: ['OUTPUT_GATED', 'CLASSIC'],
      FAR: ['EMOTIONAL', 'OUTPUT_GATED']
    },
    OUTPUT_GATED: {
      NEAR: ['CLASSIC', 'NONCAT'],
      MID: ['NONCAT', 'EMOTIONAL'],
      FAR: ['EMOTIONAL', 'CLASSIC']
    }
  };
  const resolveProbeTarget = (anchor, radius, lastProbeGame) => {
    const candidates = PROBE_ROTATION[anchor]?.[radius] || ['CLASSIC'];
    if (!lastProbeGame) return candidates[0];
    return candidates.find((g) => g !== lastProbeGame) || candidates[0];
  };
  const chooseExploreGame = (anchorLane, ratings) => {
    if ((ratings?.drift ?? 0) >= 6) return anchorLane === 'NONCAT' ? 'CLASSIC' : 'NONCAT';
    if ((ratings?.load ?? 0) >= 7) return anchorLane === 'EMOTIONAL' ? 'CLASSIC' : 'EMOTIONAL';
    if ((ratings?.mismatch ?? 0) >= 6) return anchorLane === 'OUTPUT_GATED' ? 'NONCAT' : 'OUTPUT_GATED';
    const fallback = {
      CLASSIC: 'EMOTIONAL',
      EMOTIONAL: 'CLASSIC',
      NONCAT: 'CLASSIC',
      OUTPUT_GATED: 'CLASSIC'
    };
    return fallback[anchorLane] || 'CLASSIC';
  };
  const cleanBreakthroughSignal = (session) => {
    if (!session || session.data_quality !== 'OK') return false;
    if (Array.isArray(session.block_logs) && session.block_logs.length) {
      const hasBadBlock = session.block_logs.some((b) =>
        b.felt_difficulty === 'hard' || b.state_drift === 'lost_thread' || b.engagement === 'flat'
      );
      return !hasBadBlock;
    }
    const d = session.derived || {};
    return (d.drop_count ?? 99) <= 2 && (d.end_hold_delta ?? -99) >= -1 && (d.volatility ?? 99) <= 4;
  };
  const computeDerivedFromNTrace = (nTrace, pulseCfg = { block_index: 4, recovery_blocks: [5, 6] }) => {
    const n = nTrace.map((x) => Number(x));
    const volatility = n.slice(1).reduce((acc, v, i) => acc + (v !== n[i] ? 1 : 0), 0);
    const dropDeltas = n.slice(1).map((v, i) => n[i] - v).filter((d) => d > 0);
    const baselineMean = mean([n[0], n[1]]);
    const recBlocks = (pulseCfg?.recovery_blocks || [5, 6]).map((ix) => n[Math.max(0, Math.min(9, ix - 1))]);
    const recoveryMean = mean(recBlocks);
    return {
      mean_n: Number(mean(n).toFixed(2)),
      volatility,
      drop_count: dropDeltas.length,
      max_drop: dropDeltas.length ? Math.max(...dropDeltas) : 0,
      end_hold_delta: Number((n[9] - baselineMean).toFixed(2)),
      baseline_mean: Number(baselineMean.toFixed(2)),
      recovery_delta: Number((recoveryMean - baselineMean).toFixed(2))
    };
  };
  const trendFlags = (sameLaneSessions, epsilon = 0.25) => {
    const withDerived = sameLaneSessions.filter((s) => Boolean(s?.derived) && !s?.ended_early);
    const last3 = withDerived.slice(-3);
    if (last3.length < 3) return { plateau: false, churn: false, breakthrough: false };
    const [a, b, c] = last3.map((s) => s.derived || {});
    const plateau = (Number(c.mean_n || 0) - Number(a.mean_n || 0)) < epsilon && mean([a.volatility || 0, b.volatility || 0, c.volatility || 0]) <= 2;
    const churn = (c.volatility || 0) > 5 || (c.end_hold_delta || 0) < -1;
    const breakthrough = (Number(c.mean_n || 0) - Number(b.mean_n || 0)) >= 1 || (((b.volatility || 0) > 0) && ((c.volatility || 99) <= Math.max(1, (b.volatility || 1) / 2)) && ((c.end_hold_delta || -99) > (b.end_hold_delta || -99)));
    return { plateau, churn, breakthrough };
  };

  const loadProgress = () => {
    const fromNew = safeParse(localStorage.getItem(STORAGE.PROGRESS), null);
    const fromLegacy = safeParse(localStorage.getItem(STORAGE.PROGRESS_LEGACY), null);
    const raw = fromNew || fromLegacy || {};

    const completed = Number(raw.totalSessionsCompleted)
      || Number(raw.anchorSessionsCompleted) + Number(raw.swapSessionsCompleted)
      || 0;

    return {
      schemaVersion: 'progress_v1',
      totalSessionsCompleted: completed,
      totalSessionsTarget: PROGRAM_TARGET,
      lastSessionDate: raw.lastSessionDate || null,
      programStartDate: raw.programStartDate || new Date().toISOString(),
      programCompleted: completed >= PROGRAM_TARGET,
      programCompletionDate: raw.programCompletionDate || null
    };
  };

  const saveProgress = (next) => {
    const json = JSON.stringify(next);
    localStorage.setItem(STORAGE.PROGRESS, json);
    localStorage.setItem(STORAGE.PROGRESS_LEGACY, json);
  };

  function App() {
    const [screen, setScreen] = useState('home');
    const [progress, setProgress] = useState(() => loadProgress());
    const [settingsV11] = useState(() => loadSettingsV11());
    const [programV11, setProgramV11] = useState(() => loadProgramV11());
    const [sessionsV11, setSessionsV11] = useState(() => loadSessionsV11());
    const [missionsV11, setMissionsV11] = useState(() => loadMissionsV11());
    const [zoneMode, setZoneMode] = useState('in_band');
    const [planType, setPlanType] = useState('type1_build');
    const [stateRatings, setStateRatings] = useState({ load: 4, drift: 4, mismatch: 4 });
    const [lastStateReason, setLastStateReason] = useState('');
    const [selectedGame, setSelectedGame] = useState('classic');
    const [speedPreset, setSpeedPreset] = useState('default');
    const [interferencePreset, setInterferencePreset] = useState('default');
    const [bridgeObs, setBridgeObs] = useState('');
    const [bridgeMove, setBridgeMove] = useState('');
    const [breathRoutine, setBreathRoutine] = useState('amplify');
    const [breathRunning, setBreathRunning] = useState(false);
    const [breathRemaining, setBreathRemaining] = useState(0);
    const [breathPhaseLabel, setBreathPhaseLabel] = useState('Ready');
    const [breathPhaseKind, setBreathPhaseKind] = useState('inhale');
    const [breathPhaseProgress, setBreathPhaseProgress] = useState(0);
    const breathStartRef = useRef(null);
    const breathRafRef = useRef(null);
    const [restConfirm, setRestConfirm] = useState(false);
    const [restReason, setRestReason] = useState('');
    const [sessionType, setSessionType] = useState('TUNE');
    const [baselineMode, setBaselineMode] = useState('ADAPTIVE');
    const [fixedN, setFixedN] = useState(2);
    const [pulseType, setPulseType] = useState('');
    const [pulseBlockIndex, setPulseBlockIndex] = useState(4);
    const [recoveryBlocksCsv, setRecoveryBlocksCsv] = useState('5,6');
    const [endHoldBlock, setEndHoldBlock] = useState(10);
    const [outputGateMode, setOutputGateMode] = useState('OR');
    const [nTraceInput, setNTraceInput] = useState(Array.from({ length: 10 }, () => ''));
    const [blockDone, setBlockDone] = useState(Array.from({ length: 10 }, () => false));
    const [noResponseBlocks, setNoResponseBlocks] = useState([]);
    const [fixedNBlocks, setFixedNBlocks] = useState([]);
    const [planConfirmed, setPlanConfirmed] = useState(false);
    const [temptationPressure, setTemptationPressure] = useState('');
    const [missionCue, setMissionCue] = useState('');
    const [missionSignal, setMissionSignal] = useState('');
    const [missionValueTag, setMissionValueTag] = useState('');
    const [missionOutcome, setMissionOutcome] = useState({
      cue_fired: 'YES',
      success_met: 'PARTLY',
      blocker: '',
      value_tag: ''
    });
    const [sessionRun, setSessionRun] = useState(null);
    const [quickCheck, setQuickCheck] = useState({
      level_played: '',
      felt_difficulty: 'ok',
      engagement: 'ok',
      state_drift: 'clean'
    });

    const selectedGameObj = useMemo(
      () => GAMES.find((g) => g.id === selectedGame) || GAMES[0],
      [selectedGame]
    );

    const trainingSessionsV11 = useMemo(() => getTrainingSessions(sessionsV11), [sessionsV11]);
    const sessionsRemaining = Math.max(0, PROGRAM_TARGET - (programV11.program_session_index || 0));
    const pendingMission = useMemo(() => missionsV11.find((m) => !m.outcome) || null, [missionsV11]);
    const evidenceSessions = useMemo(() => trainingSessionsV11.filter((s) => isEvidenceEligible(s)), [trainingSessionsV11]);
    const proofCounters = useMemo(() => {
      const probes = evidenceSessions.filter((s) => s.session_type === 'PROBE' && s.probe?.pass === true);
      const rechecks = evidenceSessions.filter((s) => s.session_type === 'RECHECK' && s.recheck?.pass === true).length;
      const stabilityStreak = (() => {
        let streak = 0;
        for (let i = evidenceSessions.length - 1; i >= 0; i -= 1) {
          const d = evidenceSessions[i].derived;
          if (d && d.drop_count <= 2 && d.end_hold_delta >= -1) streak += 1;
          else break;
        }
        return streak;
      })();
      const missionSuccesses = missionsV11.filter((m) => m.outcome && m.outcome.cue_fired === 'YES' && m.outcome.success_met === 'YES').length;
      return {
        near: probes.some((s) => s.probe?.probe_radius === 'NEAR'),
        mid: probes.some((s) => s.probe?.probe_radius === 'MID'),
        far: probes.some((s) => s.probe?.probe_radius === 'FAR'),
        delay_holds: rechecks,
        mission_successes: missionSuccesses,
        stability_streak: stabilityStreak
      };
    }, [evidenceSessions, missionsV11]);
    const notCountedNote = useMemo(() => {
      const last = [...trainingSessionsV11].reverse().find(Boolean);
      if (!last) return '';
      if (last.data_quality === 'UNCONFIRMED_PLAN') return 'Not counted: you did not follow today\'s plan settings.';
      if (last.data_quality === 'COMPROMISED') return 'Not counted: some blocks had no responses.';
      if (last.session_type === 'RECHECK' && !last.recheck?.of_session_id) return 'Not counted: this check was not matched to a previous session.';
      return '';
    }, [trainingSessionsV11]);
    const recommendationV11 = useMemo(() => {
      const zoneRecommendation = zoneMode === 'reset' ? 'RESET' : (zoneMode === 'light' ? 'LIGHT' : 'FULL');
      const lane = programV11.anchor_lane || 'CLASSIC';
      const sameLane = trainingSessionsV11.filter((s) => s.game === lane);
      const tf = trendFlags(sameLane, settingsV11.thresholds.plateau_epsilon);
      const row = programV11.scaffold[Math.max(0, programV11.program_session_index)] || { probe_slot: false, recheck_slot: false };
      const latestTraining = [...trainingSessionsV11].reverse().find(Boolean);
      const latestLaneSession = [...sameLane].reverse().find(Boolean);
      const lastSessionIsClean = !latestTraining || latestTraining.data_quality === 'OK';
      const lastProbeSession = [...trainingSessionsV11].reverse().find((s) => s.session_type === 'PROBE');
      const lastProbeGame = programV11.last_probe_game || lastProbeSession?.game || null;
      let session_type = 'TUNE';
      let reason = 'Stable training day.';
      let game = lane;
      let probe_radius = null;
      let probe_target_game = null;
      let recheck_target_session_id = null;
      let probe_pending_reason = null;
      let recommended_plan = null;

      if (zoneRecommendation === 'RESET') {
        session_type = 'RESET';
        reason = 'Your state is overloaded today, so easier settings are recommended.';
      } else if (zoneRecommendation === 'LIGHT') {
        session_type = 'TIGHTEN';
        reason = 'A lighter stabilising session is recommended today.';
      }
      if (tf.churn && zoneRecommendation !== 'RESET') {
        session_type = 'TIGHTEN';
        reason = 'Recent sessions were up and down, so stabilise first.';
      }
      if (session_type === 'TUNE' && row.recheck_slot && zoneRecommendation === 'FULL' && lastSessionIsClean) {
        const sig = programV11.last_passed_probe_signature && programV11.last_passed_probe_signature.probe_game
          ? programV11.last_passed_probe_signature
          : null;
        if (sig) {
          session_type = 'RECHECK';
          game = sig.probe_game;
          probe_radius = sig.probe_radius || null;
          probe_target_game = sig.probe_game;
          recheck_target_session_id = sig.target_session_id || null;
          recommended_plan = {
            speed: (sig.speed || 'DEFAULT').toLowerCase(),
            distraction: (sig.distraction || 'DEFAULT').toLowerCase(),
            baseline_mode: (sig.level_mode || 'ADAPTIVE').toUpperCase(),
            fixed_n: sig.hold_level ?? null,
            pulse_type: sig.pulse_type || '',
            pulse_block_index: sig.pulse_block_index || settingsV11.defaults.pulse_block_index,
            recovery_blocks: sig.recovery_blocks || settingsV11.defaults.recovery_blocks,
            end_hold_block: sig.end_hold_block || settingsV11.defaults.end_hold_block
          };
          reason = 'Planned later-check day: replaying your last passed switch signature.';
        } else {
          session_type = 'PROBE';
          probe_radius = 'NEAR';
          probe_target_game = resolveProbeTarget(lane, 'NEAR', lastProbeGame);
          game = probe_target_game;
          probe_pending_reason = 'recheck_fallback';
          reason = 'No passed switch signature yet, so a small switch test is suggested first.';
        }
      }
      const cleanBreakthrough = tf.breakthrough && cleanBreakthroughSignal(latestLaneSession);
      if (session_type === 'TUNE' && cleanBreakthrough && zoneRecommendation === 'FULL' && lastSessionIsClean) {
        session_type = 'PROBE';
        probe_radius = 'NEAR';
        probe_target_game = resolveProbeTarget(lane, 'NEAR', lastProbeGame);
        game = probe_target_game;
        probe_pending_reason = 'breakthrough';
        reason = 'Recent clean breakthrough detected: run a small switch test next.';
      } else if (session_type === 'TUNE' && row.probe_slot && zoneRecommendation === 'FULL' && lastSessionIsClean) {
        session_type = 'PROBE';
        probe_radius = nextProbeRadius(programV11.last_probe_radius_passed);
        probe_target_game = resolveProbeTarget(lane, probe_radius, lastProbeGame);
        game = probe_target_game;
        probe_pending_reason = 'planned_slot';
        reason = 'Today is a planned switch-test opportunity.';
      }
      if (session_type === 'TUNE' && tf.plateau && zoneRecommendation !== 'RESET') {
        session_type = 'EXPLORE';
        game = chooseExploreGame(lane, stateRatings);
        reason = 'You look flat or stuck, so a controlled explore day is suggested.';
      }
      return {
        recommended_session_type: session_type,
        recommendation_reason: reason,
        recommended_game: game,
        probe_radius,
        probe_target_game,
        recheck_target_session_id,
        probe_pending_reason,
        recommended_plan
      };
    }, [zoneMode, programV11, trainingSessionsV11, settingsV11, stateRatings]);

    const computePlanType = (zone) => {
      if (zone !== 'in_band') return 'type1_light';
      return 'type1_build';
    };

    const estimateZoneFromRatings = () => {
      const vals = [stateRatings.load, stateRatings.drift, stateRatings.mismatch];
      const avg = vals.reduce((a, b) => a + b, 0) / vals.length;
      const peak = Math.max(...vals);
      let nextZone = 'in_band';
      let reason = 'State looks manageable for normal training.';
      if (peak >= 8 || avg >= 7) {
        nextZone = 'reset';
        reason = 'You look overloaded right now, so use easier settings today.';
      } else if (avg >= 5) {
        nextZone = 'light';
        reason = 'You look a bit stretched, so keep this session lighter.';
      }
      setZoneMode(nextZone);
      setPlanType(computePlanType(nextZone));
      setLastStateReason(reason);
      if (nextZone === 'reset') setBreathRoutine('downshift');
      else if (nextZone === 'light') setBreathRoutine('amplify');
      else setBreathRoutine('upshift');
    };

    useEffect(() => {
      if (!breathRunning) {
        if (breathRafRef.current) cancelAnimationFrame(breathRafRef.current);
        breathRafRef.current = null;
        breathStartRef.current = null;
        return;
      }

      const targetMs = 90000;
      const pattern = BREATH_ROUTINES[breathRoutine];
      const cycleMs = pattern.phases.reduce((s, p) => s + p.durationMs, 0);
      if (!breathStartRef.current) breathStartRef.current = performance.now();

      const tick = () => {
        const elapsedMs = performance.now() - breathStartRef.current;
        const remainingMs = Math.max(0, targetMs - elapsedMs);
        setBreathRemaining(Math.ceil(remainingMs / 1000));

        const t = ((elapsedMs % cycleMs) + cycleMs) % cycleMs;
        let acc = 0;
        for (let i = 0; i < pattern.phases.length; i += 1) {
          const p = pattern.phases[i];
          const next = acc + p.durationMs;
          if (t >= acc && t < next) {
            setBreathPhaseLabel(p.label);
            setBreathPhaseKind(p.kind);
            setBreathPhaseProgress(p.durationMs > 0 ? (t - acc) / p.durationMs : 0);
            break;
          }
          acc = next;
        }

        if (remainingMs <= 0) {
          setBreathRunning(false);
          setBreathPhaseLabel('Complete');
          setBreathPhaseProgress(1);
          return;
        }
        breathRafRef.current = requestAnimationFrame(tick);
      };

      breathRafRef.current = requestAnimationFrame(tick);
      return () => {
        if (breathRafRef.current) cancelAnimationFrame(breathRafRef.current);
      };
    }, [breathRunning, breathRoutine]);

    useEffect(() => {
      const mapped = GAME_ID_FROM_ENUM[recommendationV11.recommended_game];
      if (mapped) setSelectedGame(mapped);
    }, [recommendationV11.recommended_game]);

    useEffect(() => {
      setSessionType(recommendationV11.recommended_session_type);
    }, [recommendationV11.recommended_session_type]);

    useEffect(() => {
      const plan = recommendationV11.recommended_plan;
      if (!plan) return;
      if (plan.speed) setSpeedPreset(plan.speed === 'fast' ? 'fast' : 'default');
      if (plan.distraction) setInterferencePreset(plan.distraction === 'high' ? 'high' : 'default');
      if (plan.baseline_mode) setBaselineMode(plan.baseline_mode === 'FIXED' ? 'FIXED' : 'ADAPTIVE');
      if (Number.isFinite(Number(plan.fixed_n)) && Number(plan.fixed_n) > 0) setFixedN(Number(plan.fixed_n));
      setPulseType(plan.pulse_type || '');
      if (Number.isFinite(Number(plan.pulse_block_index))) setPulseBlockIndex(Number(plan.pulse_block_index));
      if (Array.isArray(plan.recovery_blocks) && plan.recovery_blocks.length) {
        setRecoveryBlocksCsv(plan.recovery_blocks.join(','));
      }
      if (Number.isFinite(Number(plan.end_hold_block))) setEndHoldBlock(Number(plan.end_hold_block));
    }, [recommendationV11.recommended_plan]);

    useEffect(() => {
      saveJson(STORAGE.SETTINGS_V11, settingsV11);
    }, [settingsV11]);

    useEffect(() => {
      saveJson(STORAGE.PROGRAM_V11, programV11);
      // Legacy mirror only: keep old progress keys readable by older surfaces.
      const legacy = {
        ...progress,
        totalSessionsCompleted: programV11.program_session_index,
        totalSessionsTarget: PROGRAM_TARGET,
        programCompleted: programV11.program_session_index >= PROGRAM_TARGET
      };
      saveProgress(legacy);
      setProgress(legacy);
    }, [programV11]);

    useEffect(() => {
      saveJson(STORAGE.SESSIONS_V11, sessionsV11);
    }, [sessionsV11]);

    useEffect(() => {
      saveJson(STORAGE.MISSIONS_V11, missionsV11);
    }, [missionsV11]);

    const firstSession = (programV11.program_session_index || 0) === 0;
    const planLabel = firstSession
      ? 'No session-style suggestion yet (first session)'
      : (SESSION_LABELS[recommendationV11.recommended_session_type] || 'Build') + ' session';

    const parseRecoveryBlocks = () => {
      const parsed = recoveryBlocksCsv
        .split(',')
        .map((x) => Number(x.trim()))
        .filter((x) => Number.isFinite(x) && x >= 1 && x <= 10);
      return parsed.length ? parsed : [5, 6];
    };

    const getNTraceOrNull = () => {
      const parsed = nTraceInput.map((x) => Number(x));
      if (parsed.some((x) => !Number.isFinite(x) || x < 0)) return null;
      return parsed;
    };
    const buildProbeSignature = ({
      anchorLane,
      probeGame,
      probeRadius,
      baseline,
      pulseType,
      pulseBlockIndex,
      recoveryBlocks,
      endHoldBlock,
      targetSessionId,
      timestamp
    }) => ({
      anchor_lane: anchorLane,
      probe_game: probeGame,
      probe_radius: probeRadius,
      speed: baseline.speed,
      distraction: baseline.interference,
      level_mode: baseline.mode,
      hold_level: baseline.fixed_n ?? null,
      pulse_type: pulseType || null,
      pulse_block_index: Number(pulseBlockIndex),
      recovery_blocks: recoveryBlocks.slice(),
      end_hold_block: Number(endHoldBlock),
      target_session_id: targetSessionId || null,
      ts: timestamp
    });

    const toggleBlockTag = (current, blockIndex) => (
      current.includes(blockIndex)
        ? current.filter((x) => x !== blockIndex)
        : [...current, blockIndex].sort((a, b) => a - b)
    );

    const createInitialPlan = () => ({
      level_mode: baselineMode === 'FIXED' ? 'hold' : 'auto',
      hold_at: baselineMode === 'FIXED' ? Number(fixedN) : null,
      speed: speedPreset === 'fast' ? 'fast' : 'default',
      distraction: interferencePreset === 'high' ? 'high' : 'default',
      pulse_used: 'none'
    });

    // Stable = not hard AND not lost-thread (if drift is collected).
    const isStableBlock = (b) => b.felt_difficulty !== 'hard' && (!b.state_drift || b.state_drift !== 'lost_thread');

    const startGuidedSession = () => {
      const nowIso = new Date().toISOString();
      const firstSession = (programV11.program_session_index || 0) === 0;
      const initialPlan = createInitialPlan();
      const selectedStyle = firstSession ? sessionType : (sessionType || recommendationV11.recommended_session_type);
      setSessionRun({
        id: uid(),
        started_at: nowIso,
        game: GAME_ENUM[selectedGame] || 'CLASSIC',
        session_style: selectedStyle,
        recommended_session_type: firstSession ? null : recommendationV11.recommended_session_type,
        baseline_plan: initialPlan,
        next_block_plan: initialPlan,
        next_block_index: 1,
        blocks: [],
        coach_note: firstSession ? 'First session baseline: start simple and learn your rhythm.' : 'Start with baseline settings.',
        ended_early: null
      });
      setQuickCheck({ level_played: '', felt_difficulty: 'ok', engagement: 'ok', state_drift: 'clean' });
      setScreen('during_session');
    };

    const computeNextPlansFromBlock = (currentRun, blockLog) => {
      const blocks = [...currentRun.blocks, blockLog];
      const recentStable = blocks.slice(-2).filter(isStableBlock).length === 2;
      let nextBaseline = { ...currentRun.baseline_plan };
      let nextPlan = { ...nextBaseline, pulse_used: 'none' };
      let note = 'Recommendation: Keep your baseline settings for this block.';

      if (blockLog.felt_difficulty === 'hard' || blockLog.state_drift === 'lost_thread') {
        if (nextBaseline.level_mode === 'hold' && Number(nextBaseline.hold_at || 1) > 1) {
          nextBaseline.hold_at = Number(nextBaseline.hold_at) - 1;
          note = 'Downshift: hold level reduced by 1.';
        } else if (nextBaseline.speed === 'fast') {
          nextBaseline.speed = 'default';
          note = 'Downshift: speed returned to default.';
        } else if (nextBaseline.distraction === 'high') {
          nextBaseline.distraction = 'default';
          note = 'Downshift: distraction returned to default.';
        } else {
          note = 'Hold steady on easy settings.';
        }
        nextPlan = { ...nextBaseline, pulse_used: 'none' };
        return { nextBaseline, nextPlan, note };
      }

      if (blockLog.felt_difficulty === 'easy' && blockLog.engagement === 'flat') {
        if (nextBaseline.speed !== 'fast') {
          nextBaseline.speed = 'fast';
          note = 'Upshift: speed increased to re-engage.';
        } else if (nextBaseline.distraction !== 'high') {
          nextBaseline.distraction = 'high';
          note = 'Upshift: distraction increased to re-engage.';
        } else if (recentStable && nextBaseline.level_mode === 'hold') {
          nextBaseline.hold_at = Number(nextBaseline.hold_at || 1) + 1;
          note = 'Upshift: hold level increased by 1.';
        }
        nextPlan = { ...nextBaseline, pulse_used: 'none' };
        return { nextBaseline, nextPlan, note };
      }

      if (recentStable && blockLog.felt_difficulty === 'ok') {
        const pulseTypeNext = blockLog.engagement === 'flat' ? 'speed' : 'distraction';
        nextPlan = {
          ...nextBaseline,
          pulse_used: pulseTypeNext,
          speed: pulseTypeNext === 'speed' ? 'fast' : nextBaseline.speed,
          distraction: pulseTypeNext === 'distraction' ? 'high' : nextBaseline.distraction
        };
        note = pulseTypeNext === 'speed'
          ? 'Pulse eligible: one fast-speed block next.'
          : 'Pulse eligible: one high-distraction block next.';
        return { nextBaseline, nextPlan, note };
      }

      return { nextBaseline, nextPlan, note: 'Recommendation: Keep your baseline settings for this block.' };
    };

    const openBlockQuickCheck = () => {
      setQuickCheck({ level_played: '', felt_difficulty: 'ok', engagement: 'ok', state_drift: 'clean' });
      setScreen('quick_check');
    };

    const submitBlockQuickCheck = () => {
      if (!sessionRun) return;
      const lvl = Number(quickCheck.level_played);
      if (!Number.isFinite(lvl) || lvl < 0) {
        alert('Enter the level played for this block.');
        return;
      }
      const blockLog = {
        block_index: sessionRun.next_block_index,
        level_played: lvl,
        level_mode: sessionRun.next_block_plan.level_mode,
        level_target: sessionRun.next_block_plan.level_mode === 'hold' ? sessionRun.next_block_plan.hold_at : null,
        speed: sessionRun.next_block_plan.speed,
        distraction: sessionRun.next_block_plan.distraction,
        pulse_used: sessionRun.next_block_plan.pulse_used || 'none',
        felt_difficulty: quickCheck.felt_difficulty,
        engagement: quickCheck.engagement,
        state_drift: quickCheck.state_drift,
        ts_end: new Date().toISOString()
      };
      const { nextBaseline, nextPlan, note } = computeNextPlansFromBlock(sessionRun, blockLog);
      const nextIndex = sessionRun.next_block_index + 1;
      setSessionRun((prev) => ({
        ...prev,
        baseline_plan: nextBaseline,
        next_block_plan: nextPlan,
        next_block_index: nextIndex,
        blocks: [...prev.blocks, blockLog],
        coach_note: note
      }));
      setScreen(nextIndex > 10 ? 'session_summary' : 'during_session');
    };

    const launchExternalGame = () => {
      const handoff = {
        localDate: new Date().toISOString().slice(0, 10),
        timestamp: Date.now(),
        gameId: selectedGame,
        gameLabel: selectedGameObj.label,
        planType: recommendationV11.recommended_session_type,
        recommended_session_type: recommendationV11.recommended_session_type,
        zoneMode,
        settings: {
          speedPreset,
          interferencePreset
        },
        breathing: {
          routineId: breathRoutine,
          routineName: BREATH_ROUTINES[breathRoutine].name
        }
      };
      localStorage.setItem(STORAGE.CAPACITY_LAST_GAME, JSON.stringify(handoff));
      alert('Launch i3 Mindware (Adobe AIR), choose "' + selectedGameObj.label + '", run your block(s), then return here.');
      setScreen('results');
    };

    const saveRestDay = () => {
      if ((programV11.consecutive_rest_count || 0) >= 2 && !restConfirm) {
        alert('Reset recommended after 2 consecutive rest logs. Confirm rest again to proceed.');
        return;
      }
      const restEntry = {
        id: uid(),
        ts: new Date().toISOString(),
        entry_type: 'REST',
        is_training: false,
        program_day: programV11.program_session_index,
        reason: restReason || null
      };
      setSessionsV11((prev) => [...prev, restEntry]);
      setProgramV11((prev) => ({
        ...prev,
        calendar_entry_count: (prev.calendar_entry_count || 0) + 1,
        consecutive_rest_count: (prev.consecutive_rest_count || 0) + 1
      }));
      setRestConfirm(false);
      setRestReason('');
    };

    const saveMissionOutcome = () => {
      if (!pendingMission) {
        setScreen('home');
        return;
      }
      const payload = {
        cue_fired: missionOutcome.cue_fired,
        success_met: missionOutcome.success_met,
        blocker: missionOutcome.blocker || 'unsure',
        value_tag: missionOutcome.value_tag || null
      };
      setMissionsV11((prev) =>
        prev.map((m) =>
          m.id === pendingMission.id
            ? { ...m, outcome: payload, outcome_ts: new Date().toISOString() }
            : m
        )
      );
      setMissionOutcome({ cue_fired: 'YES', success_met: 'PARTLY', blocker: '', value_tag: '' });
      setScreen('home');
    };

    const saveGuidedSession = () => {
      if (!sessionRun) return;
      if (!bridgeObs.trim() || !bridgeMove.trim()) {
        alert('Bridge fields are required.');
        return;
      }
      const nTrace = sessionRun.blocks.map((b) => Number(b.level_played));
      const nowIso = new Date().toISOString();
      const derived = nTrace.length >= 2
        ? computeDerivedFromNTrace(
            nTrace.length >= 10 ? nTrace.slice(0, 10) : [...nTrace, ...Array.from({ length: 10 - nTrace.length }, () => nTrace[nTrace.length - 1] || 0)],
            { block_index: Number(pulseBlockIndex), recovery_blocks: parseRecoveryBlocks() }
          )
        : null;
      const recoveryBlocks = parseRecoveryBlocks();
      const dataQuality = sessionRun.blocks.some((b) => b.state_drift === 'lost_thread' && b.felt_difficulty === 'hard')
        ? 'UNCONFIRMED_PLAN'
        : 'OK';
      const anchorLane = programV11.anchor_lane || 'CLASSIC';
      const probeTargetSession = [...trainingSessionsV11].reverse().find((s) => s.game === anchorLane && isEvidenceEligible(s));
      const swapCost = sessionRun.session_style === 'PROBE' && dataQuality === 'OK' && derived && probeTargetSession?.derived
        ? Number((derived.baseline_mean - probeTargetSession.derived.baseline_mean).toFixed(2))
        : null;
      const probePass = sessionRun.session_style === 'PROBE' && dataQuality === 'OK' && swapCost !== null && derived
        ? swapCost >= settingsV11.thresholds.probe_swap_cost_min
          && derived.recovery_delta >= settingsV11.thresholds.probe_recovery_delta_min
          && derived.end_hold_delta >= settingsV11.thresholds.probe_end_hold_min
        : null;
      const recheckTarget = recommendationV11.recheck_target_session_id
        ? trainingSessionsV11.find((s) => s.id === recommendationV11.recheck_target_session_id)
        : null;
      const recheckPass = sessionRun.session_style === 'RECHECK' && recheckTarget && dataQuality === 'OK' && derived
        ? derived.mean_n >= (recheckTarget.derived.mean_n - settingsV11.thresholds.recheck_mean_tolerance)
          && derived.volatility <= ((recheckTarget.derived.volatility ?? 0) + 2)
          && derived.end_hold_delta >= (recheckTarget.derived.end_hold_delta - 1)
        : null;
      const firstPulseBlock = sessionRun.blocks.find((b) => b.pulse_used && b.pulse_used !== 'none');
      const guidedPulseType = firstPulseBlock
        ? (firstPulseBlock.pulse_used === 'speed' ? 'SPEED' : 'INTERFERENCE')
        : null;

      const trainingEntry = {
        id: uid(),
        ts: nowIso,
        entry_type: 'TRAINING',
        is_training: true,
        program_day: (programV11.program_session_index || 0) + 1,
        recommended_session_type: sessionRun.recommended_session_type,
        session_type: sessionRun.session_style,
        ended_early: null,
        recommendation_reason: recommendationV11.recommendation_reason,
        game: sessionRun.game,
        output_gate_mode: selectedGame === 'logic_gated' ? outputGateMode : null,
        zone: {
          load: stateRatings.load,
          drift: stateRatings.drift,
          mismatch: stateRatings.mismatch,
          recommendation: zoneMode === 'reset' ? 'RESET' : (zoneMode === 'light' ? 'LIGHT' : 'FULL')
        },
        plan: {
          baseline: {
            speed: sessionRun.baseline_plan.speed.toUpperCase(),
            interference: sessionRun.baseline_plan.distraction.toUpperCase(),
            mode: sessionRun.baseline_plan.level_mode === 'hold' ? 'FIXED' : 'ADAPTIVE',
            fixed_n: sessionRun.baseline_plan.level_mode === 'hold' ? Number(sessionRun.baseline_plan.hold_at) : null
          },
          pulse: guidedPulseType ? { type: guidedPulseType, block_index: firstPulseBlock.block_index, recovery_blocks: recoveryBlocks } : null,
          end_hold_block: 10
        },
        log: {
          n_trace: nTrace,
          no_response_blocks: [],
          fixed_n_blocks: sessionRun.blocks.filter((b) => b.level_mode === 'hold').map((b) => b.block_index),
          block_done: sessionRun.blocks.map(() => true),
          plan_confirmed: true,
          temptation_pressure: null
        },
        block_logs: sessionRun.blocks,
        derived,
        data_quality: dataQuality,
        probe: {
          probe_radius: recommendationV11.probe_radius,
          probe_target_game: recommendationV11.probe_target_game,
          target_session_id: probeTargetSession ? probeTargetSession.id : null,
          swap_cost: swapCost,
          pass: probePass,
          probe_pending_reason: recommendationV11.probe_pending_reason || null
        },
        recheck: {
          of_session_id: recommendationV11.recheck_target_session_id || null,
          pass: recheckPass
        },
        bridge: {
          what_changed: bridgeObs.trim(),
          how_ill_use_it: bridgeMove.trim()
        }
      };

      setSessionsV11((prev) => [...prev, trainingEntry]);
      setProgramV11((prev) => ({
        ...prev,
        program_day_completed: Math.min(PROGRAM_TARGET, (prev.program_day_completed || 0) + 1),
        program_session_index: Math.min(PROGRAM_TARGET, (prev.program_session_index || 0) + 1),
        calendar_entry_count: (prev.calendar_entry_count || 0) + 1,
        consecutive_rest_count: 0,
        last_probe_game: sessionRun.session_style === 'PROBE' ? (sessionRun.game || prev.last_probe_game) : prev.last_probe_game,
        last_probe_radius: sessionRun.session_style === 'PROBE' ? (recommendationV11.probe_radius || prev.last_probe_radius) : prev.last_probe_radius,
        last_probe_radius_passed: probePass === true ? recommendationV11.probe_radius : prev.last_probe_radius_passed,
        last_passed_probe_signature: probePass === true
          ? buildProbeSignature({
              anchorLane,
              probeGame: sessionRun.game,
              probeRadius: recommendationV11.probe_radius,
              baseline: {
                speed: sessionRun.baseline_plan.speed.toUpperCase(),
                interference: sessionRun.baseline_plan.distraction.toUpperCase(),
                mode: sessionRun.baseline_plan.level_mode === 'hold' ? 'FIXED' : 'ADAPTIVE',
                fixed_n: sessionRun.baseline_plan.level_mode === 'hold' ? Number(sessionRun.baseline_plan.hold_at) : null
              },
              pulseType: guidedPulseType,
              pulseBlockIndex: firstPulseBlock ? firstPulseBlock.block_index : settingsV11.defaults.pulse_block_index,
              recoveryBlocks,
              endHoldBlock: 10,
              targetSessionId: probeTargetSession ? probeTargetSession.id : null,
              timestamp: nowIso
            })
          : prev.last_passed_probe_signature
      }));

      if (missionCue.trim() && missionSignal.trim()) {
        setMissionsV11((prev) => [...prev, {
          id: uid(),
          created_ts: nowIso,
          created_from_session_id: trainingEntry.id,
          cue: missionCue.trim(),
          success_signal: missionSignal.trim(),
          value_tag: missionValueTag || null,
          outcome: null
        }]);
      }

      setSessionRun(null);
      setBridgeObs('');
      setBridgeMove('');
      setMissionCue('');
      setMissionSignal('');
      setMissionValueTag('');
      setScreen('home');
    };

    const completeSession = () => {
      const nTrace = getNTraceOrNull();
      if (!nTrace) {
        alert('Enter all 10 block levels first.');
        return;
      }
      if (!bridgeObs.trim() || !bridgeMove.trim()) {
        alert('Bridge fields are required.');
        return;
      }
      if (sessionType === 'PROBE' && !pulseType) {
        alert('Switch-test sessions need one challenge pulse block.');
        return;
      }

      const nextCompleted = Math.min(PROGRAM_TARGET, (progress.totalSessionsCompleted || 0) + 1);
      const nowIso = new Date().toISOString();
      const next = {
        ...progress,
        totalSessionsCompleted: nextCompleted,
        totalSessionsTarget: PROGRAM_TARGET,
        lastSessionDate: nowIso,
        programCompleted: nextCompleted >= PROGRAM_TARGET,
        programCompletionDate: nextCompleted >= PROGRAM_TARGET ? nowIso : progress.programCompletionDate
      };
      saveProgress(next);
      setProgress(next);

      const recoveryBlocks = parseRecoveryBlocks();
      const derived = computeDerivedFromNTrace(nTrace, { block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks });
      const dataQuality = noResponseBlocks.length ? 'COMPROMISED' : (planConfirmed ? 'OK' : 'UNCONFIRMED_PLAN');
      const anchorLane = programV11.anchor_lane || 'CLASSIC';
      const probeTargetSession = [...trainingSessionsV11].reverse().find((s) => s.game === anchorLane && isEvidenceEligible(s));
      const swapCost = probeTargetSession ? Number((derived.baseline_mean - probeTargetSession.derived.baseline_mean).toFixed(2)) : null;
      const probePass = sessionType === 'PROBE' && dataQuality === 'OK' && swapCost !== null
        ? swapCost >= settingsV11.thresholds.probe_swap_cost_min
          && derived.recovery_delta >= settingsV11.thresholds.probe_recovery_delta_min
          && derived.end_hold_delta >= settingsV11.thresholds.probe_end_hold_min
        : null;

      const recommendedRecheckTarget = recommendationV11.recheck_target_session_id
        ? trainingSessionsV11.find((s) => s.id === recommendationV11.recheck_target_session_id)
        : null;
      const signatureTarget = programV11.last_passed_probe_signature?.target_session_id
        ? trainingSessionsV11.find((s) => s.id === programV11.last_passed_probe_signature.target_session_id)
        : null;
      const sameGamePlanTarget = [...trainingSessionsV11].reverse().find((s) =>
        isEvidenceEligible(s)
        && s.game === (GAME_ENUM[selectedGame] || 'CLASSIC')
        && s.plan?.baseline?.mode === baselineMode
        && s.plan?.baseline?.speed === speedPreset.toUpperCase()
        && s.plan?.baseline?.interference === interferencePreset.toUpperCase()
      );
      const recheckTarget = recommendedRecheckTarget || signatureTarget || sameGamePlanTarget || null;
      const recheckPass = sessionType === 'RECHECK' && recheckTarget && dataQuality === 'OK'
        ? derived.mean_n >= (recheckTarget.derived.mean_n - settingsV11.thresholds.recheck_mean_tolerance)
          && derived.volatility <= ((recheckTarget.derived.volatility ?? 0) + 2)
          && derived.end_hold_delta >= (recheckTarget.derived.end_hold_delta - 1)
        : null;

      const handoff = {
        localDate: nowIso.slice(0, 10),
        timestamp: Date.now(),
        planType: sessionType,
        recommended_session_type: recommendationV11.recommended_session_type,
        session_type: sessionType,
        gameId: selectedGame,
        gameLabel: selectedGameObj.label,
        game_enum: GAME_ENUM[selectedGame] || 'CLASSIC',
        zoneMode,
        settings: {
          speedPreset,
          interferencePreset,
          baselineMode,
          fixedN: baselineMode === 'FIXED' ? Number(fixedN) : null
        },
        pulse: pulseType ? { type: pulseType, block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks } : null,
        bridge: {
          observation: bridgeObs.trim(),
          move: bridgeMove.trim()
        }
      };
      localStorage.setItem(STORAGE.CAPACITY_LAST_SESSION, JSON.stringify(handoff));
      localStorage.setItem(STORAGE.CAPACITY_LAST_GAME, JSON.stringify(handoff));

      const trainingEntry = {
        id: uid(),
        ts: nowIso,
        entry_type: 'TRAINING',
        is_training: true,
        program_day: (programV11.program_session_index || 0) + 1,
        recommended_session_type: recommendationV11.recommended_session_type,
        session_type: sessionType,
        ended_early: null,
        recommendation_reason: recommendationV11.recommendation_reason,
        game: GAME_ENUM[selectedGame] || 'CLASSIC',
        output_gate_mode: selectedGame === 'logic_gated' ? outputGateMode : null,
        zone: {
          load: stateRatings.load,
          drift: stateRatings.drift,
          mismatch: stateRatings.mismatch,
          recommendation: zoneMode === 'reset' ? 'RESET' : (zoneMode === 'light' ? 'LIGHT' : 'FULL')
        },
        plan: {
          baseline: {
            speed: speedPreset.toUpperCase(),
            interference: interferencePreset.toUpperCase(),
            mode: baselineMode,
            fixed_n: baselineMode === 'FIXED' ? Number(fixedN) : null
          },
          pulse: pulseType ? { type: pulseType, block_index: Number(pulseBlockIndex), recovery_blocks: recoveryBlocks } : null,
          end_hold_block: Number(endHoldBlock)
        },
        log: {
          n_trace: nTrace,
          no_response_blocks: noResponseBlocks.slice(),
          fixed_n_blocks: fixedNBlocks.slice(),
          block_done: blockDone.slice(),
          plan_confirmed: Boolean(planConfirmed),
          temptation_pressure: temptationPressure === '' ? null : Number(temptationPressure)
        },
        derived,
        data_quality: dataQuality,
        probe: {
          probe_radius: recommendationV11.probe_radius,
          probe_target_game: recommendationV11.probe_target_game,
          target_session_id: probeTargetSession ? probeTargetSession.id : null,
          swap_cost: swapCost,
          pass: probePass,
          probe_pending_reason: recommendationV11.probe_pending_reason || null
        },
        recheck: {
          of_session_id: recheckTarget ? recheckTarget.id : null,
          pass: recheckPass
        },
        bridge: {
          what_changed: bridgeObs.trim(),
          how_ill_use_it: bridgeMove.trim()
        }
      };
      setSessionsV11((prev) => [...prev, trainingEntry]);
      setProgramV11((prev) => ({
        ...prev,
        program_day_completed: Math.min(PROGRAM_TARGET, (prev.program_day_completed || 0) + 1),
        program_session_index: Math.min(PROGRAM_TARGET, (prev.program_session_index || 0) + 1),
        calendar_entry_count: (prev.calendar_entry_count || 0) + 1,
        consecutive_rest_count: 0,
        last_probe_game: sessionType === 'PROBE' ? ((GAME_ENUM[selectedGame] || 'CLASSIC') || prev.last_probe_game) : prev.last_probe_game,
        last_probe_radius: sessionType === 'PROBE' ? (recommendationV11.probe_radius || prev.last_probe_radius) : prev.last_probe_radius,
        last_probe_radius_passed: probePass === true ? recommendationV11.probe_radius : prev.last_probe_radius_passed,
        last_passed_probe_signature: probePass === true
          ? buildProbeSignature({
              anchorLane,
              probeGame: GAME_ENUM[selectedGame] || 'CLASSIC',
              probeRadius: recommendationV11.probe_radius,
              baseline: {
                speed: speedPreset.toUpperCase(),
                interference: interferencePreset.toUpperCase(),
                mode: baselineMode,
                fixed_n: baselineMode === 'FIXED' ? Number(fixedN) : null
              },
              pulseType: pulseType || null,
              pulseBlockIndex: Number(pulseBlockIndex),
              recoveryBlocks,
              endHoldBlock: Number(endHoldBlock),
              targetSessionId: probeTargetSession ? probeTargetSession.id : null,
              timestamp: nowIso
            })
          : prev.last_passed_probe_signature
      }));

      if (missionCue.trim() && missionSignal.trim()) {
        const missionObj = {
          id: uid(),
          created_ts: nowIso,
          created_from_session_id: trainingEntry.id,
          cue: missionCue.trim(),
          success_signal: missionSignal.trim(),
          value_tag: missionValueTag || null,
          outcome: null
        };
        setMissionsV11((prev) => [...prev, missionObj]);
      }

      setScreen('home');
      setBridgeObs('');
      setBridgeMove('');
      setMissionCue('');
      setMissionSignal('');
      setMissionValueTag('');
      setNTraceInput(Array.from({ length: 10 }, () => ''));
      setBlockDone(Array.from({ length: 10 }, () => false));
      setNoResponseBlocks([]);
      setFixedNBlocks([]);
      setPlanConfirmed(false);
      setTemptationPressure('');
    };

    if (screen === 'during_session' && sessionRun) {
      const p = sessionRun.next_block_plan;
      const currentBlock = Math.min(10, sessionRun.next_block_index);
      const whyText = (() => {
        if (sessionRun.coach_note.includes('Downshift')) {
          return 'Last block looked overloaded, so the coach reduced pressure for the next block.';
        }
        if (sessionRun.coach_note.includes('Pulse eligible')) {
          return 'You were steady for two blocks, so a one-block challenge test is suggested.';
        }
        if (sessionRun.coach_note.includes('Upshift')) {
          return 'The block looked easy and flat, so the coach increased challenge slightly to re-engage.';
        }
        return 'You were steady last block, so we are holding the same settings.';
      })();
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><img className="appIcon" src={APP_ICON} alt="Trident G" /></div>
              <div>
                <p className="title">IQ Capacity Coach v1</p>
                <p className="subtitle">During session coach</p>
              </div>
            </div>
            <span className="chip">Block {Math.min(10, sessionRun.next_block_index)}/10</span>
          </div>
          <main className="content capacityNarrow">
            <section className="card">
              <h1 className="h1">Up next: Block {currentBlock} of 10</h1>
              <p className="p">{sessionRun.coach_note}</p>
            </section>
            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: 0, fontWeight: 900 }}>Settings to use</p>
              <p style={{ marginTop: '8px' }}>
                Level: <b>{p.level_mode === 'hold' ? 'Hold level' : 'Auto (let the game choose)'}</b>
                {p.level_mode === 'hold' ? <> at <b>{p.hold_at}</b></> : null}
              </p>
              <p style={{ marginTop: '4px' }}>Speed: <b>{p.speed === 'fast' ? 'Fast' : 'Baseline'}</b></p>
              <p style={{ marginTop: '4px' }}>Distraction: <b>{p.distraction === 'high' ? 'High' : 'Baseline'}</b></p>
              <p style={{ marginTop: '4px' }}>Challenge test (pulse): <b>{p.pulse_used === 'none' ? 'Off' : p.pulse_used === 'speed' ? 'Speed' : 'Distraction'}</b></p>
              <p style={{ marginTop: '10px', fontSize: '13px', color: '#333333' }}>
                Do this now: Play Block {currentBlock} in the desktop app, then tap Log Block {currentBlock}.
              </p>
              <details style={{ marginTop: '10px' }}>
                <summary style={{ cursor: 'pointer', fontWeight: 900 }}>Why this recommendation?</summary>
                <p style={{ margin: '8px 0 0 0', fontSize: '13px', color: '#333333' }}>{whyText}</p>
                <p style={{ margin: '4px 0 0 0', fontSize: '13px', color: '#333333' }}>
                  Pulses only happen after two steady blocks in a row.
                </p>
              </details>
              <div className="btnRow">
                <button className="btn btnPrimary" onClick={openBlockQuickCheck}>Log Block {currentBlock}</button>
                <button className="btn btnSecondary" onClick={launchExternalGame}>Open external game</button>
              </div>
            </section>
          </main>
        </div>
      );
    }

    if (screen === 'quick_check' && sessionRun) {
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><img className="appIcon" src={APP_ICON} alt="Trident G" /></div>
              <div>
                <p className="title">IQ Capacity Coach v1</p>
                <p className="subtitle">Quick check</p>
              </div>
            </div>
            <span className="chip">Block {Math.min(10, sessionRun.next_block_index)}/10</span>
          </div>
          <main className="content capacityNarrow">
            <section className="card">
              <h1 className="h1">After This Block</h1>
              <p className="p">Fast check: level, difficulty, switched-on feeling, and focus track.</p>
            </section>
            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <label style={{ display: 'block', fontWeight: 900 }}>Level you played</label>
              <input type="number" min="0" max="12" value={quickCheck.level_played} onChange={(e) => setQuickCheck((q) => ({ ...q, level_played: e.target.value }))} style={{ width: '100%', marginTop: '6px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <select value={quickCheck.felt_difficulty} onChange={(e) => setQuickCheck((q) => ({ ...q, felt_difficulty: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="easy">How did it feel? Easy</option>
                  <option value="ok">How did it feel? About right</option>
                  <option value="hard">How did it feel? Too hard</option>
                </select>
                <select value={quickCheck.engagement} onChange={(e) => setQuickCheck((q) => ({ ...q, engagement: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="flat">How switched on did you feel? Flat</option>
                  <option value="ok">How switched on did you feel? OK</option>
                  <option value="locked_in">How switched on did you feel? Fully switched on</option>
                </select>
              </div>
              <div className="btnRow">
                <select value={quickCheck.state_drift} onChange={(e) => setQuickCheck((q) => ({ ...q, state_drift: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="clean">Did your focus stay on track? Steady</option>
                  <option value="slips">Did your focus stay on track? A few slips</option>
                  <option value="lost_thread">Did your focus stay on track? Lost the thread</option>
                </select>
              </div>
              <div className="btnRow">
                <button className="btn btnPrimary" onClick={submitBlockQuickCheck}>Set next block</button>
                <button className="btn btnSecondary" onClick={() => setScreen('during_session')}>Back</button>
              </div>
            </section>
          </main>
        </div>
      );
    }

    if (screen === 'session_summary' && sessionRun) {
      const stableBlocks = sessionRun.blocks.filter(isStableBlock).length;
      const pulseAttempts = sessionRun.blocks.filter((b) => b.pulse_used !== 'none').length;
      const recoveryMoments = sessionRun.blocks.reduce((acc, b, idx, arr) => {
        if (idx === 0) return acc;
        const prevUnstable = !isStableBlock(arr[idx - 1]);
        return prevUnstable && isStableBlock(b) ? acc + 1 : acc;
      }, 0);
      const badge = stableBlocks >= 7 ? 'Stable session' : (recoveryMoments >= 1 ? 'Stable and recovered' : 'Needs consolidation');
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><img className="appIcon" src={APP_ICON} alt="Trident G" /></div>
              <div>
                <p className="title">IQ Capacity Coach v1</p>
                <p className="subtitle">Post-session review</p>
              </div>
            </div>
            <span className="chip">Review</span>
          </div>
          <main className="content capacityNarrow">
            <section className="card">
              <h1 className="h1">{badge}</h1>
              <p className="p">Stability streak: {stableBlocks}/10 stable blocks</p>
              <p className="p" style={{ marginTop: '8px' }}>Recovery moments: {recoveryMoments} | Pulses attempted: {pulseAttempts}</p>
            </section>
            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: 0, fontWeight: 900 }}>Tomorrow start</p>
              <p style={{ marginTop: '8px' }}>
                Level mode: <b>{sessionRun.baseline_plan.level_mode === 'hold' ? `Hold ${sessionRun.baseline_plan.hold_at}` : 'Auto'}</b> | Speed: <b>{sessionRun.baseline_plan.speed}</b> | Distraction: <b>{sessionRun.baseline_plan.distraction}</b>
              </p>
            </section>
            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the game it looked like...</label>
              <input type="text" value={bridgeObs} onChange={(e) => setBridgeObs(e.target.value)} placeholder="One concise observation" style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '12px' }} />
              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the next task I will use it by...</label>
              <input type="text" value={bridgeMove} onChange={(e) => setBridgeMove(e.target.value)} placeholder="One concrete transfer move" style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
              <p style={{ margin: '14px 0 8px 0', fontWeight: 900 }}>Set a tiny cue-fired mission (recommended, optional)</p>
              <p style={{ margin: '0 0 8px 0', fontSize: '13px', color: '#333333' }}>Keep it tiny: one cue, one yes/no success signal.</p>
              <input type="text" value={missionCue} onChange={(e) => setMissionCue(e.target.value)} placeholder="Cue (when/where this should fire)" style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }} />
              <input type="text" value={missionSignal} onChange={(e) => setMissionSignal(e.target.value)} placeholder="Success signal (binary)" style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }} />
              <div className="btnRow">
                <button className="btn btnPrimary" onClick={saveGuidedSession}>Save session</button>
                <button className="btn btnSecondary" onClick={() => setScreen('during_session')}>Back</button>
              </div>
            </section>
          </main>
        </div>
      );
    }

    if (screen === 'results') {
      const bridgeReady = bridgeObs.trim() && bridgeMove.trim();
      const parsed = getNTraceOrNull();
      const derivedPreview = parsed
        ? computeDerivedFromNTrace(parsed, { block_index: Number(pulseBlockIndex), recovery_blocks: parseRecoveryBlocks() })
        : null;
      const badgePreview = sessionType === 'PROBE'
        ? ((derivedPreview && derivedPreview.recovery_delta >= -0.5 && derivedPreview.end_hold_delta >= -1) ? 'Switch test likely passed' : 'Switch test needs another try')
        : (sessionType === 'TIGHTEN'
          ? ((derivedPreview && derivedPreview.volatility <= 4) ? 'More steady today' : 'Still getting steadier')
          : (sessionType === 'RECHECK'
            ? 'Checking if gains still hold'
            : (sessionType === 'RESET' ? 'Protected learning day' : 'Stable and recovered')));
      const steadyLabel = derivedPreview
        ? (derivedPreview.volatility <= 4 ? 'Steady' : 'Up and down today')
        : '';
      const recoveryLabel = derivedPreview
        ? (derivedPreview.recovery_delta >= -0.5 ? 'Recovered quickly' : 'Recovery was slow')
        : '';
      const finishLabel = derivedPreview
        ? (derivedPreview.end_hold_delta >= -1 ? 'Finished strong' : 'Faded by the end')
        : '';
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><img className="appIcon" src={APP_ICON} alt="Trident G" /></div>
              <div>
                <p className="title">IQ Capacity Coach v1</p>
                <p className="subtitle">Session review</p>
              </div>
            </div>
            <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
          </div>

          <main className="content capacityNarrow">
            <section className="card">
              <h1 className="h1">Post-Session Review</h1>
              <p className="p">
                Played: {selectedGameObj.label} | Session style: {firstSession ? 'First session (no style suggested)' : (SESSION_LABELS[sessionType] || 'Build')}
              </p>
              <p className="p" style={{ marginTop: '8px' }}>Outcome badge: {badgePreview}</p>
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 10px 0', fontWeight: 900 }}>Today's settings (you can change these)</p>
              <div className="btnRow" style={{ marginTop: 0 }}>
                <select value={sessionType} onChange={(e) => setSessionType(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  {SESSION_TYPES.map((t) => <option key={t} value={t}>{SESSION_LABELS[t] || t}</option>)}
                </select>
                <select value={baselineMode} onChange={(e) => setBaselineMode(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="ADAPTIVE">Level mode: Auto</option>
                  <option value="FIXED">Level mode: Hold level</option>
                </select>
                {baselineMode === 'FIXED' ? (
                  <input type="number" min="1" max="9" value={fixedN} onChange={(e) => setFixedN(Number(e.target.value || 1))} style={{ width: '88px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                ) : null}
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <select value={speedPreset} onChange={(e) => setSpeedPreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="default">Speed: Default</option>
                  <option value="fast">Speed: Fast</option>
                </select>
                <select value={interferencePreset} onChange={(e) => setInterferencePreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="default">Distraction level: Default</option>
                  <option value="high">Distraction: High</option>
                </select>
                <select value={pulseType} onChange={(e) => setPulseType(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Pulse block: None</option>
                  <option value="SPEED">Pulse block: Faster speed</option>
                  <option value="INTERFERENCE">Pulse block: Higher distraction</option>
                </select>
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <input type="number" min="1" max="10" value={pulseBlockIndex} onChange={(e) => setPulseBlockIndex(Number(e.target.value || 4))} style={{ width: '90px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                <input type="text" value={recoveryBlocksCsv} onChange={(e) => setRecoveryBlocksCsv(e.target.value)} placeholder="Recovery blocks e.g. 5,6" style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
                <input type="number" min="1" max="10" value={endHoldBlock} onChange={(e) => setEndHoldBlock(Number(e.target.value || 10))} style={{ width: '90px', padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }} />
              </div>
              {selectedGame === 'logic_gated' ? (
                <div className="btnRow" style={{ marginTop: '10px' }}>
                  <select value={outputGateMode} onChange={(e) => setOutputGateMode(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                    <option value="OR">Output gate: OR</option>
                    <option value="XOR">Output gate: XOR</option>
                    <option value="AND">Output gate: AND</option>
                  </select>
                </div>
              ) : null}
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 8px 0', fontWeight: 900 }}>10-block level log</p>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(5,minmax(0,1fr))', gap: '8px' }}>
                {nTraceInput.map((v, idx) => (
                  <input
                    key={idx}
                    type="number"
                    min="0"
                    max="9"
                    value={v}
                    onChange={(e) => {
                      const next = nTraceInput.slice();
                      next[idx] = e.target.value;
                      setNTraceInput(next);
                    }}
                    placeholder={'B' + (idx + 1)}
                    style={{ padding: '10px', borderRadius: '10px', border: '1px solid #E0E0E0' }}
                  />
                ))}
              </div>
              <label style={{ display: 'block', marginTop: '10px', fontSize: '13px' }}>
                <input type="checkbox" checked={planConfirmed} onChange={(e) => setPlanConfirmed(e.target.checked)} /> Plan confirmed for this session
              </label>
              <div style={{ display: 'grid', gap: '6px', marginTop: '8px' }}>
                {Array.from({ length: 10 }, (_, i) => (
                  <div key={i} style={{ fontSize: '13px' }}>
                    <b>Block {i + 1}:</b>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={blockDone[i]} onChange={(e) => {
                      const next = blockDone.slice(); next[i] = e.target.checked; setBlockDone(next);
                    }} /> done</label>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={noResponseBlocks.includes(i + 1)} onChange={() => setNoResponseBlocks((p) => toggleBlockTag(p, i + 1))} /> no response</label>
                    <label style={{ marginLeft: '8px' }}><input type="checkbox" checked={fixedNBlocks.includes(i + 1)} onChange={() => setFixedNBlocks((p) => toggleBlockTag(p, i + 1))} /> fixed n</label>
                  </div>
                ))}
              </div>
              <div className="btnRow" style={{ marginTop: '10px' }}>
                <select value={temptationPressure} onChange={(e) => setTemptationPressure(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Temptation pressure: not logged</option>
                  <option value="0">Temptation pressure: 0</option>
                  <option value="1">Temptation pressure: 1</option>
                  <option value="2">Temptation pressure: 2</option>
                  <option value="3">Temptation pressure: 3</option>
                </select>
              </div>
              {derivedPreview ? (
                <div style={{ marginTop: '10px', fontSize: '13px', color: '#333333' }}>
                  <p style={{ margin: 0 }}>{steadyLabel} | {recoveryLabel} | {finishLabel}</p>
                  <details style={{ marginTop: '6px' }}>
                    <summary>Details</summary>
                    <p style={{ margin: '6px 0 0 0' }}>
                      Average level {derivedPreview.mean_n} | Level changes {derivedPreview.volatility} | End strength {derivedPreview.end_hold_delta} | Recovery shift {derivedPreview.recovery_delta}
                    </p>
                  </details>
                </div>
              ) : null}
            </section>

            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the game it looked like...</label>
              <input
                type="text"
                value={bridgeObs}
                onChange={(e) => setBridgeObs(e.target.value)}
                placeholder="One concise observation"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '12px' }}
              />

              <label style={{ display: 'block', fontWeight: 900, marginBottom: '8px' }}>In the next task I will use it by...</label>
              <input
                type="text"
                value={bridgeMove}
                onChange={(e) => setBridgeMove(e.target.value)}
                placeholder="One concrete transfer move"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0' }}
              />

              <p style={{ margin: '14px 0 8px 0', fontWeight: 900 }}>Set a tiny cue-fired mission (recommended, optional)</p>
              <p style={{ margin: '0 0 8px 0', fontSize: '13px', color: '#333333' }}>Keep it tiny: one cue, one yes/no success signal.</p>
              <input
                type="text"
                value={missionCue}
                onChange={(e) => setMissionCue(e.target.value)}
                placeholder="Cue (when/where this should fire)"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }}
              />
              <input
                type="text"
                value={missionSignal}
                onChange={(e) => setMissionSignal(e.target.value)}
                placeholder="Success signal (binary)"
                style={{ width: '100%', padding: '12px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }}
              />
              <select
                value={missionValueTag}
                onChange={(e) => setMissionValueTag(e.target.value)}
                style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '8px' }}
              >
                <option value="">Value tag (optional)</option>
                {VALUE_TAGS.map((v) => (
                  <option key={v} value={v}>{v}</option>
                ))}
              </select>

              <div className="btnRow">
                <button className="btn btnPrimary" onClick={completeSession} disabled={!bridgeReady}>
                  Complete session ({Math.min(PROGRAM_TARGET, progress.totalSessionsCompleted + 1)}/{PROGRAM_TARGET})
                </button>
                <button className="btn btnSecondary" onClick={() => setScreen('home')}>Back</button>
              </div>
            </section>
          </main>
        </div>
      );
    }

    if (screen === 'mission_outcome') {
      return (
        <div className="screen">
          <div className="topbar">
            <div className="brandleft">
              <div className="icon"><img className="appIcon" src={APP_ICON} alt="Trident G" /></div>
              <div>
                <p className="title">IQ Capacity Coach v1</p>
                <p className="subtitle">Mission check-in</p>
              </div>
            </div>
            <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
          </div>
          <main className="content capacityNarrow">
            <section className="card">
              <h1 className="h1">Mission Check-In</h1>
              <p className="p">This helps the app suggest the right kind of session next time.</p>
            </section>
            {!pendingMission ? (
              <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
                <p style={{ margin: '0 0 10px 0' }}>You don't have a mission to check in on yet.</p>
                <div className="btnRow">
                  <button className="btn btnPrimary" onClick={() => setScreen('home')}>Back to Home</button>
                </div>
              </section>
            ) : (
            <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
              <p style={{ margin: '0 0 6px 0', fontWeight: 900 }}>Your cue</p>
              <p style={{ margin: '0 0 10px 0' }}>{pendingMission?.cue || '-'}</p>
              <p style={{ margin: '0 0 6px 0', fontWeight: 900 }}>Your success signal</p>
              <p style={{ margin: '0 0 10px 0' }}>{pendingMission?.success_signal || '-'}</p>
              <div className="btnRow" style={{ marginTop: 0 }}>
                <select value={missionOutcome.cue_fired} onChange={(e) => setMissionOutcome((p) => ({ ...p, cue_fired: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="YES">Did your cue happen? Yes</option>
                  <option value="NO">Did your cue happen? No</option>
                </select>
                <select value={missionOutcome.success_met} onChange={(e) => setMissionOutcome((p) => ({ ...p, success_met: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="YES">Did you complete it? Yes</option>
                  <option value="PARTLY">Did you complete it? Partly</option>
                  <option value="NO">Did you complete it? No</option>
                </select>
              </div>
              <div className="btnRow">
                <select value={missionOutcome.blocker} onChange={(e) => setMissionOutcome((p) => ({ ...p, blocker: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">What mainly got in the way? (Optional)</option>
                  <option value="state">State (hot/scattered/flat)</option>
                  <option value="capacity">Training (could not hold the rule)</option>
                  <option value="context">Time and context</option>
                  <option value="unsure">Not sure</option>
                </select>
                <select value={missionOutcome.value_tag} onChange={(e) => setMissionOutcome((p) => ({ ...p, value_tag: e.target.value }))} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                  <option value="">Value tag: none</option>
                  {VALUE_TAGS.map((v) => (
                    <option key={v} value={v}>{v}</option>
                  ))}
                </select>
              </div>
              <div className="btnRow">
                <button className="btn btnPrimary" onClick={saveMissionOutcome}>Save check-in</button>
                <button className="btn btnSecondary" onClick={() => setScreen('home')}>Back</button>
              </div>
            </section>
            )}
          </main>
        </div>
      );
    }

    return (
      <div className="screen">
        <div className="topbar">
          <div className="brandleft">
            <div className="icon"><img className="appIcon" src={APP_ICON} alt="Trident G" /></div>
            <div>
              <p className="title">IQ Capacity Coach v1</p>
              <p className="subtitle">i3 Mindware session coordinator</p>
            </div>
          </div>
          <span className="chip">{progress.totalSessionsCompleted}/{PROGRAM_TARGET}</span>
        </div>

        <main className="content capacityNarrow">
          <section className="card">
            <h1 className="h1">Training Program</h1>
            <p className="p">24 sessions total. No anchor wheel. Choose any of the 4 n-back variants each session.</p>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Progress</p>
            <p style={{ marginTop: '8px' }}>{programV11.program_session_index}/{PROGRAM_TARGET} complete | {sessionsRemaining} remaining</p>
            <p style={{ marginTop: '6px', fontSize: '13px', color: '#555555' }}>
              Calendar entries: {programV11.calendar_entry_count} | Consecutive rests: {programV11.consecutive_rest_count}
            </p>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>Today's suggestion</p>
            {firstSession ? (
              <p style={{ marginTop: '8px' }}>
                First session: no session style is suggested yet. Start simple with <b>Classic n-back</b>.
              </p>
            ) : (
              <p style={{ marginTop: '8px' }}>
                Session style: <b>{SESSION_LABELS[recommendationV11.recommended_session_type] || 'Build'}</b> | Game: <b>{GAME_LABEL[GAME_ID_FROM_ENUM[recommendationV11.recommended_game]] || recommendationV11.recommended_game}</b>
              </p>
            )}
            <p style={{ marginTop: '4px', fontSize: '13px', color: '#555555' }}>{recommendationV11.recommendation_reason}</p>
            {recommendationV11.probe_radius ? (
              <p style={{ marginTop: '4px', fontSize: '13px', color: '#555555' }}>
                Switch test: {SWITCH_SIZE_LABELS[recommendationV11.probe_radius] || recommendationV11.probe_radius} | Target game: {recommendationV11.probe_target_game}
              </p>
            ) : null}
            {pendingMission ? (
              <p style={{ marginTop: '8px', fontSize: '13px', color: '#2764B7', fontWeight: 700 }}>
                You have a mission to check in on before your next session.
              </p>
            ) : null}
            <div className="btnRow">
              {pendingMission ? (
                <button
                  className="btn"
                  style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }}
                  onClick={() => setScreen('mission_outcome')}
                >
                  Mission check-in
                </button>
              ) : null}
            </div>
            {programV11.consecutive_rest_count >= 2 ? (
              <div style={{ marginTop: '10px' }}>
                <p style={{ margin: 0, color: '#9a5b00', fontWeight: 700 }}>
                  Reset day recommended: 2 or more rest days in a row.
                </p>
                <label style={{ display: 'block', marginTop: '6px', fontSize: '13px' }}>
                  <input type="checkbox" checked={restConfirm} onChange={(e) => setRestConfirm(e.target.checked)} /> Confirm another rest day
                </label>
                <input
                  type="text"
                  value={restReason}
                  onChange={(e) => setRestReason(e.target.value)}
                  placeholder="Optional reason"
                  style={{ marginTop: '6px' }}
                />
              </div>
            ) : null}
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>1) Quick readiness check</p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#333333' }}>
              Quick self-check before training. These are simple readiness sliders.
            </p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#555555' }}>
              Use these to choose full, light, or rest for today.
            </p>
            {[
              ['load', 'How overloaded do you feel?'],
              ['drift', 'How steady is your focus today?'],
              ['mismatch', 'Does today\'s plan feel doable?']
            ].map(([k, label]) => (
              <div key={k} style={{ marginBottom: '10px' }}>
                <label style={{ fontWeight: 700 }}>{label}: {stateRatings[k]}</label>
                <input
                  type="range"
                  min="0"
                  max="10"
                  value={stateRatings[k]}
                  onChange={(e) => setStateRatings((prev) => ({ ...prev, [k]: Number(e.target.value) }))}
                  style={{ width: '100%' }}
                />
                <p style={{ margin: '2px 0 0 0', fontSize: '12px', color: '#777777' }}>Low &lt;-&gt; High</p>
              </div>
            ))}
            <div className="btnRow" style={{ marginTop: 8 }}>
              <button className="btn" style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }} onClick={estimateZoneFromRatings}>
                Auto-suggest readiness
              </button>
            </div>
            {lastStateReason ? (
              <p style={{ margin: '8px 0 0 0', fontSize: '13px', color: '#333333' }}>
                {lastStateReason}
              </p>
            ) : null}
            <div className="btnRow">
              {[
                { id: 'in_band', label: 'Full session (10 blocks, normal plan)', action: 'zone' },
                { id: 'light', label: 'Light session (10 blocks, easier settings, no challenge tests)', action: 'zone' },
                { id: 'rest', label: 'Rest day (no blocks today, optional 90-second reset)', action: 'rest' }
              ].map((z) => (
                <button
                  key={z.id}
                  className="btn"
                  onClick={() => {
                    if (z.action === 'rest') {
                      saveRestDay();
                      return;
                    }
                    setZoneMode(z.id);
                    setPlanType(computePlanType(z.id));
                  }}
                  style={{
                    background: zoneMode === z.id && z.action === 'zone' ? '#E8F4FF' : '#FFFFFF',
                    border: '1px solid ' + (zoneMode === z.id && z.action === 'zone' ? '#2764B7' : '#E0E0E0'),
                    color: '#111111'
                  }}
                >
                  {z.label}
                </button>
              ))}
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>2) Optional: 90-second reset</p>
            <p style={{ margin: '0 0 10px 0', fontSize: '13px', color: '#333333' }}>
              Simplified from Zone Coach (no HR capture).
            </p>
            <select
              value={breathRoutine}
              onChange={(e) => setBreathRoutine(e.target.value)}
              style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0', marginBottom: '10px' }}
            >
              <option value="upshift">Upshift</option>
              <option value="amplify">Amplify</option>
              <option value="downshift">Downshift</option>
            </select>
            <p style={{ margin: '0 0 4px 0', fontWeight: 700 }}>{BREATH_ROUTINES[breathRoutine].name}</p>
            <p style={{ margin: '0 0 4px 0', fontSize: '13px' }}>{BREATH_ROUTINES[breathRoutine].description}</p>
            <p style={{ margin: 0, fontSize: '13px', color: '#555555' }}>{BREATH_ROUTINES[breathRoutine].cue}</p>
            <div style={{ display: 'flex', justifyContent: 'center', marginTop: '10px' }}>
              <svg width="220" height="220" viewBox="0 0 220 220">
                <circle cx="110" cy="110" r="88" fill="none" stroke="rgba(39,100,183,0.20)" strokeWidth="8" />
                <circle
                  cx="110"
                  cy="110"
                  r={54 + (42 * (breathPhaseKind === 'inhale' ? breathPhaseProgress : (1 - breathPhaseProgress)))}
                  fill="none"
                  stroke="var(--deep)"
                  strokeWidth="10"
                  strokeOpacity="0.9"
                />
                <text x="110" y="115" textAnchor="middle" fontSize="18" fontWeight="900" fill="#143a73">
                  {breathPhaseLabel}
                </text>
              </svg>
            </div>
            <div className="btnRow">
              <button
                className="btn"
                style={{ background: '#FFFFFF', border: '1px solid #2764B7', color: '#2764B7' }}
                onClick={() => {
                  setBreathRemaining(90);
                  setBreathPhaseLabel('Ready');
                  setBreathPhaseProgress(0);
                  setBreathRunning(true);
                }}
              >
                Start 90s routine
              </button>
              {breathRunning ? (
                <button
                  className="btn"
                  style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', color: '#333333' }}
                  onClick={() => {
                    setBreathRunning(false);
                    setBreathRemaining(0);
                    setBreathPhaseLabel('Stopped');
                    setBreathPhaseProgress(0);
                  }}
                >
                  Stop
                </button>
              ) : null}
            </div>
            {breathRunning ? (
              <p style={{ margin: '8px 0 0 0', fontWeight: 900 }}>
                {Math.max(0, breathRemaining)}s remaining
              </p>
            ) : null}
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>Baseline settings</p>
            <div className="btnRow">
              <select value={speedPreset} onChange={(e) => setSpeedPreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                <option value="default">Speed: Baseline</option>
                <option value="fast">Speed: Fast</option>
              </select>
              <select value={interferencePreset} onChange={(e) => setInterferencePreset(e.target.value)} style={{ padding: '10px', borderRadius: '12px', border: '1px solid #E0E0E0' }}>
                <option value="default">Distraction: Baseline</option>
                <option value="high">Distraction: High</option>
              </select>
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: '0 0 12px 0', fontWeight: 900 }}>3) Choose today's i3 Mindware game</p>
            <div style={{ display: 'grid', gap: '10px' }}>
              {GAMES.map((g) => (
                <button
                  key={g.id}
                  className="btn"
                  onClick={() => setSelectedGame(g.id)}
                  style={{
                    width: '100%',
                    textAlign: 'left',
                    background: selectedGame === g.id ? '#E8F4FF' : '#FFFFFF',
                    border: '1px solid ' + (selectedGame === g.id ? '#2764B7' : '#E0E0E0'),
                    color: '#111111'
                  }}
                >
                  <div style={{ fontWeight: 900 }}>{g.label}{g.id === 'classic' ? ' (Suggested start)' : ''}</div>
                  <div style={{ fontSize: '13px', marginTop: '6px', opacity: 0.85 }}>{g.note}</div>
                </button>
              ))}
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <p style={{ margin: 0, fontWeight: 900 }}>4) Start session</p>
            <p style={{ marginTop: '6px', fontSize: '13px', color: '#555555' }}>Plan: {planLabel}</p>
            <p style={{ marginTop: '8px' }}>Use the coach between each block. It tells you the next block settings based on your quick check.</p>
            <div className="btnRow">
              <button className="btn btnPrimary" onClick={startGuidedSession}>Start guided session</button>
              <button className="btn btnSecondary" onClick={() => setScreen('results')}>Use post-session entry instead</button>
            </div>
          </section>

          <section style={{ background: '#FFFFFF', border: '1px solid #E0E0E0', borderRadius: '16px', padding: '16px' }}>
            <details>
              <summary style={{ cursor: 'pointer', fontWeight: 900 }}>View progress checks</summary>
              <p style={{ marginTop: '8px' }}>
                Transfer checks: Small <b>{proofCounters.near ? 'passed' : 'not yet'}</b> | Medium <b>{proofCounters.mid ? 'passed' : 'not yet'}</b> | Big <b>{proofCounters.far ? 'passed' : 'not yet'}</b>
              </p>
              <p style={{ marginTop: '6px' }}>
                Still holds later: <b>{proofCounters.delay_holds > 0 ? proofCounters.delay_holds : 'not checked yet'}</b> | Real-life cue wins: <b>{proofCounters.mission_successes > 0 ? proofCounters.mission_successes : 'not logged yet'}</b>
              </p>
              <p style={{ marginTop: '6px' }}>
                Steady sessions in a row: <b>{proofCounters.stability_streak}</b>
              </p>
              {notCountedNote ? (
                <p style={{ marginTop: '8px', fontSize: '13px', color: '#555555' }}>{notCountedNote}</p>
              ) : null}
            </details>
          </section>
        </main>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>
</body>
</html>


