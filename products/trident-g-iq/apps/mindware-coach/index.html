<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IQ Mindware Coach v1</title>
  <link rel="stylesheet" href="../../../../branding/brand.css">
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
    .mindwareNarrow { width: clamp(340px, 34vw, 640px); margin: 0 auto; }
    @media (max-width: 980px) { .mindwareNarrow { width: 100%; } }
    .appIcon { width: 28px; height: 28px; object-fit: contain; display: block; margin: 0 auto; }
    .field { width: 100%; padding: 10px; border-radius: 12px; border: 1px solid #E0E0E0; }
    .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .optBtn { width: 100%; text-align: left; background: #FFFFFF; border: 1px solid #E0E0E0; color: #111; }
    .hint { margin: 6px 0 0 0; font-size: 13px; color: #555; }
    .timer { font-weight: 900; color: #143a73; }
    .plainLink { padding: 0; border: none; background: none; color: #143a73; cursor: pointer; font: inherit; }
  </style>
</head>
<body>
  <div id="root"></div>
<script type="text/babel" data-presets="env,react">
  const { useEffect, useMemo, useState } = React;
  const APP_ICON = "../../../../branding/Trident-G-Icon.svg";
  const APP_NAME = "IQ Mindware Coach v1";
  const BUILD_ID = "2026-02-15.2";

  const LS = {
    SHARED: "tg_shared_state_v1",
    STATE: "tg_mindware_state_v1",
    EVENTS: "tg_mindware_events_v1",
    CACHE: "tg_mindware_content_cache_v1"
  };
  const COPY = {
    home_help_strip: {
      title: "How this helps",
      lines: [
        "You're building mindware scripts: short, repeatable thinking steps you can run under pressure.",
        "You practise one here, then deploy it on a real work task and prove it carries over - even when you're busy, interrupted, or using AI."
      ],
      links: { learn_more: "Learn more >" }
    },
    how_it_works_modal: {
      title: "How it works",
      sections: [
        {
          title: "The point of this app",
          body: "Learn a compact IQ algebra for real-world thinking: a small set of reliable scripts for decisions, problem-solving, and judgement.\n\nThis isn't tips or motivation. It's train -> test -> use -> re-check, so scripts don't just feel good in practice, they hold up in real work, including AI-assisted workflows."
        },
        {
          title: "What is a thinking step?",
          body: "A thinking step is one repeatable move in your reasoning, for example:\n\nPick the one check that would change your next action.\n\nDefine what done looks like before you start.\n\nName the key assumption, then test it."
        },
        {
          title: "The Mindware Loop",
          list: [
            "Teach: what the script is for and when to use it",
            "Worked example: see it applied once, without time pressure",
            "Timed practice: practise until it's fast and reliable",
            "Quick repair (optional): fix a repeating error or bottleneck",
            "Change test (optional): does it still work when the context changes? (change test -> context change)",
            "Real-life mission: run it once on a real task with a clear success signal",
            "Save: keep a short version you can reuse next time, with a cue to trigger it"
          ]
        },
        {
          title: "Why try it in real life?",
          body: "Practice makes a script familiar. A real task makes it reliable. Missions are how you prove a script still works when you are interrupted, under pressure, or leaning on AI suggestions."
        }
      ],
      footer_small: "This is skills training, not medical treatment. No guaranteed outcomes. If you're concerned about health or mental health, speak to your GP."
    },
    start_session: {
      why_line: "Why: Practice makes it familiar. Real tasks make it reliable."
    },
    mission_bridge_banner: {
      no_mission: "After this session: set one small work task (5-15 minutes) to try this script once.",
      pending_title: "Mission pending",
      pending_body: "Log what happened before your next session (recommended).",
      buttons: { log_outcome: "Log outcome", skip_for_now: "Skip for now" }
    }
  };
  const FRAME_LABEL = { understand: "Understand", argue: "Argue", decide: "Decide", plan_do: "Plan & Do" };
  const FRAMES = Object.keys(FRAME_LABEL);
  const SCRIPTS = ["Y0","Y1","Y2","Y3","Y4","Y5","Y6","Y7","Y8","Y9","Y10"];
  const GYM_FAMILY_LABEL = {
    invalid_conditional: "If-then logic",
    no_counterexample: "Find the counterexample",
    base_rate_ignored: "Base rates",
    correlation_not_cause: "Cause vs coincidence",
    surface_over_structure: "Structure vs surface"
  };
  const GYM_FAMILY_DEF = {
    invalid_conditional: "Stops conclusions that do not follow.",
    no_counterexample: "Stops you believing a rule with an obvious exception.",
    base_rate_ignored: "Stops you overreacting to one case.",
    correlation_not_cause: "Stops you treating patterns as causes.",
    surface_over_structure: "Stops shallow similarities fooling you."
  };
  const OPERATOR_GLOSSARY = {
    Y0: [
      ["Commit or park", "Decide to do it now, or schedule it for later on purpose."],
      ["Timebox", "A fixed amount of time you agree to stop at."],
      ["Good enough", "A clear minimum result that is enough to move forward."]
    ],
    Y1: [
      ["Discriminating check", "A quick test that tells options apart."],
      ["Flip rule", "What result would make you change your next step."]
    ],
    Y2: [
      ["Trade-off", "Choosing between options where each has pros and cons."],
      ["Criteria", "The few things that matter most for this choice."],
      ["Flip check", "The uncertainty that could change the winner."]
    ],
    Y3: [
      ["Value x chance", "Rough benefit multiplied by rough likelihood."],
      ["Ballpark estimate", "A rough number that is good enough to decide."],
      ["Driver estimate", "The single estimate most likely to flip your choice."]
    ],
    Y4: [
      ["Claim", "The main point being argued."],
      ["Support", "Evidence or reasons used for the claim."],
      ["Link", "Why the support actually backs the claim."]
    ],
    Y5: [
      ["Mechanism", "How one thing causes another step by step."],
      ["Cause chain", "Driver -> intermediate steps -> outcome."],
      ["Alternative cause", "Another explanation that could also fit the result."]
    ],
    Y6: [
      ["Bottleneck", "The main constraint limiting progress right now."],
      ["Constraint relief", "A specific action that loosens that limit."],
      ["Shift check", "Verify whether the bottleneck actually moved."]
    ],
    Y7: [
      ["Success signal", "One observable sign you can track."],
      ["Measurable goal", "A goal stated so progress can be seen."],
      ["Stop rule", "A clear point where you stop or switch."]
    ],
    Y8: [
      ["Minimum useful model", "The simplest model that still supports a good next move."],
      ["Hard constraint", "A limit you cannot ignore, like time or budget."],
      ["Flip uncertainty", "The unknown that could change your plan."]
    ],
    Y9: [
      ["Time-boxed trial", "A test with a fixed start and end."],
      ["Metric", "The one number or signal you use to judge the trial."],
      ["Keep or switch rule", "A pre-set rule for what you do after results."]
    ],
    Y10: [
      ["Evidence update", "Adjust confidence to match what new evidence supports."],
      ["Proportional update", "Strong evidence changes confidence more than weak evidence."],
      ["Plan change", "A concrete behavior change based on the update."]
    ]
  };
  const TIMED_PACKS = [
    "./content/packs/core_v1.json",
    "./content/packs/reasoning_gym_v1.json",
    "./content/packs/logic_injections_v1.json"
  ];
  const LESSON_PACK = "./content/packs/lessons_v1.json";
  const MANIFEST_PACK = "./content/packs/manifest_v1.json";
  const TIMEBOX_TO_ITEMS = { 2: 5, 4: 8, 6: 12, 8: 16 };
  const REQUIRED = ["id","context","frame","wrapper","script","polarity","lens_target","kind","is_boundary","near_miss_tag","prompt","options","answer_index","why_right"];

  const parse = (raw, fb) => { try { return JSON.parse(raw); } catch { return fb; } };
  const asObj = (v) => (v && typeof v === "object" && !Array.isArray(v) ? v : {});
  const uid = () => "mw_" + Math.random().toString(36).slice(2, 10) + "_" + Date.now().toString(36);
  const nowIso = () => new Date().toISOString();
  const save = (k, v) => localStorage.setItem(k, JSON.stringify(v));
  const prettyContext = (v) => String(v || "").charAt(0).toUpperCase() + String(v || "").slice(1);
  const stripPromptTags = (prompt) => String(prompt || "").replace(/^(\[[^\]]+\]\s*)+/, "").trim();
  const gymFamilyLabel = (tag) => GYM_FAMILY_LABEL[tag] || GYM_FAMILY_LABEL.surface_over_structure;
  const gymFamilyDef = (tag) => GYM_FAMILY_DEF[tag] || GYM_FAMILY_DEF.surface_over_structure;
  const localDateKey = (d = new Date()) => {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  };

  const defaultShared = () => ({
    schema_version: "tg_shared_state_v1",
    today: {
      date_local: localDateKey(),
      readiness: "full",
      data_quality: "ok",
      capacity: { sessions_completed: 0 },
      mindware: { sessions_completed: 0, last_session_ts: null, missions_pending: 0 }
    },
    last: { mindware_session: { summary: null } }
  });
  const defaultState = () => ({
    schema_version: "tg_mindware_state_v1",
    defaults: { frame: "understand", script: "Y1", rigour: "standard", timebox_min: 4 },
    scripts: {},
    ui: { home_help_dismissed: false, how_it_works_last_opened_ts: null },
    operator_intro: {},
    seen_items: {},
    missions: [],
    probe: {
      next_distance: "near",
      pending_probe: null,
      pending_recheck: null,
      last_passed_probe_signature: null,
      next_microset_tag: null,
      next_microset_source_session_id: null
    }
  });
  const loadShared = () => {
    const raw = asObj(parse(localStorage.getItem(LS.SHARED), {}));
    const d = defaultShared();
    const todayKey = localDateKey();
    const rawToday = asObj(raw.today);
    const today = rawToday.date_local === todayKey
      ? {
        ...d.today,
        ...rawToday,
        capacity: { ...d.today.capacity, ...asObj(rawToday.capacity) },
        mindware: { ...d.today.mindware, ...asObj(rawToday.mindware) },
        date_local: todayKey
      }
      : {
        ...d.today,
        date_local: todayKey
      };
    return {
      ...d,
      ...raw,
      today,
      last: { ...d.last, ...asObj(raw.last), mindware_session: { summary: raw.last?.mindware_session?.summary || null } }
    };
  };
  const loadState = () => {
    const raw = asObj(parse(localStorage.getItem(LS.STATE), {}));
    const d = defaultState();
    return {
      ...d,
      ...raw,
      defaults: { ...d.defaults, ...asObj(raw.defaults) },
      scripts: asObj(raw.scripts),
      ui: { ...d.ui, ...asObj(raw.ui) },
      operator_intro: asObj(raw.operator_intro),
      seen_items: asObj(raw.seen_items),
      missions: Array.isArray(raw.missions) ? raw.missions : [],
      probe: { ...d.probe, ...asObj(raw.probe) }
    };
  };

  function App() {
    const [screen, setScreen] = useState("splash");
    const [shared, setShared] = useState(() => loadShared());
    const [mwState, setMwState] = useState(() => loadState());
    const [events, setEvents] = useState(() => (Array.isArray(parse(localStorage.getItem(LS.EVENTS), [])) ? parse(localStorage.getItem(LS.EVENTS), []) : []));
    const [timedPacks, setTimedPacks] = useState([]);
    const [lessonsPack, setLessonsPack] = useState(null);
    const [packError, setPackError] = useState("");
    const [loadingPacks, setLoadingPacks] = useState(true);
    const [timerSec, setTimerSec] = useState(0);
    const [plan, setPlan] = useState(() => ({
      mode: "practice",
      frame: mwState.defaults.frame,
      script: mwState.defaults.script,
      rigour: mwState.defaults.rigour,
      timebox_min: mwState.defaults.timebox_min
    }));
    const [session, setSession] = useState(null);
    const [lessonRun, setLessonRun] = useState(null);
    const [guidedFeedback, setGuidedFeedback] = useState(null);
    const [lessonModalScript, setLessonModalScript] = useState(null);
    const [showHowItWorks, setShowHowItWorks] = useState(false);
    const [missionDraft, setMissionDraft] = useState({ cue: "", success_signal: "", stop_flip_rule: "", value_tag: "" });
    const [missionOutcome, setMissionOutcome] = useState({ cue_fired: "YES", success_met: "PARTLY", blocker: "", improved: "", note: "" });

    const pendingMission = useMemo(() => mwState.missions.find((m) => m.status === "pending") || null, [mwState.missions]);
    const pendingMissionCount = useMemo(() => mwState.missions.filter((m) => m.status === "pending").length, [mwState.missions]);
    const allItems = useMemo(() => timedPacks.flatMap((p) => p.items || []), [timedPacks]);
    const getLessonByScript = (script) => (lessonsPack?.operators || []).find((op) => op.script === script) || null;
    const getGuidedItemByScript = (script) => {
      const lesson = getLessonByScript(script);
      if (!lesson) return null;
      return (lessonsPack?.items || []).find((it) => it.id === lesson.guided_item_id) || null;
    };
    const getOperatorIntro = (script) => asObj(mwState.operator_intro?.[script]);
    const needsTeach = (script) => {
      const intro = getOperatorIntro(script);
      const lesson = getLessonByScript(script);
      const targetVersion = Number(lesson?.operator_version || lessonsPack?.version || 1);
      if (intro.seen !== true) return true;
      const seenVersion = Number(intro.operator_version || intro.lesson_version || 0);
      return seenVersion !== targetVersion;
    };
    const scriptTitle = (script) => {
      const lesson = getLessonByScript(script);
      return lesson?.display_name || lesson?.title || "Script";
    };
    const scriptOneLiner = (script) => {
      const lesson = getLessonByScript(script);
      return lesson?.display_subtitle || lesson?.one_liner || "";
    };
    const needsRefresher = (script) => {
      if (!lessonsPack || needsTeach(script)) return false;
      const intro = getOperatorIntro(script);
      const seenTs = intro.seen_ts ? new Date(intro.seen_ts).getTime() : 0;
      const stale = !seenTs || (Date.now() - seenTs) > (14 * 24 * 60 * 60 * 1000);
      const recent = Array.isArray(mwState.scripts?.[script]?.recent_accuracy) ? mwState.scripts[script].recent_accuracy : [];
      const low = recent.length >= 3 && recent.slice(-3).every((x) => Number(x) < 0.6);
      return stale || low;
    };
    const markIntroSeen = (script) => {
      const lesson = getLessonByScript(script);
      const targetVersion = Number(lesson?.operator_version || lessonsPack?.version || 1);
      setMwState((prev) => ({
        ...prev,
        operator_intro: {
          ...prev.operator_intro,
          [script]: {
            seen: true,
            seen_ts: nowIso(),
            operator_version: targetVersion,
            lesson_version: Number(lessonsPack?.version || 1)
          }
        }
      }));
    };

    useEffect(() => save(LS.STATE, mwState), [mwState]);
    useEffect(() => save(LS.SHARED, shared), [shared]);
    useEffect(() => save(LS.EVENTS, events.slice(-800)), [events]);
    useEffect(() => {
      // Do not persist a forced Gym suggestion across reloads.
      setMwState((prev) => {
        if (!prev.probe?.next_microset_tag) return prev;
        return {
          ...prev,
          probe: {
            ...prev.probe,
            next_microset_tag: null,
            next_microset_source_session_id: null
          }
        };
      });
    }, []);

    useEffect(() => {
      let cancelled = false;
      const load = async () => {
        setLoadingPacks(true);
        const cache = asObj(parse(localStorage.getItem(LS.CACHE), {}));
        const loaded = [];
        const ids = new Set();
        try {
          let timedUrls = [...TIMED_PACKS];
          let lessonUrl = LESSON_PACK;
          try {
            const manifestRes = await fetch(MANIFEST_PACK, { cache: "no-store" });
            if (manifestRes.ok) {
              const manifest = await manifestRes.json();
              const packs = Array.isArray(manifest?.packs) ? manifest.packs : [];
              const timed = packs.filter((p) => p?.type === "timed" || p?.id === "core_v1" || p?.id === "reasoning_gym_v1" || p?.id === "logic_injections_v1");
              const lessons = packs.find((p) => p?.type === "lessons" || p?.id === "lessons_v1");
              if (timed.length) timedUrls = timed.map((p) => p.path);
              if (lessons?.path) lessonUrl = lessons.path;
            }
          } catch (manifestErr) {
            console.warn("Mindware manifest not loaded; using default pack paths.", manifestErr);
          }

          for (const url of timedUrls) {
            const res = await fetch(url, { cache: "no-store" });
            if (!res.ok) throw new Error(url);
            const pack = await res.json();
            if (!pack || !Array.isArray(pack.items)) throw new Error("pack format");
            for (const item of pack.items) {
              for (const f of REQUIRED) if (!(f in item)) throw new Error("missing " + f);
              if (!FRAMES.includes(item.frame)) throw new Error("frame");
              if (ids.has(item.id)) throw new Error("duplicate " + item.id);
              ids.add(item.id);
            }
            loaded.push(pack);
            cache[pack.pack_id + "@" + pack.version] = { count: pack.items.length, last_loaded_ts: nowIso() };
          }

          const lessonRes = await fetch(lessonUrl, { cache: "no-store" });
          if (!lessonRes.ok) throw new Error(lessonUrl);
          const lessonPack = await lessonRes.json();
          if (!lessonPack || !Array.isArray(lessonPack.items) || !Array.isArray(lessonPack.operators)) throw new Error("lesson format");
          if (lessonPack.items.length !== 11) throw new Error("lesson items must be 11");
          for (const op of lessonPack.operators) {
            if (!op.script || !op.guided_item_id || !op.one_liner || !Array.isArray(op.steps)) throw new Error("lesson operator");
            if (!op.display_name || !op.display_subtitle) throw new Error("lesson display fields");
            if (typeof op.operator_version !== "number") throw new Error("lesson operator_version");
          }
          for (const item of lessonPack.items) {
            for (const f of REQUIRED) if (!(f in item)) throw new Error("missing lesson " + f);
            if (!FRAMES.includes(item.frame)) throw new Error("lesson frame");
            if (item.time_limit_s !== null && typeof item.time_limit_s !== "number") throw new Error("lesson untimed");
            if (ids.has(item.id)) throw new Error("duplicate " + item.id);
            ids.add(item.id);
          }
          cache[lessonPack.pack_id + "@" + lessonPack.version] = { count: lessonPack.items.length, last_loaded_ts: nowIso() };

          const warnSkew = (label, rows, key, expectedMin = 0) => {
            const counts = rows.reduce((acc, row) => ({ ...acc, [row[key]]: (acc[row[key]] || 0) + 1 }), {});
            Object.entries(counts).forEach(([k, count]) => {
              if (count < expectedMin) console.warn(`${label}: ${k} has low coverage (${count})`);
            });
            return counts;
          };
          const core = loaded.find((p) => p.pack_id === "core_v1");
          if (core) {
            warnSkew("core_v1 script coverage", core.items || [], "script", 8);
            const frameCounts = warnSkew("core_v1 frame coverage", core.items || [], "frame");
            Object.entries(frameCounts).forEach(([frame, count]) => {
              if (Math.abs(count - 30) > 8) console.warn(`core_v1 frame distribution skew: ${frame}=${count}`);
            });
          }
          const gym = loaded.find((p) => p.pack_id === "reasoning_gym_v1");
          if (gym) {
            const tagCounts = warnSkew("reasoning_gym_v1 near-miss coverage", gym.items || [], "near_miss_tag", 20);
            Object.entries(tagCounts).forEach(([tag, count]) => {
              if (Math.abs(count - 20) > 6) console.warn(`reasoning_gym_v1 tag distribution skew: ${tag}=${count}`);
              const rows = (gym.items || []).filter((it) => it.near_miss_tag === tag);
              const frameCounts = warnSkew(`reasoning_gym_v1 frame mix for ${tag}`, rows, "frame");
              if (Object.keys(frameCounts).length < 2) console.warn(`reasoning_gym_v1 frame mix too narrow for ${tag}`);
            });
          }

          if (!cancelled) {
            setTimedPacks(loaded);
            setLessonsPack(lessonPack);
            setLoadingPacks(false);
            save(LS.CACHE, cache);
          }
        } catch (e) {
          console.error(e);
          if (!cancelled) {
            setPackError("Content did not load. Check your connection or reload the page.");
            setLoadingPacks(false);
          }
        }
      };
      load();
      return () => { cancelled = true; };
    }, []);

    useEffect(() => {
      if (!session || session.phase !== "question") return;
      if (lessonModalScript) return;
      if (timerSec <= 0) return;
      const id = setTimeout(() => setTimerSec((v) => v - 1), 1000);
      return () => clearTimeout(id);
    }, [timerSec, session, lessonModalScript]);

    const pushEvent = (type, payload) => setEvents((prev) => [...prev, { ts: nowIso(), app: "mindware", type, payload }].slice(-800));
    const seenRecently = (id) => {
      const ts = mwState.seen_items[id];
      if (!ts) return false;
      return (Date.now() - new Date(ts).getTime()) < (7 * 24 * 60 * 60 * 1000);
    };
    const mapTag = (tag) => {
      const tags = ["invalid_conditional","no_counterexample","base_rate_ignored","correlation_not_cause","surface_over_structure"];
      return tags.includes(tag) ? tag : "surface_over_structure";
    };
    const transferFailCountLast7d = (script) => {
      if (!script) return 0;
      const since = Date.now() - (7 * 24 * 60 * 60 * 1000);
      return events.filter((e) => {
        const ts = new Date(e?.ts || 0).getTime();
        return ts >= since
          && (e?.type === "probe_failed" || e?.type === "recheck_failed")
          && e?.payload?.script === script;
      }).length;
    };
    const sessionGymSuggestion = (s) => {
      if (!s || !Array.isArray(s.answers)) return null;
      const total = s.answers.length;
      const correct = s.answers.filter((a) => a.correct).length;
      const accuracy = total ? correct / total : 0;
      const boundaryAnswers = s.answers.filter((a) => a.is_boundary);
      const boundaryPass = boundaryAnswers.length ? boundaryAnswers.every((a) => a.correct) : false;
      const missCounts = s.answers.reduce((acc, a) => ({ ...acc, [a.near_miss_tag]: (acc[a.near_miss_tag] || 0) + (a.correct ? 0 : 1) }), {});
      const topMiss = Object.entries(missCounts).sort((a, b) => b[1] - a[1])[0] || null;
      const repeatedMistake = Boolean(topMiss && topMiss[1] >= 2 && accuracy < 0.8);
      if (repeatedMistake) return mapTag(topMiss[0]);
      const transferFailedNow = (s.mode === "probe" || s.mode === "recheck") && !(accuracy >= 0.7 && boundaryPass);
      const transferFails = transferFailCountLast7d(s.script) + (transferFailedNow ? 1 : 0);
      if (transferFailedNow && transferFails >= 2) return mapTag(topMiss ? topMiss[0] : null);
      return null;
    };
    const recommended = useMemo(() => {
      const readiness = String(shared.today.readiness || "full").toLowerCase();
      const noisy = String(shared.today.data_quality || "ok").toLowerCase() !== "ok";
      if (mwState.probe.pending_recheck && readiness === "full") return { mode: "recheck", note: "Transfer re-check due: replay a similar set to confirm this still holds." };
      if (mwState.probe.pending_probe && readiness === "full" && !noisy) return { mode: "probe", note: "Transfer check due: " + String(mwState.probe.pending_probe.distance || "near").toUpperCase() + " distance (new situation)." };
      if (
        mwState.probe.next_microset_tag &&
        mwState.probe.next_microset_source_session_id &&
        mwState.probe.next_microset_source_session_id === shared.last?.mindware_session?.summary?.session_id
      ) {
        const tag = mapTag(mwState.probe.next_microset_tag);
        return {
          mode: "gym",
          note: "Quick repair available (2 minutes): " + gymFamilyLabel(tag) + ".",
          tag
        };
      }
      return { mode: "practice", note: "" };
    }, [mwState.probe, shared]);

    const pickItems = ({ mode, signature, microTag, script }) => {
      const targetN = mode === "gym" ? 5 : (TIMEBOX_TO_ITEMS[plan.timebox_min] || 8);
      let pool = [];
      if (mode === "gym") {
        pool = allItems.filter((it) => it.near_miss_tag === microTag);
      } else if (mode === "recheck" && signature) {
        pool = allItems.filter((it) => it.frame === signature.frame && it.wrapper === signature.wrapper && it.script === signature.script);
      } else if (mode === "probe" && signature) {
        if (signature.distance === "near") {
          pool = allItems.filter((it) => it.frame === signature.frame && it.wrapper !== signature.wrapper && it.script === signature.script);
        } else if (signature.distance === "mid") {
          pool = allItems.filter((it) => it.frame !== signature.frame && (it.polarity === signature.polarity || it.lens_target === signature.lens_target) && it.script === signature.script);
        } else {
          pool = allItems.filter((it) => it.frame !== signature.frame && (it.polarity !== signature.polarity || it.lens_target !== signature.lens_target) && it.script === signature.script);
        }
      } else {
        pool = allItems.filter((it) => it.frame === plan.frame && (it.script === script || it.script === "Y0"));
      }
      const fresh = pool.filter((it) => !seenRecently(it.id));
      const src = fresh.length >= targetN ? fresh : pool;
      if (mode === "gym") {
        const limit = Math.min(targetN, src.length);
        if (!limit) return [];
        const switchPool = src.filter((it) => it.is_switch === true);
        const regularPool = src.filter((it) => it.is_switch !== true);
        if (switchPool.length) {
          const oneSwitch = switchPool.slice().sort(() => Math.random() - 0.5).slice(0, 1);
          const restN = Math.max(0, limit - 1);
          const rest = regularPool.slice().sort(() => Math.random() - 0.5).slice(0, restN);
          const topUpN = Math.max(0, limit - (oneSwitch.length + rest.length));
          const topUp = switchPool.slice().sort(() => Math.random() - 0.5).slice(1, 1 + topUpN);
          return [...oneSwitch, ...rest, ...topUp];
        }
      }
      let picked = src.slice().sort(() => Math.random() - 0.5).slice(0, targetN);
      if (picked.length && !picked.some((x) => x.is_boundary)) {
        const boundary = src.find((x) => x.is_boundary);
        if (boundary) picked[picked.length - 1] = boundary;
      }
      if ((picked.some((x) => x.script === "Y0" || x.script === "Y1" || x.script === "Y10")) && !picked.some((x) => x.kind === "choose_check")) {
        const check = src.find((x) => x.kind === "choose_check");
        if (check) picked[Math.max(0, picked.length - 2)] = check;
      }
      return picked;
    };

    const beginTimedSession = ({ mode, signature, microTag, script }) => {
      const items = pickItems({ mode, signature, microTag, script });
      if (!items.length) {
        alert("No items available for this mode.");
        return;
      }
      const q = items[0];
      setSession({
        id: uid(),
        started_at: nowIso(),
        mode,
        frame: signature?.frame || plan.frame,
        script: signature?.script || script,
        rigour: signature?.rigour || plan.rigour,
        signature,
        items,
        index: 0,
        phase: "question",
        answers: [],
        current: q,
        qStartedAt: Date.now()
      });
      setTimerSec(Number(q.time_limit_s || 35));
      setScreen("session");
    };

    const startSession = () => {
      let mode = recommended.mode === "practice" ? "practice" : recommended.mode;
      let signature = mode === "recheck" ? mwState.probe.pending_recheck : (mode === "probe" ? mwState.probe.pending_probe : null);
      let microTag = mode === "gym" ? mwState.probe.next_microset_tag : null;
      let script = signature?.script || plan.script;

      // Respect explicit script selection for manual starts.
      if (mode === "gym" || ((mode === "probe" || mode === "recheck") && signature?.script && signature.script !== plan.script)) {
        mode = "practice";
        signature = null;
        microTag = null;
        script = plan.script;
      }

      if (mode === "gym") {
        // Consume suggestion at entry so backing out does not keep forcing Gym.
        setMwState((prev) => ({
          ...prev,
          probe: {
            ...prev.probe,
            next_microset_tag: null,
            next_microset_source_session_id: null
          }
        }));
      }

      if (!lessonsPack) {
        alert("Lessons are required but not loaded.");
        return;
      }
      if (needsTeach(script)) {
        startTeachForScript(script, mode, signature, microTag);
        return;
      }
      beginTimedSession({ mode, signature, microTag, script });
    };
    const startQuickRepair = () => {
      const tag = mapTag(recommended.tag || mwState.probe.next_microset_tag);
      setMwState((prev) => ({
        ...prev,
        probe: {
          ...prev.probe,
          next_microset_tag: null,
          next_microset_source_session_id: null
        }
      }));
      beginTimedSession({ mode: "gym", signature: null, microTag: tag, script: plan.script });
    };
    const useSimpleMissionPreset = () => {
      setMissionDraft((prev) => ({
        ...prev,
        cue: "Today, during my next focused work block",
        success_signal: "I complete one concrete step and write a 1-2 line result",
        stop_flip_rule: "If I'm stuck for 5 minutes, I simplify and pick the next smallest step"
      }));
    };
    const startTeachForScript = (script, mode = "practice", signature = null, microTag = null) => {
      const lesson = getLessonByScript(script);
      const guided = getGuidedItemByScript(script);
      if (!lesson || !guided) {
        alert("Lesson content for this script is missing.");
        return;
      }
      setLessonRun({ script, lesson, guided, mode, signature, microTag });
      setGuidedFeedback(null);
      setScreen("teach");
    };
    const openHowItWorks = () => {
      setShowHowItWorks(true);
      setMwState((prev) => ({
        ...prev,
        ui: {
          ...asObj(prev.ui),
          home_help_dismissed: false,
          how_it_works_last_opened_ts: nowIso()
        }
      }));
    };

    const resetLearningState = () => {
      setMwState((prev) => {
        const nextScripts = Object.fromEntries(
          Object.entries(prev.scripts || {}).map(([k, v]) => {
            const row = asObj(v);
            const { recent_accuracy, ...rest } = row;
            return [k, rest];
          })
        );
        return {
          ...prev,
          operator_intro: {},
          scripts: nextScripts
        };
      });
    };

    const openTeachForPlan = () => startTeachForScript(plan.script, "practice", null, null);

    const handleAnswer = (selectedIndex) => {
      setSession((prev) => {
        if (!prev || prev.phase !== "question") return prev;
        const item = prev.current;
        const late = Number(item.time_limit_s || 35) > 0 && timerSec <= 0;
        const answer = {
          item_id: item.id,
          selected_index: selectedIndex,
          correct: selectedIndex === item.answer_index,
          late,
          rt_ms: Date.now() - prev.qStartedAt,
          near_miss_tag: item.near_miss_tag,
          is_boundary: item.is_boundary
        };
        setMwState((s) => ({ ...s, seen_items: { ...s.seen_items, [item.id]: nowIso() } }));
        return { ...prev, answers: [...prev.answers, answer], phase: "feedback", lastCorrect: answer.correct };
      });
    };

    const nextQuestion = () => {
      setSession((prev) => {
        if (!prev) return prev;
        const nextIdx = prev.index + 1;
        if (nextIdx >= prev.items.length) return { ...prev, phase: "complete", completed_at: nowIso() };
        const q = prev.items[nextIdx];
        setTimerSec(Number(q.time_limit_s || 35));
        return { ...prev, index: nextIdx, current: q, phase: "question", qStartedAt: Date.now() };
      });
    };

    const finishSession = () => {
      if (!session || session.phase !== "complete") return;
      const total = session.answers.length;
      const correct = session.answers.filter((a) => a.correct).length;
      const accuracy = total ? correct / total : 0;
      const boundaryAnswers = session.answers.filter((a) => a.is_boundary);
      const boundaryPass = boundaryAnswers.length ? boundaryAnswers.every((a) => a.correct) : false;
      const missCounts = session.answers.reduce((acc, a) => ({ ...acc, [a.near_miss_tag]: (acc[a.near_miss_tag] || 0) + (a.correct ? 0 : 1) }), {});
      const topMiss = Object.entries(missCounts).sort((a, b) => b[1] - a[1])[0] || null;
      const transferFailedNow = (session.mode === "probe" || session.mode === "recheck") && !(accuracy >= 0.7 && boundaryPass);
      const shouldSuggestTransferGym = transferFailedNow && ((transferFailCountLast7d(session.script) + 1) >= 2);
      const summary = {
        session_id: session.id,
        mode: session.mode,
        frame: session.frame,
        script: session.script,
        accuracy: Number(accuracy.toFixed(2)),
        boundary_pass: boundaryPass,
        top_near_miss: topMiss ? topMiss[0] : null,
        top_near_miss_count: topMiss ? topMiss[1] : 0,
        completed_at: nowIso()
      };
      pushEvent("practice_completed", summary);

      setMwState((prev) => {
        const next = { ...prev, scripts: { ...prev.scripts }, probe: { ...prev.probe } };
        const cur = next.scripts[session.script] || { attempts: 0, accuracy_avg: 0, status: "learning", recent_accuracy: [] };
        const attempts = Number(cur.attempts || 0) + 1;
        const avg = ((Number(cur.accuracy_avg || 0) * Number(cur.attempts || 0)) + accuracy) / attempts;
        const recent = [...(Array.isArray(cur.recent_accuracy) ? cur.recent_accuracy : []), Number(accuracy.toFixed(2))].slice(-3);
        next.scripts[session.script] = {
          attempts,
          accuracy_avg: Number(avg.toFixed(2)),
          status: avg >= 0.75 ? "stable" : "learning",
          last_session_ts: summary.completed_at,
          recent_accuracy: recent
        };

        if (session.mode === "probe") {
          if (accuracy >= 0.7 && boundaryPass) {
            const dist = session.signature?.distance || "near";
            const sig = {
              script: session.script,
              frame: session.frame,
              distance: dist,
              wrapper: session.items[0]?.wrapper,
              rigour: session.rigour,
              time_limit_s: session.items[0]?.time_limit_s || 35,
              polarity: session.items[0]?.polarity,
              lens_target: session.items[0]?.lens_target,
              ts: summary.completed_at
            };
            next.probe.last_passed_probe_signature = sig;
            next.probe.pending_recheck = { ...sig, due_after_ts: summary.completed_at };
            next.probe.pending_probe = null;
            next.probe.next_distance = dist === "near" ? "mid" : (dist === "mid" ? "far" : "far");
            next.probe.next_microset_tag = null;
            next.probe.next_microset_source_session_id = null;
            pushEvent("probe_passed", { session_id: session.id, distance: dist });
          } else {
            if (shouldSuggestTransferGym) {
              next.probe.next_microset_tag = mapTag(topMiss ? topMiss[0] : next.probe.next_microset_tag);
              next.probe.next_microset_source_session_id = session.id;
            } else {
              next.probe.next_microset_tag = null;
              next.probe.next_microset_source_session_id = null;
            }
            pushEvent("probe_failed", { session_id: session.id, script: session.script, distance: session.signature?.distance || "near" });
          }
        } else if (session.mode === "recheck") {
          next.probe.pending_recheck = null;
          if (accuracy >= 0.7 && boundaryPass) {
            next.probe.next_microset_tag = null;
            next.probe.next_microset_source_session_id = null;
            pushEvent("recheck_passed", { session_id: session.id });
          }
          else {
            if (shouldSuggestTransferGym) {
              next.probe.next_microset_tag = mapTag(topMiss ? topMiss[0] : next.probe.next_microset_tag);
              next.probe.next_microset_source_session_id = session.id;
            } else {
              next.probe.next_microset_tag = null;
              next.probe.next_microset_source_session_id = null;
            }
            pushEvent("recheck_failed", { session_id: session.id, script: session.script });
          }
        } else if (session.mode === "gym") {
          next.probe.next_microset_tag = null;
          next.probe.next_microset_source_session_id = null;
        } else {
          if (accuracy >= 0.7 && boundaryPass && !next.probe.pending_probe && !next.probe.pending_recheck) {
            next.probe.pending_probe = {
              script: session.script,
              frame: session.frame,
              distance: next.probe.next_distance || "near",
              wrapper: session.items[0]?.wrapper,
              rigour: session.rigour,
              time_limit_s: session.items[0]?.time_limit_s || 35,
              polarity: session.items[0]?.polarity,
              lens_target: session.items[0]?.lens_target
            };
          }
          if (topMiss && topMiss[1] >= 2 && accuracy < 0.8) {
            next.probe.next_microset_tag = mapTag(topMiss[0]);
            next.probe.next_microset_source_session_id = session.id;
          } else {
            next.probe.next_microset_tag = null;
            next.probe.next_microset_source_session_id = null;
          }
        }
        return next;
      });

      setShared((prev) => ({
        ...prev,
        today: {
          ...prev.today,
          mindware: {
            ...prev.today.mindware,
            sessions_completed: Number(prev.today.mindware?.sessions_completed || 0) + 1,
            last_session_ts: summary.completed_at,
            missions_pending: mwState.missions.filter((m) => m.status === "pending").length
          }
        },
        last: { ...prev.last, mindware_session: { summary } }
      }));
      setScreen("post");
    };

    const saveMission = () => {
      if (!missionDraft.cue.trim() || !missionDraft.success_signal.trim()) {
        alert("Cue and success signal are required.");
        return;
      }
      const mission = {
        id: uid(),
        status: "pending",
        created_ts: nowIso(),
        cue: missionDraft.cue.trim(),
        success_signal: missionDraft.success_signal.trim(),
        stop_flip_rule: missionDraft.stop_flip_rule.trim() || null,
        value_tag: missionDraft.value_tag.trim() || null,
        created_from_session_id: session?.id || null
      };
      setMwState((prev) => ({ ...prev, missions: [...prev.missions, mission] }));
      setShared((prev) => ({
        ...prev,
        today: { ...prev.today, mindware: { ...prev.today.mindware, missions_pending: Number(prev.today.mindware?.missions_pending || 0) + 1 } }
      }));
      pushEvent("mission_planned", { mission_id: mission.id });
      setScreen("home");
    };

    const saveMissionOutcome = () => {
      if (!pendingMission) { setScreen("home"); return; }
      setMwState((prev) => ({
        ...prev,
        missions: prev.missions.map((m) => m.id === pendingMission.id ? { ...m, status: "done", outcome_ts: nowIso(), outcome: { ...missionOutcome } } : m),
        probe: {
          ...prev.probe,
          next_microset_tag: (missionOutcome.success_met === "NO" && missionOutcome.blocker === "script_use")
            ? (prev.probe.next_microset_tag || "surface_over_structure")
            : prev.probe.next_microset_tag
        }
      }));
      setShared((prev) => ({
        ...prev,
        today: { ...prev.today, mindware: { ...prev.today.mindware, missions_pending: Math.max(0, Number(prev.today.mindware?.missions_pending || 0) - 1) } }
      }));
      pushEvent("mission_completed", { mission_id: pendingMission.id, outcome: missionOutcome.success_met });
      setMissionOutcome({ cue_fired: "YES", success_met: "PARTLY", blocker: "", improved: "", note: "" });
      setScreen("home");
    };

    const Frame = ({ chip, subtitle, children }) => {
      const modalLesson = lessonModalScript ? getLessonByScript(lessonModalScript) : null;
      return (
        <>
          <div className="screen">
            <div className="topbar">
              <div className="brandleft">
                <div className="icon"><img className="appIcon" src={APP_ICON} alt="Trident G" /></div>
                <div>
                  <p className="title">{APP_NAME}</p>
                  <p className="subtitle">{subtitle}</p>
                </div>
              </div>
              <span className="chip">{chip}</span>
            </div>
            <main className="content mindwareNarrow">{children}</main>
          </div>
          {modalLesson ? (
            <div style={{ position:"fixed", inset:0, background:"rgba(0,0,0,0.35)", display:"grid", placeItems:"center", padding:"12px", zIndex:20 }}>
              <section style={{ width:"min(640px, 100%)", maxHeight:"80vh", overflow:"auto", background:"#fff", borderRadius:"16px", border:"1px solid #ddd", padding:"16px" }}>
                <h2 className="h1" style={{ marginTop:0 }}>Script: {scriptTitle(lessonModalScript)}</h2>
                <p className="p">{scriptOneLiner(lessonModalScript)}</p>
                <p style={{ margin:"8px 0", fontWeight:900 }}>Quick reminder</p>
                <ol style={{ margin:"0 0 0 18px", padding:0 }}>
                  {(modalLesson.steps || []).slice(0, 3).map((s, i) => <li key={i} className="hint">{s}</li>)}
                </ol>
                {Array.isArray(OPERATOR_GLOSSARY[lessonModalScript]) ? (
                  <>
                    <p style={{ margin:"8px 0", fontWeight:900 }}>Plain-language terms</p>
                    <ul style={{ margin:"0 0 0 18px", padding:0 }}>
                      {OPERATOR_GLOSSARY[lessonModalScript].map(([term, meaning], i) => <li key={i} className="hint"><b>{term}:</b> {meaning}</li>)}
                    </ul>
                  </>
                ) : null}
                <div className="btnRow"><button className="btn btnPrimary" onClick={() => setLessonModalScript(null)}>Close</button></div>
              </section>
            </div>
          ) : null}
          {showHowItWorks ? (
            <div style={{ position:"fixed", inset:0, background:"rgba(0,0,0,0.35)", display:"grid", placeItems:"center", padding:"12px", zIndex:20 }}>
              <section style={{ width:"min(700px, 100%)", maxHeight:"85vh", overflow:"auto", background:"#fff", borderRadius:"16px", border:"1px solid #ddd", padding:"16px" }}>
                <h2 className="h1" style={{ marginTop:0 }}>{COPY.how_it_works_modal.title}</h2>
                <p style={{ margin:"8px 0", fontWeight:900 }}>{COPY.how_it_works_modal.sections[0].title}</p>
                <p className="hint">{COPY.how_it_works_modal.sections[0].body}</p>
                <p style={{ margin:"8px 0", fontWeight:900 }}>{COPY.how_it_works_modal.sections[1].title}</p>
                <p className="hint">{COPY.how_it_works_modal.sections[1].body}</p>
                <p style={{ margin:"8px 0", fontWeight:900 }}>{COPY.how_it_works_modal.sections[2].title}</p>
                <ol style={{ margin:"0 0 8px 18px", padding:0 }}>
                  {COPY.how_it_works_modal.sections[2].list.map((row, i) => <li key={i} className="hint">{row}</li>)}
                </ol>
                <p style={{ margin:"8px 0", fontWeight:900 }}>{COPY.how_it_works_modal.sections[3].title}</p>
                <p className="hint">{COPY.how_it_works_modal.sections[3].body}</p>
                <p className="hint" style={{ marginTop:"10px" }}>{COPY.how_it_works_modal.footer_small}</p>
                <div className="btnRow"><button className="btn btnPrimary" onClick={() => setShowHowItWorks(false)}>Close</button></div>
              </section>
            </div>
          ) : null}
        </>
      );
    };

    if (screen === "splash") {
      return (
        <div className="screen" style={{ background: "#EFF3F8" }}>
          <main className="content mindwareNarrow" style={{ display: "grid", placeItems: "center", minHeight: "100vh" }}>
            <section style={{ width: "100%", background: "#4EA0E8", border: "1px solid #4EA0E8", borderRadius: "22px", padding: "30px 28px", textAlign: "center", boxShadow: "0 8px 24px rgba(20,58,115,0.16)" }}>
              <div style={{ width: "52px", height: "52px", borderRadius: "14px", background: "#BEEF4E", display: "grid", placeItems: "center", margin: "0 auto 12px auto", border: "4px solid rgba(255,255,255,0.5)" }}>
                <img src={APP_ICON} alt="Trident G" style={{ width: "34px", height: "34px", objectFit: "contain", display: "block" }} />
              </div>
              <h1 className="h1" style={{ margin: "0 0 8px 0", fontWeight: 900, color: "#FFFFFF" }}>{APP_NAME}</h1>
              <p className="p" style={{ margin: "0 0 18px 0", color: "#F4FAFF" }}>Teach once -> practise many -> apply to real work.</p>
              <div className="btnRow" style={{ justifyContent: "center", marginBottom: "8px" }}>
                <button
                  className="btn"
                  style={{ background: "#BEEF4E", border: "1px solid #BEEF4E", color: "#111111", fontWeight: 900, minWidth: "220px", boxShadow: "0 4px 16px rgba(190,239,78,0.35)" }}
                  onClick={() => setScreen("home")}
                >
                  Continue
                </button>
              </div>
              <p style={{ margin: 0, color: "#EAF5FF", fontSize: "16px" }}>Mindware Lab - IQ Mindware</p>
            </section>
          </main>
        </div>
      );
    }

    if (loadingPacks) return <Frame chip="Loading" subtitle="Mindware session coordinator"><section className="card"><h1 className="h1">Loading content packs...</h1><p className="p">Preparing scenarios and drills.</p></section></Frame>;

    if (screen === "teach" && lessonRun) {
      const lesson = lessonRun.lesson;
      return (
        <Frame chip="Teach" subtitle="Teach once before timed practice">
          <section className="card">
            <h1 className="h1">Teach mindware script: {scriptTitle(lessonRun.script)}</h1>
            <p className="p">{scriptOneLiner(lessonRun.script)}</p>
            <p className="hint"><b>Quick view:</b> use this once, then move to the worked example.</p>
          </section>
          <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
            <p style={{ margin:"0 0 6px 0", fontWeight:900 }}>When to use it (quick)</p>
            <ul style={{ margin:"0 0 12px 18px", padding:0 }}>
              {(lesson.when_to_use || []).slice(0, 2).map((row, i) => <li key={i} className="hint">{row}</li>)}
            </ul>
            <p style={{ margin:"0 0 6px 0", fontWeight:900 }}>How to do it (quick)</p>
            <ol style={{ margin:"0 0 12px 18px", padding:0 }}>
              {(lesson.steps || []).slice(0, 3).map((row, i) => <li key={i} className="hint">{row}</li>)}
            </ol>
            <p style={{ margin:"0 0 6px 0", fontWeight:900 }}>Common traps (quick)</p>
            <ul style={{ margin:"0 0 12px 18px", padding:0 }}>
              {(lesson.common_traps || []).slice(0, 2).map((row, i) => <li key={i} className="hint">{row}</li>)}
            </ul>
            {Array.isArray(lesson.when_not_to_use) && lesson.when_not_to_use.length ? (
              <>
                <p style={{ margin:"0 0 6px 0", fontWeight:900 }}>When not to use this</p>
                <ul style={{ margin:"0 0 12px 18px", padding:0 }}>
                  {lesson.when_not_to_use.slice(0, 2).map((row, i) => <li key={i} className="hint">{row}</li>)}
                </ul>
              </>
            ) : null}
            {Array.isArray(lesson.switch_first_to_script) && lesson.switch_first_to_script.length ? (
              <section style={{ margin:"0 0 12px 0", border:"1px solid #E0E0E0", borderRadius:"12px", padding:"10px", background:"#FAFAFA" }}>
                <p style={{ margin:"0 0 4px 0", fontWeight:900 }}>If this is the real issue, start with...</p>
                <p className="hint"><b>Start with:</b> {scriptTitle(lesson.switch_first_to_script[0])}</p>
                {lesson.switch_first_reason ? <p className="hint"><b>Why:</b> {lesson.switch_first_reason}</p> : null}
                <div className="btnRow">
                  <button className="btn btnSecondary" onClick={() => startTeachForScript(lesson.switch_first_to_script[0], "practice", null, null)}>See that script</button>
                </div>
              </section>
            ) : null}
            <div className="btnRow">
              <button
                className="btn btnSecondary"
                onClick={() => {
                  setLessonRun(null);
                  setGuidedFeedback(null);
                  setScreen("home");
                }}
              >
                Return to menu
              </button>
              <button className="btn btnPrimary" onClick={() => setScreen("guided")}>Try a worked example</button>
              <button className="btn btnSecondary" onClick={() => setScreen("guided")}>Skip for now</button>
            </div>
          </section>
        </Frame>
      );
    }

    if (screen === "guided" && lessonRun) {
      const item = lessonRun.guided;
      const lesson = lessonRun.lesson;
      if (!guidedFeedback) {
        return (
          <Frame chip="Worked example" subtitle={`${FRAME_LABEL[item.frame]} • ${scriptTitle(item.script)} • ${prettyContext(item.context)}`}>
            <section className="card">
              <h1 className="h1">Worked example (no timer)</h1>
              <p className="p">{stripPromptTags(item.prompt)}</p>
            </section>
            <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
              <div style={{ display:"grid", gap:"10px" }}>
                {item.options.map((op, i) => (
                  <button
                    key={i}
                    className="btn optBtn"
                    onClick={() => {
                      markIntroSeen(lessonRun.script);
                      pushEvent("lesson_completed", {
                        script: lessonRun.script,
                        lesson_version: lessonsPack?.version || 1,
                        operator_version: Number(lesson?.operator_version || lessonsPack?.version || 1)
                      });
                      setGuidedFeedback({ selected: i, correct: i === item.answer_index });
                    }}
                  >
                    {op}
                  </button>
                ))}
              </div>
            </section>
          </Frame>
        );
      }
      return (
        <Frame chip="Guided feedback" subtitle={`Script: ${scriptTitle(lessonRun.script)}`}>
          <section className="card">
            <h1 className="h1">{guidedFeedback.correct ? "Correct" : "Review"}</h1>
            <p className="p"><b>Why this is best:</b> {item.why_right}</p>
          </section>
          <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
            <p style={{ margin:0, fontWeight:900 }}>Why the tempting options fail</p>
            {(item.why_traps || []).map((t, i) => <p key={i} className="hint">{t}</p>)}
            <p style={{ margin:"8px 0 0 0", fontWeight:900 }}>What to do in real life</p>
            <p className="hint">{scriptOneLiner(lessonRun.script)}</p>
            <div className="btnRow">
              <button
                className="btn btnSecondary"
                onClick={() => {
                  setLessonRun(null);
                  setGuidedFeedback(null);
                  setScreen("home");
                }}
              >
                Return to selection
              </button>
              <button
                className="btn btnPrimary"
                onClick={() => {
                  beginTimedSession({ mode: lessonRun.mode, signature: lessonRun.signature, microTag: lessonRun.microTag, script: lessonRun.script });
                  setLessonRun(null);
                  setGuidedFeedback(null);
                }}
              >
                Start timed practice
              </button>
            </div>
          </section>
        </Frame>
      );
    }

    if (screen === "session" && session) {
      if (session.phase === "feedback") {
        const q = session.current;
        const last = session.answers[session.answers.length - 1];
        return (
          <Frame chip={`${session.index + 1}/${session.items.length}`} subtitle="Timed practice">
            <section className="card"><h1 className="h1">{last?.late ? "Time's up" : (session.lastCorrect ? "Correct" : "Not this time")}</h1><p className="p">{q.why_right}</p></section>
            <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
              {last?.late ? <p className="hint"><b>Answered after time.</b></p> : null}
              <p style={{ margin:0, fontWeight:900 }}>Why the trap fails</p>
              {(q.why_traps || []).slice(0,2).map((t, i) => <p key={i} className="hint">{t}</p>)}
              <div className="btnRow"><button className="btn btnPrimary" onClick={nextQuestion}>{session.index + 1 >= session.items.length ? "Finish session" : "Next item"}</button></div>
            </section>
          </Frame>
        );
      }
      if (session.phase === "complete") {
        const total = session.answers.length;
        const correct = session.answers.filter((a) => a.correct).length;
        const acc = total ? Math.round((correct / total) * 100) : 0;
        const quickRepairTag = sessionGymSuggestion(session);
        return (
          <Frame chip="Complete" subtitle="Session finished">
            <section className="card"><h1 className="h1">Session complete</h1><p className="p">Accuracy: {acc}% ({correct}/{total})</p></section>
            <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
              {quickRepairTag ? (
                <>
                  <p style={{ margin:0, fontWeight:900 }}>Quick repair (2 minutes)</p>
                  <p className="hint">This fixes the mistake that blocked your script today.</p>
                  <p className="hint"><b>Mindware script:</b> {scriptTitle(session.script)}</p>
                  <p className="hint"><b>Reasoning Gym focus:</b> {gymFamilyLabel(quickRepairTag)}</p>
                  <p className="hint">Fix the exact mistake that repeated: <b>{gymFamilyLabel(quickRepairTag)}</b>.</p>
                  <p className="hint">{gymFamilyDef(quickRepairTag)}</p>
                </>
              ) : null}
              <p style={{ margin:0, fontWeight:900 }}>Next step</p>
              <p className="hint"><b>Try this before your next session:</b> pick one small real task today and apply this script once.</p>
              <div className="btnRow"><button className="btn btnPrimary" onClick={finishSession}>Continue</button></div>
              <p className="hint"><b>Next:</b> do one real-life mission today, then log the outcome next time you open the app.</p>
            </section>
          </Frame>
        );
      }
      const q = session.current;
      const lesson = getLessonByScript(q.script);
      return (
        <Frame chip={`${session.index + 1}/${session.items.length}`} subtitle="Timed practice">
          <section className="card">
            <p className="p" style={{ marginBottom:"8px", fontSize:"13px", color:"#334" }}>
              <b>{FRAME_LABEL[session.frame]}</b> • <b>MS: {lesson ? scriptTitle(q.script) : "Script"}</b> • <b>{prettyContext(q.context)}</b> • <b>{timerSec}s left</b>
            </p>
            <p className="hint" style={{ marginTop:0 }}>
              <button className="plainLink" onClick={() => setLessonModalScript(q.script)}>What is this script?</button>
            </p>
            <h1 className="h1">Timed item</h1>
            {(q.is_switch === true && q.switch_type === "wrong_tool") ? <p className="hint"><b>Is this the right approach?</b></p> : null}
            {(q.is_switch === true && q.switch_type === "flip_trigger") ? <p className="hint"><b>What would change your mind?</b></p> : null}
            <p className="p">{stripPromptTags(q.prompt)}</p>
            {timerSec <= 0 ? <p className="hint"><b>Time is up.</b> You can still answer.</p> : null}
          </section>
          <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
            <div style={{ display:"grid", gap:"10px" }}>
              {q.options.map((op, i) => <button key={i} className="btn optBtn" onClick={() => handleAnswer(i)}>{op}</button>)}
            </div>
          </section>
        </Frame>
      );
    }

    if (screen === "post") {
      return (
        <Frame chip="Mission" subtitle="Bridge to real-world use">
          <section className="card"><h1 className="h1">Try it in real life</h1><p className="p">Before your next session, run one small mission with this script.</p></section>
          <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
            <label style={{ fontWeight:900 }}>Cue (When will I do it?)</label><input className="field" value={missionDraft.cue} onChange={(e)=>setMissionDraft((p)=>({...p,cue:e.target.value}))} />
            <label style={{ fontWeight:900, display:"block", marginTop:"10px" }}>Success signal (How will I know it worked?)</label><input className="field" value={missionDraft.success_signal} onChange={(e)=>setMissionDraft((p)=>({...p,success_signal:e.target.value}))} />
            <label style={{ fontWeight:900, display:"block", marginTop:"10px" }}>Stop/switch rule (optional)</label><input className="field" value={missionDraft.stop_flip_rule} onChange={(e)=>setMissionDraft((p)=>({...p,stop_flip_rule:e.target.value}))} />
            <label style={{ fontWeight:900, display:"block", marginTop:"10px" }}>Value tag (optional)</label><input className="field" value={missionDraft.value_tag} onChange={(e)=>setMissionDraft((p)=>({...p,value_tag:e.target.value}))} />
            <div className="btnRow">
              <button className="btn btnSecondary" onClick={useSimpleMissionPreset}>Use a simple mission (recommended)</button>
            </div>
            <div className="btnRow"><button className="btn btnPrimary" onClick={saveMission}>Save mission</button><button className="btn btnSecondary" onClick={()=>setScreen("home")}>Skip</button></div>
          </section>
        </Frame>
      );
    }

    if (screen === "mission_outcome") {
      return (
        <Frame chip="Check-in" subtitle="Mission result">
          <section className="card"><h1 className="h1">Mission check-in</h1><p className="p">{pendingMission ? pendingMission.cue : "No pending mission."}</p></section>
          {!pendingMission ? <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}><div className="btnRow"><button className="btn btnPrimary" onClick={()=>setScreen("home")}>Back home</button></div></section> : (
            <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
              <div className="grid2">
                <select className="field" value={missionOutcome.cue_fired} onChange={(e)=>setMissionOutcome((p)=>({...p,cue_fired:e.target.value}))}><option value="YES">Did the cue happen? Yes</option><option value="NO">Did the cue happen? No</option></select>
                <select className="field" value={missionOutcome.success_met} onChange={(e)=>setMissionOutcome((p)=>({...p,success_met:e.target.value}))}><option value="YES">Did it work? Yes</option><option value="PARTLY">Did it work? Partly</option><option value="NO">Did it work? No</option></select>
              </div>
              <select className="field" style={{ marginTop:"10px" }} value={missionOutcome.blocker} onChange={(e)=>setMissionOutcome((p)=>({...p,blocker:e.target.value}))}>
                <option value="">What got in the way?</option>
                <option value="state">State (tired, stressed, distracted)</option>
                <option value="capacity">Capacity (could not hold it in mind)</option>
                <option value="context">Context (time, interruptions, missing info)</option>
                <option value="script_use">Using the script (did not apply it correctly)</option>
                <option value="unsure">Not sure</option>
              </select>
              {missionOutcome.success_met === "PARTLY" ? (
                <input className="field" style={{ marginTop:"10px" }} value={missionOutcome.improved} onChange={(e)=>setMissionOutcome((p)=>({...p,improved:e.target.value}))} placeholder="What improved? (optional)" />
              ) : null}
              <input className="field" style={{ marginTop:"10px" }} value={missionOutcome.note} onChange={(e)=>setMissionOutcome((p)=>({...p,note:e.target.value}))} placeholder="Optional note" />
              <div className="btnRow"><button className="btn btnPrimary" onClick={saveMissionOutcome}>Save check-in</button></div>
            </section>
          )}
        </Frame>
      );
    }

    const refresherLesson = needsRefresher(plan.script) ? getLessonByScript(plan.script) : null;
    const previewSession = (() => {
      let mode = recommended.mode === "practice" ? "practice" : recommended.mode;
      let signature = mode === "recheck" ? mwState.probe.pending_recheck : (mode === "probe" ? mwState.probe.pending_probe : null);
      let script = signature?.script || plan.script;
      if (mode === "gym" || ((mode === "probe" || mode === "recheck") && signature?.script && signature.script !== plan.script)) {
        mode = "practice";
        signature = null;
        script = plan.script;
      }
      return { mode, script, signature };
    })();
    const readinessKey = String(shared.today.readiness || "full").toLowerCase();
    const readinessLabel = readinessKey === "light" ? "Light" : (readinessKey === "reset" ? "Reset" : "Full");
    const capacityDoneToday = Number(shared.today.capacity?.sessions_completed || 0);

    return (
      <Frame chip={`${Number(shared.today.mindware?.sessions_completed || 0)} today`} subtitle="Understand • Argue • Decide • Plan & Do">
        <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"12px" }}>
          <p style={{ margin:"0 0 6px 0", fontWeight:900 }}>{COPY.home_help_strip.title}</p>
          <p className="hint">{COPY.home_help_strip.lines[0]}</p>
          <p className="hint">{COPY.home_help_strip.lines[1]}</p>
          <p className="hint" style={{ marginTop:"8px" }}>
            <button className="plainLink" onClick={openHowItWorks}>{COPY.home_help_strip.links.learn_more}</button>
          </p>
        </section>
        <section className="card"><h1 className="h1">Mindware loop</h1><p className="p"><b>Teach &gt; Worked example &gt; Timed practice &gt; Try it in real life &gt; Hardwire it as new mindware (crystallised intelligence)</b></p></section>
        <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
          <p style={{ margin:0, fontWeight:900 }}>Today</p>
          <p className="hint"><b>Recommended intensity today:</b> <b>{readinessLabel}</b> (change)</p>
          <p className="hint">Full = normal practice. Light = shorter. Reset = mission only.</p>
          {capacityDoneToday >= 1 ? <p className="hint"><b>Capacity training done today:</b> {capacityDoneToday} session{capacityDoneToday === 1 ? "" : "s"}</p> : null}
          {capacityDoneToday >= 2 ? <p className="hint">You've already done a lot today. Consider a short mindware session or mission-only.</p> : null}
          {(String(shared.today.data_quality || "ok").toLowerCase() !== "ok") ? <p className="hint">Today looks noisy. Consider Light or Reset.</p> : null}
          {recommended.note ? <p className="hint">{recommended.note}</p> : null}
          {recommended.mode === "probe" ? <p className="hint">Transfer check = Same script, different situation.</p> : null}
          {recommended.mode === "recheck" ? <p className="hint">Transfer re-check = Try it again later to see if it sticks.</p> : null}
          {!pendingMission ? <p className="hint"><b>After this session:</b> set one small work task (5-15 minutes) to try this script once. <button className="plainLink" onClick={openHowItWorks}>Why?</button></p> : null}
          {pendingMission ? (
            <>
              <p className="hint"><b>{COPY.mission_bridge_banner.pending_title}:</b> {COPY.mission_bridge_banner.pending_body}</p>
              <div className="btnRow">
                <button className="btn btnSecondary" onClick={() => setScreen("mission_outcome")}>{COPY.mission_bridge_banner.buttons.log_outcome}</button>
                <button className="btn btnSecondary" onClick={() => setScreen("home")}>{COPY.mission_bridge_banner.buttons.skip_for_now}</button>
              </div>
            </>
          ) : null}
          {recommended.mode === "gym" ? (
            <section style={{ marginTop:"8px", border:"1px solid #E0E0E0", borderRadius:"12px", padding:"10px", background:"#FAFAFA" }}>
              <p style={{ margin:"0 0 4px 0", fontWeight:900 }}>Reasoning Gym (quick repair)</p>
              <p className="hint"><b>{gymFamilyLabel(recommended.tag)}:</b> {gymFamilyDef(recommended.tag)}</p>
              <p className="hint">Optional warm-up: 3-5 items, about 2 minutes, then back to your script.</p>
              <div className="btnRow"><button className="btn btnSecondary" onClick={startQuickRepair}>Start quick repair</button></div>
            </section>
          ) : null}
        </section>
        <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
          <p style={{ margin:"0 0 10px 0", fontWeight:900 }}>Choose a mindware script</p>
          <p className="hint">Choose what to practise.</p>
          <p className="hint">Frame = the kind of thinking task. Script = the routine you'll use inside it.</p>
          <p className="hint">Example: Decide + Trade-offs means make a decision using a quick trade-off check.</p>
          <div className="grid2">
            <select className="field" value={plan.frame} onChange={(e)=>setPlan((p)=>({...p,frame:e.target.value}))}>{FRAMES.map((f) => <option key={f} value={f}>Frame: {FRAME_LABEL[f]}</option>)}</select>
            <select className="field" value={plan.script} onChange={(e)=>setPlan((p)=>({...p,script:e.target.value}))}>
              {SCRIPTS.map((s) => <option key={s} value={s}>Script: {scriptTitle(s)}</option>)}
            </select>
            <select className="field" value={plan.rigour} onChange={(e)=>setPlan((p)=>({...p,rigour:e.target.value}))}><option value="light">Rigour: light</option><option value="standard">Rigour: standard</option><option value="deep">Rigour: deep</option></select>
            <select className="field" value={plan.timebox_min} onChange={(e)=>setPlan((p)=>({...p,timebox_min:Number(e.target.value)}))}> {[2,4,6,8].map((m)=><option key={m} value={m}>Timebox: {m} min</option>)} </select>
          </div>
          <p className="hint" style={{ marginTop:"10px" }}>
            Selected: <b>{FRAME_LABEL[plan.frame]}</b> • <b>Script: {scriptTitle(plan.script)}</b>
          </p>
          {getLessonByScript(plan.script) ? (
            <section style={{ marginTop:"8px", border:"1px solid #E0E0E0", borderRadius:"12px", padding:"10px", background:"#FAFAFA" }}>
              <p style={{ margin:"0 0 4px 0", fontWeight:900 }}>What you're practising</p>
              <p className="hint">{scriptOneLiner(plan.script)}</p>
              <p className="hint"><b>Use it when:</b> {plan.script === "Y1" ? "you're gathering info but nothing is changing what you'll do next." : ((getLessonByScript(plan.script).when_to_use || [])[0] || "A decision needs a clear next move.")}</p>
              <p className="hint"><b>Quick steps:</b></p>
              <ol style={{ margin:"0 0 0 18px", padding:0 }}>
                {(getLessonByScript(plan.script).steps || []).slice(0, 3).map((s, i) => <li key={i} className="hint">{s}</li>)}
              </ol>
              {Array.isArray(OPERATOR_GLOSSARY[plan.script]) ? (
                <p className="hint"><b>Terms:</b> {OPERATOR_GLOSSARY[plan.script].map(([term, meaning]) => `${term} = ${meaning}`).join(" | ")}</p>
              ) : null}
              <div className="btnRow">
                <button
                  className="btn btnPrimary"
                  onClick={openTeachForPlan}
                >
                  Open script guide (quick teach)
                </button>
                <button
                  className="btn btnSecondary"
                  style={{ background:"#EAF5FF", border:"1px solid #2764B7", color:"#143A73", fontWeight:900, opacity:1 }}
                  onClick={() => {
                    const lesson = getLessonByScript(plan.script);
                    const guided = getGuidedItemByScript(plan.script);
                    if (!lesson || !guided) return;
                    setLessonRun({ script: plan.script, lesson, guided, mode: "practice", signature: null, microTag: null });
                    setGuidedFeedback(null);
                    setScreen("guided");
                  }}
                >
                  Preview one worked example (untimed)
                </button>
              </div>
              <p className="hint" style={{ marginTop:"6px" }}>
                Use the script guide first if this routine is new. Then preview one worked example before timed practice.
              </p>
              <p className="hint" style={{ marginTop:"6px" }}>
                Use this to see one full question and feedback before you start timed practice.
              </p>
            </section>
          ) : null}
          {needsTeach(plan.script) ? <p className="hint"><b>First run:</b> Teach and a worked example will appear before timed items.</p> : null}
          {refresherLesson ? (
            <details style={{ marginTop:"8px" }}>
              <summary style={{ cursor:"pointer", fontWeight:900 }}>Quick reminder</summary>
              <p className="hint">{refresherLesson.one_liner}</p>
              <ol style={{ margin:"0 0 0 18px", padding:0 }}>
                {(refresherLesson.steps || []).slice(0, 3).map((s, i) => <li key={i} className="hint">{s}</li>)}
              </ol>
            </details>
          ) : null}
          <div className="btnRow"><button className="btn btnPrimary" onClick={startSession}>Start session</button></div>
          <p className="hint"><b>{COPY.start_session.why_line}</b></p>
        </section>
        <section style={{ background:"#FFF", border:"1px solid #E0E0E0", borderRadius:"16px", padding:"16px" }}>
          <details>
            <summary style={{ cursor:"pointer", fontWeight:900 }}>Content + status</summary>
            {packError ? <p className="hint" style={{ color:"#9a1b1b" }}>{packError}</p> : null}
            <p className="hint">Timed items loaded: <b>{allItems.length}</b></p>
            <p className="hint">Lessons loaded: <b>{(lessonsPack?.operators || []).length}</b></p>
            <p className="hint">Build: <b>{BUILD_ID}</b></p>
            <p className="hint">Selected script: <b>{scriptTitle(plan.script)}</b></p>
            <p className="hint">Deck script: <b>{previewSession.script ? scriptTitle(previewSession.script) : "mixed"}</b> ({previewSession.mode})</p>
            <p className="hint">Pending probe: <b>{mwState.probe.pending_probe ? "Yes" : "No"}</b> | Pending re-check: <b>{mwState.probe.pending_recheck ? "Yes" : "No"}</b></p>
            <p className="hint">Reasoning Gym next: <b>{mwState.probe.next_microset_tag ? gymFamilyLabel(mapTag(mwState.probe.next_microset_tag)) : "none"}</b></p>
            <p className="hint">Missions pending: <b>{pendingMissionCount}</b></p>
            <div className="btnRow">
              <button className="btn btnSecondary" onClick={resetLearningState}>Reset learning</button>
            </div>
          </details>
        </section>
      </Frame>
    );
  }

  ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>

