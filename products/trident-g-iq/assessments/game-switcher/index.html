<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session Switcher Training App</title>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

<script type="text/babel" data-presets="env,react">
  const { useState } = React;

  const SessionSwitcher = () => {
    // Branding
    const brand = {
      appName: 'Capacity Training Coach',
      subtitle: 'Adaptive cognitive training based on your current state',
      accent: '#2764B7',
      logoSrc: './assets/Trident-Logo.svg'
    };

    // ------------------------------
    // Storage keys (canonical + legacy fallbacks)
    // ------------------------------
    const STORAGE = {
      // Zone Coach -> Switcher
      ZONE_LAST: 'iqmw.zone.last',            // new canonical
      ZONE_LEGACY: 'zoneCheckTelemetry',      // legacy fallback

      // Progress
      PROGRESS: 'iqmw.progress.v1',           // new canonical
      PROGRESS_LEGACY: 'trainingProgress',    // legacy fallback

      // Capacity handoffs
      CAPACITY_LAST_SESSION: 'iqmw.capacity.lastSession',       // new canonical
      CAPACITY_LEGACY_LAST_SESSION: 'lastCapacitySession',      // legacy fallback
      CAPACITY_LAST_GAME: 'iqmw.capacity.lastGameSelection',    // new canonical
      CAPACITY_LEGACY_LAST_GAME: 'lastGameSelection'            // legacy fallback
    };

    const safeJsonParse = (s) => {
      try { return JSON.parse(s); } catch { return null; }
    };

    const safeSetItem = (k, v) => {
      try { localStorage.setItem(k, v); } catch {}
    };

    // ----- Date helper (local browser time) -----
    const localYYYYMMDD = (d = new Date()) => {
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      return `${yyyy}-${mm}-${dd}`;
    };

    // ------------------------------
    // Zone telemetry adapter (accepts new zone_v1 + legacy shapes)
    // Normalised output guarantees: localDate, timestamp, postBreathMode, dose{}
    // ------------------------------
    const normaliseZoneTelemetry = (raw) => {
      if (!raw || typeof raw !== 'object') return null;

      const timestamp = raw.timestamp || Date.now();
      const ensuredLocalDate =
        raw.localDate ||
        (timestamp ? localYYYYMMDD(new Date(timestamp)) : localYYYYMMDD());

      // 1) Already in legacy "switcher schema"
      if (raw.dose && raw.postBreathMode) {
        return {
          schemaVersion: 'switcher_zone_norm_v1',
          ...raw,
          localDate: ensuredLocalDate,
          timestamp
        };
      }

      // 2) New Zone Coach schema (zone_v1 style)
      const looksLikeZoneV1 = !!raw?.gate?.zone || String(raw?.schemaVersion || '').startsWith('zone_');
      if (looksLikeZoneV1) {
        const gateZone = raw?.gate?.zone || 'mixed'; // cold | in_band | hot | mixed
        const gateRec = raw?.gate?.recommendation || 'proceed'; // proceed | light
        const rigourBudget = raw?.suggest?.rigourBudget || 'medium';
        const timeboxMins = raw?.suggest?.timeboxMins || 10;
        const capacityFocus = raw?.suggest?.capacityFocus || null; // ideally one of: hold/update/clear/shield/stop/recover

        // Prefer explicit label if Zone Coach provides one
        const postBreathMode =
          raw?.modeLabelPublic ||
          raw?.state?.modeLabelPublic ||
          (gateZone === 'in_band'
            ? 'Œ®-band (in the zone)'
            : gateZone === 'cold'
              ? 'Subcritical (flat/demotivated)'
              : gateZone === 'hot'
                ? 'Supercritical: overloaded'
                : 'Mixed / unclear');

        // Keep legacy "dose" fields for downstream compatibility
        const dose = {
          level: gateRec === 'light' ? 'amber' : 'green',
          sessions: Number.isFinite(raw?.suggest?.sessionsAllowed) ? raw.suggest.sessionsAllowed : 1,
          blocks: Number.isFinite(raw?.suggest?.blocksSuggested) ? raw.suggest.blocksSuggested : 1,
          recommendation:
            gateRec === 'light'
              ? 'Proceed, but keep it light today (Recover focus).'
              : 'Proceed with training.'
        };

        return {
          schemaVersion: 'switcher_zone_norm_v1',
          localDate: ensuredLocalDate,
          timestamp,
          postBreathMode,
          dose,
          gate: { zone: gateZone, recommendation: gateRec },
          suggest: { rigourBudget, timeboxMins, capacityFocus },
          rawZoneCheck: raw
        };
      }

      // 3) Legacy Zone Coach schema by shape
      const looksLikeLegacyZoneCoach =
        !!raw?.breathing?.postBreathSelfReport ||
        raw?.gate?.blockTraining !== undefined ||
        raw?.gate?.postInZone !== undefined ||
        raw?.gate?.preInZone !== undefined;

      if (!looksLikeLegacyZoneCoach) {
        // Unknown shape, keep it usable
        return {
          schemaVersion: 'switcher_zone_norm_v1',
          ...raw,
          localDate: ensuredLocalDate,
          timestamp
        };
      }

      const report = raw?.breathing?.postBreathSelfReport;
      const reportMap = {
        'Subcritical': 'Subcritical (flat/demotivated)',
        'Œ®-band': 'Œ®-band (in the zone)',
        'Supercritical ‚Äì explore': 'Supercritical: scattered explore',
        'Supercritical ‚Äì rigid control': 'Supercritical: rigid control',
        'Not sure': 'Mixed / unclear'
      };

      const postBreathMode =
        reportMap[report] ||
        (raw?.prototypes?.modeLabelPublic ? String(raw.prototypes.modeLabelPublic) : 'Mixed / unclear');

      const postInZone = !!raw?.gate?.postInZone;
      const blockTraining = !!raw?.gate?.blockTraining;

      // NOTE: this legacy "red" path will be softened later (we‚Äôll remove hard-blocking in the UI chunk).
      const dose = {
        level: blockTraining ? 'red' : (postInZone ? 'green' : 'amber'),
        sessions: blockTraining ? 0 : 1,
        blocks: blockTraining ? 0 : 1,
        recommendation: blockTraining
          ? 'Recovery recommended today. Keep it light and try again tomorrow.'
          : 'Proceed with training.'
      };

      return {
        schemaVersion: 'switcher_zone_norm_v1',
        localDate: ensuredLocalDate,
        postBreathMode,
        dose,
        timestamp,
        rawZoneCheck: raw
      };
    };

    const getLatestZoneTelemetry = () => {
      // Prefer canonical key, fallback to legacy
      const tryKeys = [STORAGE.ZONE_LAST, STORAGE.ZONE_LEGACY];
      for (const k of tryKeys) {
        const parsed = safeJsonParse(localStorage.getItem(k) || '');
        const norm = normaliseZoneTelemetry(parsed);
        if (norm) return norm;
      }
      return null;
    };

    // ---- Per-day session counter (persist across reloads) ----
    const todayKey = () => `iqmw.capacity.sessionsCompleted_${localYYYYMMDD()}`;

    const loadSessionsCompletedToday = () => {
      try {
        const v = parseInt(localStorage.getItem(todayKey()) || '0', 10);
        return Number.isFinite(v) ? v : 0;
      } catch {
        return 0;
      }
    };

    const bumpSessionsCompletedToday = (setSessionsCompletedToday) => {
      const next = loadSessionsCompletedToday() + 1;
      try { localStorage.setItem(todayKey(), String(next)); } catch {}
      setSessionsCompletedToday(next);
      return next;
    };

    // Splash screen state
    const [showSplash, setShowSplash] = useState(true);

    // Zone Check data (normalised)
    const [zoneCheckData, setZoneCheckData] = useState(null);

    // Unit progression state (canonical + legacy read)
    const [userProgress, setUserProgress] = useState(() => {
      const fromNew = safeJsonParse(localStorage.getItem(STORAGE.PROGRESS) || '');
      if (fromNew) return fromNew;

      const fromLegacy = safeJsonParse(localStorage.getItem(STORAGE.PROGRESS_LEGACY) || '');
      if (fromLegacy) return fromLegacy;

      return {
        schemaVersion: 'progress_v1',
        anchorSessionsCompleted: 0,
        currentUnit: 1,
        unitsCompleted: [],
        swapSessionsCompleted: 0,
        lastSessionDate: null,
        programStartDate: new Date().toISOString(),
        programCompleted: false,
        programCompletionDate: null
      };
    });

    // REPLACE THESE WITH YOUR ACTUAL URLS
    const DNB_URL = "PASTE_YOUR_DNB_APP_URL_HERE";
    const GPT_URL = "PASTE_YOUR_GPT_APP_URL_HERE";

    // Swap game URLs
    const SWAP_URLS = {
      classic: "PASTE_CLASSIC_SWAP_URL",
      logic_gated: "PASTE_LOGIC_GATED_URL",
      emotional: "PASTE_EMOTIONAL_URL"
    };

    // Unit URLs
    const OPERATOR_URLS = {
      1: "https://mindware-lab.github.io/iq-assessments/units/unit-1",
      2: "https://mindware-lab.github.io/iq-assessments/units/unit-2",
      3: "https://mindware-lab.github.io/iq-assessments/units/unit-3",
      4: "https://mindware-lab.github.io/iq-assessments/units/unit-4",
      5: "https://mindware-lab.github.io/iq-assessments/units/unit-5",
      6: "https://mindware-lab.github.io/iq-assessments/units/unit-6",
      7: "https://mindware-lab.github.io/iq-assessments/units/unit-7",
      8: "https://mindware-lab.github.io/iq-assessments/units/unit-8",
      9: "https://mindware-lab.github.io/iq-assessments/units/unit-9",
      10: "https://mindware-lab.github.io/iq-assessments/units/unit-10",
      11: "https://mindware-lab.github.io/iq-assessments/units/unit-11",
      12: "https://mindware-lab.github.io/iq-assessments/units/unit-12",
      13: "https://mindware-lab.github.io/iq-assessments/units/unit-13",
      14: "https://mindware-lab.github.io/iq-assessments/units/unit-14",
      15: "https://mindware-lab.github.io/iq-assessments/units/unit-15",
      16: "https://mindware-lab.github.io/iq-assessments/units/unit-16",
      17: "https://mindware-lab.github.io/iq-assessments/units/unit-17",
      18: "https://mindware-lab.github.io/iq-assessments/units/unit-18",
      19: "https://mindware-lab.github.io/iq-assessments/units/unit-19",
      20: "https://mindware-lab.github.io/iq-assessments/units/unit-20"
    };

    const getUnitUrl = (unitNumber) => {
      return OPERATOR_URLS[unitNumber] || `https://mindware-lab.github.io/iq-assessments/units/unit-${unitNumber}`;
    };

    // Unit metadata - titles and info for all 20 units
    const UNIT_METADATA = {
      1: { title: "Shift the story + test it", category: "Mental Attitude", time: "‚â§10 min" },
      2: { title: "Fast OODA loop", category: "Strategic Planning", time: "‚â§10 min" },
      3: { title: "Turn it into a checklist", category: "Strategic Planning", time: "‚â§10 min" },
      4: { title: "Update your belief (don't get stuck)", category: "Mental Attitude", time: "‚â§10 min" },
      5: { title: "Spot the pattern", category: "Comprehension", time: "‚â§10 min" },
      6: { title: "Test your assumptions", category: "Argumentation", time: "‚â§10 min" },
      7: { title: "Consider the opposite", category: "Argumentation", time: "‚â§10 min" },
      8: { title: "Base rate + adjustment", category: "Decision Making", time: "‚â§10 min" },
      9: { title: "Pre-mortem analysis", category: "Strategic Planning", time: "‚â§10 min" },
      10: { title: "Steelman the argument", category: "Argumentation", time: "‚â§10 min" },
      11: { title: "Double-crux dialogue", category: "Argumentation", time: "‚â§10 min" },
      12: { title: "Seek disconfirming evidence", category: "Comprehension", time: "‚â§10 min" },
      13: { title: "Separate signal from noise", category: "Comprehension", time: "‚â§10 min" },
      14: { title: "Opportunity cost thinking", category: "Decision Making", time: "‚â§10 min" },
      15: { title: "Expected value calculation", category: "Decision Making", time: "‚â§10 min" },
      16: { title: "Zoom in, zoom out", category: "Strategic Planning", time: "‚â§10 min" },
      17: { title: "Second-order effects", category: "Strategic Action", time: "‚â§10 min" },
      18: { title: "Reversible vs irreversible decisions", category: "Decision Making", time: "‚â§10 min" },
      19: { title: "Multiplier thinking", category: "Strategic Action", time: "‚â§10 min" },
      20: { title: "Strategic optionality", category: "Strategic Action", time: "‚â§10 min" }
    };

    // ------------------------------
    // Type-1 capacity primitives (canonical)
    // ------------------------------
    const CAPACITY_FOCI = {
      hold:   { id: 'hold',   label: 'Hold',   def: 'Pin the goal/rule in mind and keep it online.' },
      update: { id: 'update', label: 'Update', def: 'Refresh the active set. Swap in the new info.' },
      clear:  { id: 'clear',  label: 'Clear',  def: 'Drop the old set. Start clean.' },
      shield: { id: 'shield', label: 'Shield', def: 'Keep updates clean. Prevent interference.' },
      stop:   { id: 'stop',   label: 'Stop',   def: 'Brake the default. Ignore distractors and guessing.' },
      recover:{ id: 'recover',label: 'Recover',def: 'Notice conflict/noise. Reset and re-enter the corridor.' }
    };

    // Primary ‚Äúsignature‚Äù of each game wrapper (in primitives)
    const GAME_SIGNATURES = {
      anchor_noncat: ['hold', 'update', 'shield', 'stop', 'recover'],
      classic:       ['hold', 'update', 'shield', 'stop'],
      emotional:     ['stop', 'recover', 'shield', 'hold'],
      logic_gated:   ['clear', 'stop', 'update', 'hold']
    };

    // Unit targets expressed in primitives (defaults; tune later)
    const UNIT_CAPACITY_MAP = {
      1:  { primary: 'stop',   secondary: 'update',  useLine: 'Use it to shift the story, then do one quick reality-check.' },
      2:  { primary: 'update', secondary: 'hold',    useLine: 'Use it to run a fast OODA loop without losing the thread.' },
      3:  { primary: 'hold',   secondary: 'shield',  useLine: 'Use it to compress the job into a simple checklist you can execute.' },
      4:  { primary: 'update', secondary: 'stop',    useLine: 'Use it to update your belief when evidence changes, not when mood changes.' },
      5:  { primary: 'hold',   secondary: 'shield',  useLine: 'Use it to spot the underlying pattern and ignore surface noise.' },
      6:  { primary: 'stop',   secondary: 'shield',  useLine: 'Use it to test assumptions without being pulled by tempting stories.' },
      7:  { primary: 'stop',   secondary: 'shield',  useLine: 'Use it to seriously consider the opposite (without snap-reverting).' },
      8:  { primary: 'hold',   secondary: 'stop',    useLine: 'Use it to apply base rates cleanly instead of going with gut feel.' },
      9:  { primary: 'clear',  secondary: 'hold',    useLine: 'Use it to run a premortem without spiralling into unhelpful detail.' },
      10: { primary: 'shield', secondary: 'hold',    useLine: 'Use it to steelman the strongest case rather than the loudest case.' },
      11: { primary: 'hold',   secondary: 'stop',    useLine: 'Use it to hold the real crux steady and avoid arguing around it.' },
      12: { primary: 'stop',   secondary: 'shield',  useLine: 'Use it to actively look for disconfirming evidence.' },
      13: { primary: 'shield', secondary: 'stop',    useLine: 'Use it to separate signal from noise and stay relevance-led.' },
      14: { primary: 'hold',   secondary: 'update',  useLine: 'Use it to keep options in view and make opportunity costs explicit.' },
      15: { primary: 'hold',   secondary: 'stop',    useLine: 'Use it to do expected value without confidence drift.' },
      16: { primary: 'clear',  secondary: 'hold',    useLine: 'Use it to zoom in/out without losing the governing rule.' },
      17: { primary: 'hold',   secondary: 'update',  useLine: 'Use it to track second-order effects without dropping key constraints.' },
      18: { primary: 'stop',   secondary: 'clear',   useLine: 'Use it to choose reversible vs irreversible moves cleanly.' },
      19: { primary: 'hold',   secondary: 'shield',  useLine: 'Use it to think in multipliers rather than one-step wins.' },
      20: { primary: 'clear',  secondary: 'hold',    useLine: 'Use it to preserve optionality while still committing to a next step.' }
    };

    const getUnitTargets = (unitNumber) => {
      return UNIT_CAPACITY_MAP[unitNumber] || {
        primary: 'hold',
        secondary: 'shield',
        useLine: 'Use it to run the strategy cleanly in one pass.'
      };
    };

    const getRoundForUnit = (unitNumber) => (unitNumber <= 10 ? 1 : 2);

    // Pick ONE capacity focus to highlight:
    // (a) knobs first (strongest), else (b) wrapper signature, biased to unit primary/secondary
    const pickCapacityPack = ({ unitNumber, gameId, settings }) => {
      const targets = getUnitTargets(unitNumber);

      if (gameId === 'anchor_noncat') {
        if (settings?.interference) return { ...CAPACITY_FOCI.shield, match: targets.primary === 'shield' ? 'primary' : (targets.secondary === 'shield' ? 'secondary' : 'other') };
        if (settings?.handSwitch)   return { ...CAPACITY_FOCI.clear,  match: targets.primary === 'clear' ? 'primary' : (targets.secondary === 'clear' ? 'secondary' : 'other') };
        if (settings?.speed)        return { ...CAPACITY_FOCI.hold,   match: targets.primary === 'hold' ? 'primary' : (targets.secondary === 'hold' ? 'secondary' : 'other') };
      }

      const sig = GAME_SIGNATURES[gameId] || GAME_SIGNATURES.anchor_noncat;

      const pickId =
        sig.includes(targets.primary) ? targets.primary :
        sig.includes(targets.secondary) ? targets.secondary :
        sig[0];

      const pack = CAPACITY_FOCI[pickId] || CAPACITY_FOCI.hold;
      const match =
        pickId === targets.primary ? 'primary' :
        pickId === targets.secondary ? 'secondary' :
        'other';

      return { ...pack, match };
    };

    // Persist a compact handoff record so the Unit app can read it on load.
    const persistCapacityHandoff = (payload) => {
      const json = JSON.stringify(payload);
      safeSetItem(STORAGE.CAPACITY_LAST_SESSION, json);
      safeSetItem(STORAGE.CAPACITY_LEGACY_LAST_SESSION, json); // legacy compatibility
    };

    const persistLastGameSelection = (payload) => {
      const json = JSON.stringify(payload);
      safeSetItem(STORAGE.CAPACITY_LAST_GAME, json);
      safeSetItem(STORAGE.CAPACITY_LEGACY_LAST_GAME, json); // legacy compatibility
    };

    // ------------------------------
    // Local UI state
    // ------------------------------
    const [screen, setScreen] = useState('postBreath');
    const [postBreathState, setPostBreathState] = useState(null);
    const [trained3, setTrained3] = useState(null);
    const [progress, setProgress] = useState(null);
    const [routine, setRoutine] = useState(null);
    const [robustness, setRobustness] = useState(null);
    const [click, setClick] = useState(null);
    const [clickNote, setClickNote] = useState('');
    const [showClickInput, setShowClickInput] = useState(false);
    const [deploy, setDeploy] = useState(null);
    const [breaksFirst, setBreaksFirst] = useState(null);
    const [swapChoice, setSwapChoice] = useState(null);
    const [swapStrategy, setSwapStrategy] = useState(null);
    const [recommendation, setRecommendation] = useState(null);
    const [sessionFeel, setSessionFeel] = useState(null);
    const [carryOver, setCarryOver] = useState(null);
    const [spikeGap, setSpikeGap] = useState(null);
    const [bridgeObs, setBridgeObs] = useState('');
    const [bridgeMove, setBridgeMove] = useState('');
    const [selectedChange, setSelectedChange] = useState('none');
    const [sessionsCompletedToday, setSessionsCompletedToday] = useState(() => loadSessionsCompletedToday());

    // NOTE: bumpSessionsCompletedToday now takes the setter, so call:
    // bumpSessionsCompletedToday(setSessionsCompletedToday)

    const makeUnitContextFor = (unitNumber, gameId, settings) => {
      const unitTargets = getUnitTargets(unitNumber);
      const cap = pickCapacityPack({ unitNumber, gameId, settings });

      // --- CONTINUATION: finish makeUnitContextFor(...) and then the effects + URL building ---

      return {
        // ---- Canonical context for unit app ----
        schemaVersion: 'unit_ctx_v1',
        unit: unitNumber,
        round: getRoundForUnit(unitNumber),

        // Unit app needs these
        focus: cap.label,
        plan: recommendation?.planType || '',
        game: gameId,
        settings,
        zone: postBreathState,
        strategy: swapStrategy || '',
        obs: bridgeObs,
        move: bridgeMove,
        sessionsCompleted: sessionsCompletedToday,
        totalSessions: zoneCheckData?.dose?.sessions ?? 1,

        // Capacity focus handoff
        capId: cap.id,
        capLabel: cap.label,
        capDef: cap.def,
        capMatch: cap.match,

        // Unit targets (Option B / primitives)
        unitPrimaryCap: unitTargets.primary,
        unitSecondaryCap: unitTargets.secondary
      };
    };

    // Save progress whenever it changes (canonical + legacy)
    React.useEffect(() => {
      try {
        const payload = {
          ...userProgress,
          schemaVersion: userProgress.schemaVersion || 'progress_v1'
        };
        const json = JSON.stringify(payload);
        localStorage.setItem(STORAGE.PROGRESS, json);
        localStorage.setItem(STORAGE.PROGRESS_LEGACY, json);
      } catch (error) {
        console.warn('Failed to save progress:', error);
      }
    }, [userProgress]);

    // FIX: choose the correct game URL (Anchor vs Swap)
    const getGameUrl = (isSwap, finalGame) => {
      if (!isSwap) return DNB_URL;
      return SWAP_URLS[finalGame] || DNB_URL;
    };

    // NEW: Read Zone Check telemetry on component load
    React.useEffect(() => {
      // -------------------------
      // 1) Handle "just completed a unit"
      // -------------------------
      const lastCompletionRaw = localStorage.getItem('lastUnitCompletion');
      if (lastCompletionRaw) {
        const data = safeJsonParse(lastCompletionRaw);

        // Re-load zone telemetry to get dose info
        const z = getLatestZoneTelemetry();

        // Update progress
        if (data && typeof data.unitNumber === 'number') {
          setUserProgress(prev => {
            const newProgress = { ...prev };
            const unitNum = data.unitNumber;

            if (!Array.isArray(newProgress.unitsCompleted)) newProgress.unitsCompleted = [];
            if (!newProgress.unitsCompleted.includes(unitNum)) {
              newProgress.unitsCompleted = [...newProgress.unitsCompleted, unitNum];
            }

            // Determine session type (anchor vs swap) from multiple sources
            let isAnchorSession = false;

            if (data.sessionType) {
              isAnchorSession = data.sessionType === 'anchor_noncat';
            } else if (sessionStorage.getItem('currentSessionType')) {
              isAnchorSession = sessionStorage.getItem('currentSessionType') === 'anchor_noncat';
              sessionStorage.removeItem('currentSessionType');
              sessionStorage.removeItem('currentSessionTimestamp');
            } else {
              // Fallback heuristic: if completed unit matches "currentUnit", likely anchor
              isAnchorSession = unitNum === newProgress.currentUnit;
            }

            if (isAnchorSession) {
              newProgress.anchorSessionsCompleted = (newProgress.anchorSessionsCompleted || 0) + 1;
              newProgress.currentUnit = Math.min((newProgress.currentUnit || 1) + 1, 20);
            } else {
              newProgress.swapSessionsCompleted = (newProgress.swapSessionsCompleted || 0) + 1;
            }

            newProgress.lastSessionDate = new Date().toISOString();

            if ((newProgress.anchorSessionsCompleted || 0) >= 20) {
              newProgress.programCompleted = true;
              newProgress.programCompletionDate = new Date().toISOString();
            }

            return newProgress;
          });
        }

        // Clear completion flag
        localStorage.removeItem('lastUnitCompletion');

        // FIX: persisted per-day counter (uses new signature)
        const totalSessions = z?.dose?.sessions ?? 1;
        const newSessionsCompleted = bumpSessionsCompletedToday(setSessionsCompletedToday);

        // Restore last plan state if present (avoid blank recommendation screen)
        const restored = safeJsonParse(sessionStorage.getItem('lastPlanState') || '');

        if (newSessionsCompleted < totalSessions) {
          alert(`Unit ${data?.unitNumber ?? ''} complete! Starting session ${newSessionsCompleted + 1} of ${totalSessions}...`);

          if (restored?.recommendation) {
            try {
              setPostBreathState(restored.postBreathState || postBreathState);
              setTrained3(restored.trained3 || trained3);
              setProgress(restored.progress || progress);
              setRoutine(restored.routine || routine);
              setRobustness(restored.robustness || robustness);
              setClick(restored.click || click);
              setDeploy(restored.deploy || deploy);
              setSpikeGap(restored.spikeGap || spikeGap);
              setBreaksFirst(restored.breaksFirst || breaksFirst);
              setSelectedChange(restored.selectedChange || 'none');
              setSwapChoice(restored.swapChoice || null);
              setSwapStrategy(restored.swapStrategy || null);
              setRecommendation(restored.recommendation);
              setScreen('recommendation');
            } catch {
              setScreen('eligibility');
            }
          } else {
            setScreen('eligibility');
          }
        } else {
          alert(`Unit ${data?.unitNumber ?? ''} complete! All sessions done for today.`);
          setScreen('afterTraining');
        }

        return; // Stop here if we processed a completion
      }

      // -------------------------
      // 2) Otherwise load Zone Check data
      // -------------------------
      let data = null;
      let fromLocalStorage = false;

      // Strategy 1: localStorage (best UX)
      const z = getLatestZoneTelemetry();
      if (z) {
        data = z;
        fromLocalStorage = true;

        // Persist normalised zone telemetry back to canonical key for future reads
        try { localStorage.setItem(STORAGE.ZONE_LAST, JSON.stringify(z)); } catch {}

        console.log('Zone Check data loaded from localStorage');
      }

      // Strategy 2: URL params fallback (cross-device or localStorage blocked)
      if (!data) {
        const urlParams = new URLSearchParams(window.location.search);

        // Accept either:
        // - legacy params: mode, dose, sessions, blocks, localDate
        // - newer params: zone, rec, cap, timebox
        const mode = urlParams.get('mode');
        const doseLevel = urlParams.get('dose');
        const sessionsRaw = urlParams.get('sessions');
        const blocksRaw = urlParams.get('blocks');
        const localDate = urlParams.get('localDate') || localYYYYMMDD();

        const zone = urlParams.get('zone');           // cold | in_band | hot | mixed
        const rec = urlParams.get('rec');             // proceed | light
        const cap = urlParams.get('cap');             // hold/update/clear/shield/stop/recover (optional)
        const timebox = urlParams.get('timebox');     // minutes (optional)

        const toInt = (v, fallback) => {
          const n = parseInt(v ?? '', 10);
          return Number.isFinite(n) ? n : fallback;
        };

        if (zone || rec) {
          data = normaliseZoneTelemetry({
            schemaVersion: 'zone_v1',
            timestamp: Date.now(),
            localDate,
            gate: {
              zone: zone || 'mixed',
              recommendation: rec || 'proceed'
            },
            suggest: {
              timeboxMins: toInt(timebox, 10),
              capacityFocus: cap || null
            }
          });
          console.log('Zone Check data loaded from URL params (zone_v1 style)');
        } else if (mode) {
          // legacy style
          data = normaliseZoneTelemetry({
            postBreathMode: mode,
            dose: {
              level: doseLevel || 'amber',
              sessions: toInt(sessionsRaw, 1),
              blocks: toInt(blocksRaw, 1),
              recommendation: doseLevel === 'red'
                ? 'Proceed, but keep it light today (Recover focus).'
                : 'Proceed with training.'
            },
            localDate,
            timestamp: Date.now()
          });
          console.log('Zone Check data loaded from URL params (legacy style)');
        }
      }

      // Validate telemetry is from today
      if (data) {
        const todayLocalDate = localYYYYMMDD();
        if (fromLocalStorage && (!data.localDate || data.localDate !== todayLocalDate)) {
          console.warn('Zone Check telemetry is stale or missing localDate - treating as missing');
          data = null;
        } else if (data.localDate && data.localDate !== todayLocalDate) {
          console.warn('Zone Check telemetry is stale (not from today) - treating as missing');
          data = null;
        }
      }

      // Process data if found
      if (data) {
        setZoneCheckData(data);

        // Map post-breath mode to internal state format
        const modeToStateMap = {
          'Subcritical (flat/demotivated)': 'subcritical',
          'Subcritical': 'subcritical',

          'Œ®-band (in the zone)': 'psi',
          'Œ®-band': 'psi',
          'In the zone': 'psi',

          'Supercritical: rigid control': 'super_rigid',
          'Supercritical ‚Äì rigid control': 'super_rigid',
          'Supercritical - rigid': 'super_rigid',

          'Supercritical: scattered explore': 'super_scattered',
          'Supercritical ‚Äì explore': 'super_scattered',
          'Supercritical - scattered': 'super_scattered',

          'Supercritical: overloaded': 'super_scattered', // new zone_v1 hot label
          'Supercritical - scattered explore': 'super_scattered',

          'Depleted overload': 'super_scattered',

          'Mixed / unclear': 'mixed',
          'Not sure': 'mixed'
        };

        const mappedState = modeToStateMap[data.postBreathMode] || 'mixed';
        setPostBreathState(mappedState);

        // IMPORTANT: no hard "blocked" anymore.
        // If sessions === 0, we still allow a light session path downstream.
        // The UI can display "light session recommended" based on dose.level or gate.recommendation.
        console.log(`${data.dose?.level || 'unknown'} dose detected - ${data.dose?.sessions ?? 1} session(s) allowed`);

        // Skip post-breath screen if we have telemetry
        setScreen('eligibility');
      } else {
        console.log('No Zone Check data found - user can start fresh with post-breath screen');
      }
    }, []); // run once on mount

    const settingsFor = (planType, changeSelection = 'none') => {
      switch (planType) {
        case 'anchor_light':
        case 'anchor_stabilise':
        case 'anchor_consolidate':
        case 'swap_variant':
          return { speed: false, interference: false, handSwitch: false };
        case 'anchor_build':
          if (changeSelection === 'speed') return { speed: true, interference: false, handSwitch: false };
          if (changeSelection === 'interference') return { speed: false, interference: true, handSwitch: false };
          return { speed: false, interference: false, handSwitch: false };
        case 'anchor_probe':
          if (changeSelection === 'interference') return { speed: false, interference: true, handSwitch: false };
          if (changeSelection === 'hand') return { speed: false, interference: false, handSwitch: true };
          if (changeSelection === 'speed') return { speed: true, interference: false, handSwitch: false };
          return { speed: false, interference: false, handSwitch: false };
        default:
          return { speed: false, interference: false, handSwitch: false };
      }
    };

    const getTrainingFocus = (settings) => {
      if (settings.interference) return "Shield (interference resistance)";
      if (settings.speed) return "Hold (under pace)";
      if (settings.handSwitch) return "Clear (rule remapping)";
      return "Recover (clean stability)";
    };

    const goToRecommendation = (r) => {
      setRecommendation(r);
      setSelectedChange('none');
      setSwapChoice(null);
      setSwapStrategy(null);
      setScreen('recommendation');
    };

const buildOperatorUrl = (unitNumber, ctx) => {
  const baseUrl = getUnitUrl(unitNumber);

  try {
    const url = new URL(baseUrl);

    // Core context
    url.searchParams.set('schema', ctx.schemaVersion || 'unit_ctx_v1');
    url.searchParams.set('unit', String(unitNumber));
    url.searchParams.set('round', String(ctx.round || getRoundForUnit(unitNumber)));

    // Game context
    url.searchParams.set('focus', ctx.focus || '');
    url.searchParams.set('plan', ctx.plan || '');
    url.searchParams.set('game', ctx.game || '');

    // Settings
    url.searchParams.set('speed', ctx.settings?.speed ? '1' : '0');
    url.searchParams.set('interference', ctx.settings?.interference ? '1' : '0');
    url.searchParams.set('hand', ctx.settings?.handSwitch ? '1' : '0');

    // State
    if (ctx.zone) url.searchParams.set('zone', ctx.zone);
    if (ctx.strategy) url.searchParams.set('strategy', ctx.strategy);

    // Bridge notes (keep short)
    if (ctx.obs) url.searchParams.set('obs', String(ctx.obs).slice(0, 280));
    if (ctx.move) url.searchParams.set('move', String(ctx.move).slice(0, 280));

    // Session counts
    url.searchParams.set('sessionsCompleted', String(ctx.sessionsCompleted ?? 0));
    url.searchParams.set('totalSessions', String(ctx.totalSessions ?? 1));

    // Capacity focus handoff
    if (ctx.capId) url.searchParams.set('capId', ctx.capId);
    if (ctx.capLabel) url.searchParams.set('capLabel', ctx.capLabel);
    if (ctx.capDef) url.searchParams.set('capDef', ctx.capDef);
    if (ctx.capMatch) url.searchParams.set('capMatch', ctx.capMatch);

    // Unit targets
    if (ctx.unitPrimaryCap) url.searchParams.set('unitPrimaryCap', ctx.unitPrimaryCap);
    if (ctx.unitSecondaryCap) url.searchParams.set('unitSecondaryCap', ctx.unitSecondaryCap);

    // Return URL (optional, but if you want it, it must be *inside* this try)
    url.searchParams.set('return', window.location.href);

    return url.toString();
  } catch (e) {
    console.warn('buildOperatorUrl failed, falling back to baseUrl', e);
    return baseUrl;
  }
};


// -------------------------------
// calcRec / names / recipes / swapGames (UNCHANGED)
// -------------------------------
const calcRec = () => {
  const zone = postBreathState;
  if (trained3 === 'no') {
    return {
      planType: zone === 'psi' ? 'anchor_light' : 'anchor_stabilise',
      game: 'anchor_noncat',
      wheelAdvances: true
    };
  }

  const stalled =
    (progress === 'plateau' || progress === 'unsure') &&
    click === 'no' &&
    spikeGap === 'long' &&
    robustness !== 'improved';

  const unstableOrFlat =
    zone === 'subcritical' || zone === 'super_rigid' || zone === 'super_scattered';

  if (unstableOrFlat && stalled) {
    return { planType: 'swap_variant', game: 'classic', wheelAdvances: false };
  }

  if (zone !== 'psi') {
    return { planType: 'anchor_stabilise', game: 'anchor_noncat', wheelAdvances: true };
  }

  if (click === 'yes') return { planType: 'anchor_consolidate', game: 'anchor_noncat', wheelAdvances: true };

  if ((deploy === 'yes' || deploy === 'somewhat') && robustness !== 'worse') {
    return { planType: 'anchor_consolidate', game: 'anchor_noncat', wheelAdvances: true };
  }

  if (routine === 'very' && (progress === 'unsure' || progress === 'plateau') && robustness !== 'improved') {
    let game = 'classic';
    if (breaksFirst === 'rule_mapping') game = 'logic_gated';
    else if (breaksFirst === 'emotional') game = 'emotional';
    return { planType: 'swap_variant', game, wheelAdvances: false };
  }

  if (progress === 'plateau' && (robustness === 'same' || robustness === 'worse')) {
    return { planType: routine === 'somewhat' || routine === 'very' ? 'anchor_probe' : 'anchor_build', game: 'anchor_noncat', wheelAdvances: true };
  }

  return { planType: 'anchor_build', game: 'anchor_noncat', wheelAdvances: true };
};

const names = {
  anchor_light: "Anchor session (light)",
  anchor_stabilise: "Anchor session (wheel step)",
  anchor_build: "Anchor session (wheel step)",
  anchor_probe: "Anchor session (probe)",
  anchor_consolidate: "Anchor session (consolidate)",
  swap_variant: "Swap session (variant today)"
};

const recipes = {
  anchor_light: "Keep it simple today: play the Anchor with default settings. Keep the wrapper stable. Aim for a clean run.",
  anchor_stabilise: "Keep it clean and stable. No speed shifts, no interference, no switching.",
  anchor_build: "Anchor only. Keep it mostly stable. Add ONE mild change today: either 1 slightly faster block OR 1 slightly higher-interference block. Don't stack changes.",
  anchor_probe: "Probe day: if you feel stable, select Interference ON below and add 1‚Äì2 interference blocks. Otherwise keep it clean and stable.",
  anchor_consolidate: "Anchor only. Stable wrapper. Minimal interference. No speed shifts. No switching. Repeat yesterday's approach and keep it clean.",
  swap_variant: "Play one Swap game today instead of the Anchor. Keep settings stable. Tomorrow, return to the Anchor for a rebound test."
};

const swapGames = [
  { id: 'classic', title: 'Classic (tempo / dual-load)', bestWhen: 'Best when you fall behind, start guessing, or one stream drops out.', strategies: ['comprehension', 'strategic_action'] },
  { id: 'logic_gated', title: 'Logic-gated (rule discipline)', bestWhen: 'Best when rule/mapping changes break you, or switching causes confusion.', strategies: ['argumentation'] },
  { id: 'emotional', title: 'Emotional (salience control)', bestWhen: 'Best when distraction, rumination, or affect hijacks attention.', strategies: ['mental_attitude', 'decision_making'] }
];

// Render nothing initially while React is setting up
if (!screen) return null;

// -------------------------------
// SPLASH SCREEN (unchanged)
// -------------------------------
if (showSplash) {
  return (
    <div style={{
      minHeight: '100vh',
      background: '#E0E0E0',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: '24px',
      fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
    }}>
      <div style={{
        width: 'min(560px, 100%)',
        background: '#FFFFFF',
        borderRadius: '12px',
        padding: '28px 24px',
        boxShadow: '0 10px 15px -3px rgba(0,0,0,0.12)',
        textAlign: 'center'
      }}>
        <img
          src={brand.logoSrc}
          alt="Trident logo"
          style={{
            width: '96px',
            height: '96px',
            margin: '0 auto 16px',
            objectFit: 'contain'
          }}
          onError={(e) => { e.target.style.display = 'none'; }}
        />
        <div style={{
          fontSize: '28px',
          fontWeight: '900',
          color: '#333333',
          marginBottom: '8px'
        }}>
          {brand.appName}
        </div>
        <div style={{
          fontSize: '14px',
          fontWeight: '600',
          color: '#6D6D6D',
          marginBottom: '20px',
          lineHeight: '1.4'
        }}>
          {brand.subtitle}
        </div>
        <button
          onClick={() => setShowSplash(false)}
          style={{
            width: '100%',
            padding: '12px 14px',
            borderRadius: '12px',
            border: 'none',
            background: brand.accent,
            color: '#FFFFFF',
            fontSize: '16px',
            fontWeight: '900',
            cursor: 'pointer'
          }}
          onMouseEnter={(e) => e.currentTarget.style.filter = 'brightness(0.9)'}
          onMouseLeave={(e) => e.currentTarget.style.filter = 'none'}
        >
          Continue
        </button>
        <div style={{
          marginTop: '16px',
          fontSize: '12px',
          color: '#6D6D6D'
        }}>
          Mindware Lab ‚Ä¢ Trident
        </div>
      </div>
    </div>
  );
}

// -------------------------------
// SCREEN: Light-only (replaces previous "blocked" screen)
// -------------------------------
if (screen === 'blocked') {
  const stateLabel = zoneCheckData?.postBreathMode || 'Mixed / unclear';
  const recText =
    zoneCheckData?.dose?.recommendation ||
    "Today looks like a recovery day. If you train, keep it to one light, clean session.";

  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-2xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <div className="text-center mb-6">
            <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>üü°</div>
            <h1 className="text-3xl font-bold mb-4" style={{ color: '#333333' }}>
              Light session only today
            </h1>
            <p className="mb-4" style={{ color: '#6D6D6D' }}>
              Your Zone Check suggests you‚Äôre out of band for ‚Äúhard‚Äù training. If you do anything, keep it gentle and clean.
            </p>
          </div>

          <div className="p-4 rounded-lg mb-6" style={{ backgroundColor: '#FFF6E6', border: '2px solid #FFB84D' }}>
            <p className="font-semibold mb-2" style={{ color: '#333333' }}>Your state:</p>
            <p className="mb-3" style={{ color: '#333333' }}>
              Post-breathing: <strong>{stateLabel}</strong>
            </p>
            <p className="font-semibold mb-2" style={{ color: '#333333' }}>Recommendation:</p>
            <p className="text-sm" style={{ color: '#333333' }}>{recText}</p>
          </div>

          <div className="p-4 rounded-lg mb-6" style={{ backgroundColor: '#F5F5F5' }}>
            <p className="font-semibold mb-2" style={{ color: '#333333' }}>What ‚Äúlight‚Äù means:</p>
            <ul className="text-sm space-y-2" style={{ color: '#333333' }}>
              <li>‚Ä¢ One short session only</li>
              <li>‚Ä¢ Default settings, no probes, no swaps</li>
              <li>‚Ä¢ Aim for calm accuracy, not pushing speed</li>
            </ul>
          </div>

          <button
            onClick={() => {
              // Force a light anchor recommendation and continue normally
              setTrained3('no');
              setRecommendation({ planType: 'anchor_light', game: 'anchor_noncat', wheelAdvances: true });
              setSelectedChange('none');
              setSwapChoice(null);
              setSwapStrategy(null);
              setScreen('recommendation');
            }}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all shadow-md mb-3"
            style={{ backgroundColor: '#2764B7', color: '#FFFFFF' }}
          >
            Proceed with one light session
          </button>

          <button
            onClick={() => setScreen('afterTraining')}
            className="w-full py-3 px-6 rounded-lg font-semibold border-2 transition-all"
            style={{ borderColor: '#2764B7', color: '#2764B7', backgroundColor: '#FFFFFF' }}
          >
            Call it a day
          </button>
        </div>
      </div>
    </div>
  );
}

// -------------------------------
// SCREEN: Unit Wheel (UPDATED settings source)
// -------------------------------
if (screen === 'unitWheel') {
  const gameId = recommendation?.game || 'anchor_noncat'; // wrapper actually played
  const settings = settingsFor(recommendation?.planType || 'anchor_stabilise', selectedChange);
  const bridgeComplete = bridgeObs.trim() && bridgeMove.trim();

  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-3xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <h1 className="text-3xl font-bold mb-4" style={{ color: '#333333' }}>
            Choose Your Mindware Unit
          </h1>
          <p className="mb-6" style={{ color: '#6D6D6D' }}>
            Since you did a swap game today, select which mindware unit you‚Äôd like to practise:
          </p>

          <div className="grid grid-cols-2 sm:grid-cols-4 gap-3 mb-6">
            {Array.from({ length: 20 }, (_, i) => i + 1).map((unit) => {
              const isCompleted = userProgress.unitsCompleted.includes(unit);

              return (
                <button
                  key={unit}
                  disabled={!bridgeComplete}
                  onClick={() => {
                    if (!bridgeComplete) {
                      alert('Please complete the spike-capture bridge first');
                      return;
                    }

                    const unitTargets = getUnitTargets(unit);
                    const cap = pickCapacityPack({ unitNumber: unit, gameId, settings });

                    persistCapacityHandoff({
                      localDate: localYYYYMMDD(),
                      timestamp: Date.now(),
                      unitNumber: unit,
                      unitTitle: UNIT_METADATA[unit]?.title || '',
                      planType: recommendation?.planType || '',
                      gameId,
                      settings,
                      zone: postBreathState,
                      swapStrategy: swapStrategy || '',
                      capacity: {
                        id: cap.id,
                        label: cap.label,
                        def: cap.def,
                        match: cap.match,
                        unitPrimary: unitTargets.primary,
                        unitSecondary: unitTargets.secondary
                      }
                    });

                    const unitCtx = makeUnitContextFor(unit, gameId, settings);
                    const unitUrl = buildOperatorUrl(unit, unitCtx);
                    window.location.href = unitUrl;
                  }}
                  className="p-4 rounded-lg border-2 font-semibold transition-all"
                  style={{
                    borderColor: isCompleted ? '#CCFF66' : '#E0E0E0',
                    backgroundColor: isCompleted ? '#F5FFE6' : '#FFFFFF',
                    color: '#333333',
                    opacity: bridgeComplete ? 1 : 0.6,
                    cursor: bridgeComplete ? 'pointer' : 'not-allowed'
                  }}
                >
                  Unit {unit}
                  {isCompleted && (
                    <div className="text-xs mt-1" style={{ color: '#6D6D6D' }}>
                      ‚úì Complete
                    </div>
                  )}
                </button>
              );
            })}
          </div>

          <button
            onClick={() => setScreen('afterTraining')}
            className="w-full py-3 px-6 rounded-lg font-semibold border-2 transition-all"
            style={{ borderColor: '#2764B7', color: '#2764B7', backgroundColor: '#FFFFFF' }}
          >
            Back
          </button>
        </div>
      </div>
    </div>
  );
}

// SCREEN: Post-Breath
if (screen === 'postBreath') {
  const states = [
    { id: 'subcritical', label: 'Subcritical (flat/demotivated)', color: '#22AAFF' },
    { id: 'psi', label: 'Œ®-band (in the zone)', color: '#CCFF66' },
    { id: 'super_rigid', label: 'Supercritical: rigid control', color: '#FFB020' },
    { id: 'super_scattered', label: 'Supercritical: scattered explore', color: '#B07CFF' },
    { id: 'mixed', label: 'Mixed / unclear', color: '#6D6D6D' }
  ];

  // If the user didn‚Äôt come from Zone Coach, create a minimal ‚Äúdose‚Äù so downstream logic is consistent.
  const stateToModeLabel = {
    subcritical: 'Subcritical (flat/demotivated)',
    psi: 'Œ®-band (in the zone)',
    super_rigid: 'Supercritical: rigid control',
    super_scattered: 'Supercritical: scattered explore',
    mixed: 'Mixed / unclear'
  };

  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-2xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <h1 className="text-3xl font-bold mb-2" style={{ color: '#333333' }}>How do you feel now?</h1>
          <p className="mb-6" style={{ color: '#6D6D6D' }}>
            You‚Äôve completed 3 minutes of breathing. Where are you at now?
          </p>

          <div className="space-y-3 mb-6">
            {states.map(s => (
              <button
                key={s.id}
                onClick={() => setPostBreathState(s.id)}
                className="w-full p-4 rounded-lg border-2 font-semibold text-left transition-all"
                style={{
                  borderColor: postBreathState === s.id ? s.color : '#E0E0E0',
                  backgroundColor: postBreathState === s.id ? `${s.color}20` : '#FFFFFF',
                  color: '#333333'
                }}
              >
                {s.label}
              </button>
            ))}
          </div>

          <p className="text-sm mb-6" style={{ color: '#6D6D6D' }}>
            If you‚Äôre not sure, choose ‚ÄòMixed / unclear‚Äô.
          </p>

          <button
            onClick={() => {
              if (!postBreathState) return;

              // Create a fallback ‚Äúzone telemetry‚Äù so totalSessions etc are stable downstream
              if (!zoneCheckData) {
                const fallback = normaliseZoneTelemetry({
                  postBreathMode: stateToModeLabel[postBreathState] || 'Mixed / unclear',
                  dose: {
                    level: 'amber',
                    sessions: 1,
                    blocks: 1,
                    recommendation: 'Proceed with training.'
                  },
                  localDate: localYYYYMMDD(),
                  timestamp: Date.now()
                });
                setZoneCheckData(fallback);
              }

              setScreen('eligibility');
            }}
            disabled={!postBreathState}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all"
            style={{
              backgroundColor: postBreathState ? '#2764B7' : '#E0E0E0',
              color: postBreathState ? '#FFFFFF' : '#6D6D6D',
              cursor: postBreathState ? 'pointer' : 'not-allowed'
            }}
          >
            Continue
          </button>
        </div>
      </div>
    </div>
  );
}

// SCREEN: Eligibility
if (screen === 'eligibility') {
  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-2xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <h1 className="text-3xl font-bold mb-2" style={{ color: '#333333' }}>Quick check</h1>
          <p className="mb-6" style={{ color: '#6D6D6D' }}>Have you done at least 3 training sessions before today?</p>

          <div className="space-y-3 mb-6">
            {['yes', 'no'].map(opt => (
              <button
                key={opt}
                onClick={() => setTrained3(opt)}
                className="w-full p-4 rounded-lg border-2 font-semibold transition-all capitalize"
                style={{
                  borderColor: trained3 === opt ? '#2764B7' : '#E0E0E0',
                  backgroundColor: trained3 === opt ? '#E8F4FF' : '#FFFFFF',
                  color: '#333333'
                }}
              >
                {opt}
              </button>
            ))}
          </div>

          <p className="text-sm mb-6" style={{ color: '#6D6D6D' }}>
            If this is your first few sessions, we keep it simple.
          </p>

          <button
            onClick={() => {
              if (!trained3) return;
              if (trained3 === 'no') {
                goToRecommendation(calcRec());
              } else {
                setScreen('lastSessions');
              }
            }}
            disabled={!trained3}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all"
            style={{
              backgroundColor: trained3 ? '#2764B7' : '#E0E0E0',
              color: trained3 ? '#FFFFFF' : '#6D6D6D',
              cursor: trained3 ? 'pointer' : 'not-allowed'
            }}
          >
            Continue
          </button>
        </div>
      </div>
    </div>
  );
}

// SCREEN: Last Sessions
if (screen === 'lastSessions') {
  const canContinue = progress && routine && robustness && click && deploy && spikeGap;

  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-2xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <h1 className="text-3xl font-bold mb-2" style={{ color: '#333333' }}>Last 2‚Äì3 sessions</h1>
          <p className="mb-6" style={{ color: '#6D6D6D' }}>Answer quickly based on your last couple of sessions.</p>

          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>Did you make progress?</p>
            <div className="space-y-2">
              {[{ id: 'clear', label: 'Yes, clear progress' }, { id: 'unsure', label: 'A bit / unsure' }, { id: 'plateau', label: 'No, plateau' }].map(o => (
                <button
                  key={o.id}
                  onClick={() => setProgress(o.id)}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: progress === o.id ? '#2764B7' : '#E0E0E0',
                    backgroundColor: progress === o.id ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  {o.label}
                </button>
              ))}
            </div>
          </div>

          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>Did it feel routine and automatic?</p>
            <div className="space-y-2">
              {[{ id: 'not', label: 'Not really' }, { id: 'somewhat', label: 'Somewhat' }, { id: 'very', label: 'Very routine' }].map(o => (
                <button
                  key={o.id}
                  onClick={() => setRoutine(o.id)}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: routine === o.id ? '#2764B7' : '#E0E0E0',
                    backgroundColor: routine === o.id ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  {o.label}
                </button>
              ))}
            </div>
          </div>

          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>Did your performance hold up when you changed settings in the Anchor game?</p>
            <p className="text-sm mb-3" style={{ color: '#6D6D6D' }}>Changes = speed, interference, or hand/response mapping.</p>

            <div className="space-y-2">
              {[
                { id: 'improved', label: 'Improved' },
                { id: 'same', label: 'Same as usual' },
                { id: 'worse', label: 'Worse / fragile' },
                { id: 'not_tried', label: "Didn't try changes (kept it stable)" }
              ].map(o => (
                <button
                  key={o.id}
                  onClick={() => setRobustness(o.id)}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: robustness === o.id ? '#2764B7' : '#E0E0E0',
                    backgroundColor: robustness === o.id ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  {o.label}
                </button>
              ))}
            </div>
          </div>

          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>Did anything 'click' recently?</p>

            <div className="space-y-2 mb-3">
              <button
                onClick={() => { setClick('yes'); setShowClickInput(true); }}
                className="w-full p-3 rounded-lg border-2 text-left transition-all"
                style={{
                  borderColor: click === 'yes' ? '#2764B7' : '#E0E0E0',
                  backgroundColor: click === 'yes' ? '#E8F4FF' : '#FFFFFF',
                  color: '#333333'
                }}
              >
                Yes
              </button>

              <button
                onClick={() => { setClick('no'); setShowClickInput(false); setClickNote(''); }}
                className="w-full p-3 rounded-lg border-2 text-left transition-all"
                style={{
                  borderColor: click === 'no' ? '#2764B7' : '#E0E0E0',
                  backgroundColor: click === 'no' ? '#E8F4FF' : '#FFFFFF',
                  color: '#333333'
                }}
              >
                No
              </button>
            </div>

            {showClickInput && (
              <div className="p-4 rounded-lg" style={{ backgroundColor: '#F5F5F5' }}>
                <label className="block text-sm font-semibold mb-2" style={{ color: '#333333' }}>What changed? (one line)</label>
                <p className="text-xs mb-2" style={{ color: '#6D6D6D' }}>Keep it simple. What did you do differently?</p>

                <input
                  type="text"
                  value={clickNote}
                  onChange={(e) => setClickNote(e.target.value)}
                  placeholder="E.g., 'I slowed down', 'I stopped guessing'..."
                  className="w-full p-3 rounded border-2 mb-3"
                  style={{ borderColor: '#E0E0E0' }}
                />

                <div className="flex gap-2">
                  <button
                    onClick={() => setShowClickInput(false)}
                    className="flex-1 py-2 px-4 rounded-lg font-semibold"
                    style={{ backgroundColor: '#2764B7', color: '#FFFFFF' }}
                  >
                    Save and continue
                  </button>
                  <button
                    onClick={() => { setClickNote(''); setShowClickInput(false); }}
                    className="flex-1 py-2 px-4 rounded-lg font-semibold border-2"
                    style={{ borderColor: '#E0E0E0', color: '#333333', backgroundColor: '#FFFFFF' }}
                  >
                    Skip
                  </button>
                </div>
              </div>
            )}
          </div>

          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>Did your strategy help outside the game since your last session?</p>
            <div className="space-y-2">
              {[{ id: 'yes', label: 'Yes' }, { id: 'somewhat', label: 'Somewhat' }, { id: 'no', label: 'No' }, { id: 'didnt_try', label: "Didn't try" }].map(o => (
                <button
                  key={o.id}
                  onClick={() => setDeploy(o.id)}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: deploy === o.id ? '#2764B7' : '#E0E0E0',
                    backgroundColor: deploy === o.id ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  {o.label}
                </button>
              ))}
            </div>
          </div>

          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>
              When was your last step-change session?
            </p>
            <p className="text-sm mb-3" style={{ color: '#6D6D6D' }}>
              A step-change = a clear jump, a ‚Äòclick‚Äô, or holding up much better under changes.
            </p>

            <div className="space-y-2">
              {[
                { id: 'recent', label: 'In the last 1‚Äì2 sessions' },
                { id: 'mid', label: 'About 3‚Äì4 sessions ago' },
                { id: 'long', label: "Not recently / can't remember" }
              ].map(o => (
                <button
                  key={o.id}
                  onClick={() => setSpikeGap(o.id)}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: spikeGap === o.id ? '#2764B7' : '#E0E0E0',
                    backgroundColor: spikeGap === o.id ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  {o.label}
                </button>
              ))}
            </div>
          </div>

          <button
            onClick={() => {
              if (!canContinue) return;
              const r = calcRec();

              if (r.planType === 'swap_variant' && postBreathState === 'psi' && !breaksFirst) {
                setBreaksFirst(null);
                setSwapChoice(null);
                setSwapStrategy(null);
                setSelectedChange('none');
                setScreen('breakdown');
              } else {
                goToRecommendation(r);
              }
            }}
            disabled={!canContinue}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all"
            style={{
              backgroundColor: canContinue ? '#2764B7' : '#E0E0E0',
              color: canContinue ? '#FFFFFF' : '#6D6D6D',
              cursor: canContinue ? 'pointer' : 'not-allowed'
            }}
          >
            Get my plan
          </button>
        </div>
      </div>
    </div>
  );
}

// SCREEN: Breakdown
if (screen === 'breakdown') {
  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-2xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <h1 className="text-3xl font-bold mb-2" style={{ color: '#333333' }}>One more thing</h1>
          <p className="mb-6" style={{ color: '#6D6D6D' }}>When things break down, what breaks first?</p>

          <div className="space-y-3 mb-6">
            {[
              { id: 'tempo', label: 'Keeping up (tempo / speed)' },
              { id: 'rule_mapping', label: 'Rules or mapping (I get confused)' },
              { id: 'emotional', label: 'Emotional pull (rumination / distraction)' },
              { id: 'not_sure', label: 'Not sure' }
            ].map(o => (
              <button
                key={o.id}
                onClick={() => setBreaksFirst(o.id)}
                className="w-full p-4 rounded-lg border-2 font-semibold text-left transition-all"
                style={{
                  borderColor: breaksFirst === o.id ? '#2764B7' : '#E0E0E0',
                  backgroundColor: breaksFirst === o.id ? '#E8F4FF' : '#FFFFFF',
                  color: '#333333'
                }}
              >
                {o.label}
              </button>
            ))}
          </div>

          <button
            onClick={() => {
              if (!breaksFirst) return;
              goToRecommendation(calcRec());
            }}
            disabled={!breaksFirst}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all"
            style={{
              backgroundColor: breaksFirst ? '#2764B7' : '#E0E0E0',
              color: breaksFirst ? '#FFFFFF' : '#6D6D6D',
              cursor: breaksFirst ? 'pointer' : 'not-allowed'
            }}
          >
            Show my plan
          </button>
        </div>
      </div>
    </div>
  );
}

// SCREEN: Recommendation
if (screen === 'recommendation' && recommendation) {
  const isSwap = recommendation.planType === 'swap_variant';
  const finalGame = swapChoice || recommendation.game;

  // Always derive settings from planType + selectedChange (canonical)
  const settings = settingsFor(recommendation.planType, selectedChange);

  const targetUnit = userProgress.currentUnit; // next anchor unit (wheel)
  const unitTargets = getUnitTargets(targetUnit);

  const capacityPack = pickCapacityPack({
    unitNumber: targetUnit,
    gameId: finalGame,     // 'anchor_noncat' | 'classic' | 'logic_gated' | 'emotional'
    settings
  });

  const gameUrl = getGameUrl(isSwap, finalGame);

  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-3xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <h1 className="text-3xl font-bold mb-4" style={{ color: '#333333' }}>Today‚Äôs plan</h1>

          <div className="p-4 rounded-lg mb-6" style={{ backgroundColor: '#E8F4FF', border: '2px solid #2764B7' }}>
            <p className="font-semibold" style={{ color: '#333333' }}>
              Keep this page open. When you finish training, come back here for a 20-second wrap-up.
            </p>
          </div>

          <h2 className="text-2xl font-bold mb-6" style={{ color: '#2764B7' }}>
            {names[recommendation.planType]}
          </h2>

          <div className="mb-6 p-4 rounded-lg" style={{ backgroundColor: '#F5F5F5' }}>
            <p className="font-semibold" style={{ color: '#333333' }}>
              {recommendation.wheelAdvances
                ? 'This counts towards your 20 Anchor sessions and advances the wheel.'
                : 'This does NOT advance the wheel. Next session returns to the Anchor and repeats the same wheel unit.'}
            </p>
          </div>

          <div className="mb-6">
            <h3 className="font-bold mb-2" style={{ color: '#333333' }}>What to play</h3>
            <p className="mb-2" style={{ color: '#333333' }}>
              {isSwap
                ? 'Play today: Choose a Swap game below (recommended highlighted).'
                : 'Play today: Non-categorical dual n-back (Anchor).'}
            </p>
            <p className="text-sm" style={{ color: '#6D6D6D' }}>
              Keep settings stable today. The point is a clean probe, not maximum difficulty.
            </p>
          </div>

          <div className="p-4 rounded-lg mb-6" style={{ backgroundColor: '#F5F5F5' }}>
            <h3 className="font-bold mb-2" style={{ color: '#333333' }}>Today‚Äôs training focus</h3>
            <p style={{ color: '#333333' }}>
              You‚Äôre training: <b>{capacityPack.label}</b>
            </p>
            <p className="text-sm mt-1" style={{ color: '#6D6D6D' }}>
              {capacityPack.def}
            </p>
            <p className="text-sm mt-3" style={{ color: '#333333' }}>
              Next, you‚Äôll use it in <b>Unit {targetUnit}</b>: {UNIT_METADATA[targetUnit]?.title || 'Mindware practice'}.
            </p>
            <p className="text-sm mt-1" style={{ color: '#6D6D6D' }}>
              {unitTargets.useLine}
            </p>
          </div>

          <div className="mb-6 p-4 rounded-lg" style={{ backgroundColor: '#F5FFE6', border: '1px solid #CCFF66' }}>
            <p style={{ color: '#333333' }}>{recipes[recommendation.planType]}</p>
            {isSwap && (
              <p className="mt-2 font-semibold" style={{ color: '#333333' }}>
                Swap sessions are usually just one day. Tomorrow‚Äôs Anchor session is where we check if it helped.
              </p>
            )}
          </div>

          <div className="p-4 rounded-lg mb-6" style={{ backgroundColor: '#F5F5F5' }}>
            <h3 className="font-bold mb-3" style={{ color: '#333333' }}>Today‚Äôs settings</h3>
            <p className="text-sm mb-3" style={{ color: '#6D6D6D' }}>
              Change at most ONE thing today. Clean runs beat ‚Äúhard‚Äù runs.
            </p>
            <ul className="space-y-2" style={{ color: '#333333' }}>
              <li><b>Speed (double pace):</b> {settings.speed ? 'ON' : 'OFF'}</li>
              <li><b>Interference / lures:</b> {settings.interference ? 'ON' : 'OFF'}</li>
              <li><b>Hand/response switching:</b> {settings.handSwitch ? 'ON' : 'OFF'}</li>
            </ul>
          </div>

          {(recommendation.planType === 'anchor_build' || recommendation.planType === 'anchor_probe') && (
            <div className="mb-6 p-4 rounded-lg" style={{ backgroundColor: '#FFF9E6', border: '1px solid #FFD700' }}>
              <p className="font-semibold mb-3" style={{ color: '#333333' }}>Choose today‚Äôs ONE change:</p>

              <div className="space-y-2">
                <button
                  onClick={() => setSelectedChange('none')}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: selectedChange === 'none' ? '#2764B7' : '#E0E0E0',
                    backgroundColor: selectedChange === 'none' ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  No change (clean stability)
                </button>

                {recommendation.planType === 'anchor_build' && (
                  <>
                    <button
                      onClick={() => setSelectedChange('interference')}
                      className="w-full p-3 rounded-lg border-2 text-left transition-all"
                      style={{
                        borderColor: selectedChange === 'interference' ? '#2764B7' : '#E0E0E0',
                        backgroundColor: selectedChange === 'interference' ? '#E8F4FF' : '#FFFFFF',
                        color: '#333333'
                      }}
                    >
                      Interference ON (recommended)
                    </button>

                    <button
                      onClick={() => setSelectedChange('speed')}
                      className="w-full p-3 rounded-lg border-2 text-left transition-all"
                      style={{
                        borderColor: selectedChange === 'speed' ? '#2764B7' : '#E0E0E0',
                        backgroundColor: selectedChange === 'speed' ? '#E8F4FF' : '#FFFFFF',
                        color: '#333333'
                      }}
                    >
                      Speed ON
                    </button>
                  </>
                )}

                {recommendation.planType === 'anchor_probe' && (
                  <>
                    <button
                      onClick={() => setSelectedChange('interference')}
                      className="w-full p-3 rounded-lg border-2 text-left transition-all"
                      style={{
                        borderColor: selectedChange === 'interference' ? '#2764B7' : '#E0E0E0',
                        backgroundColor: selectedChange === 'interference' ? '#E8F4FF' : '#FFFFFF',
                        color: '#333333'
                      }}
                    >
                      Interference ON (recommended)
                    </button>

                    <button
                      onClick={() => setSelectedChange('hand')}
                      className="w-full p-3 rounded-lg border-2 text-left transition-all"
                      style={{
                        borderColor: selectedChange === 'hand' ? '#2764B7' : '#E0E0E0',
                        backgroundColor: selectedChange === 'hand' ? '#E8F4FF' : '#FFFFFF',
                        color: '#333333'
                      }}
                    >
                      Hand/response switching ON
                    </button>

                    <button
                      onClick={() => setSelectedChange('speed')}
                      className="w-full p-3 rounded-lg border-2 text-left transition-all"
                      style={{
                        borderColor: selectedChange === 'speed' ? '#2764B7' : '#E0E0E0',
                        backgroundColor: selectedChange === 'speed' ? '#E8F4FF' : '#FFFFFF',
                        color: '#333333'
                      }}
                    >
                      Speed ON
                    </button>
                  </>
                )}
              </div>
            </div>
          )}

          {isSwap && (
            <div className="mb-6">
              <p className="font-semibold mb-4" style={{ color: '#333333' }}>
                Recommended: {recommendation.game === 'classic' ? 'Classic' : recommendation.game === 'logic_gated' ? 'Logic-gated' : 'Emotional'}
              </p>
              <p className="text-sm mb-4" style={{ color: '#6D6D6D' }}>
                You can follow the recommendation, or choose a different swap game below.
              </p>

              <div className="space-y-3">
                {swapGames.map(g => (
                  <div
                    key={g.id}
                    onClick={() => { setSwapChoice(g.id); setSwapStrategy(null); }}
                    className="p-4 rounded-lg border-2 cursor-pointer transition-all"
                    style={{
                      borderColor: finalGame === g.id ? '#2764B7' : '#E0E0E0',
                      backgroundColor: finalGame === g.id ? '#E8F4FF' : '#FFFFFF'
                    }}
                  >
                    <p className="font-bold mb-1" style={{ color: '#333333' }}>
                      {g.title}{' '}
                      {recommendation.game === g.id && !swapChoice && <span style={{ color: '#2764B7' }}>(Recommended)</span>}
                    </p>
                    <p className="text-sm mb-2" style={{ color: '#6D6D6D' }}>{g.bestWhen}</p>

                    <div className="flex gap-2 mt-2">
                      {g.strategies.map(s => (
                        <button
                          key={s}
                          onClick={(e) => { e.stopPropagation(); setSwapChoice(g.id); setSwapStrategy(s); }}
                          className="px-3 py-1 rounded text-sm border-2 transition-all"
                          style={{
                            borderColor: swapStrategy === s && finalGame === g.id ? '#2764B7' : '#E0E0E0',
                            backgroundColor: swapStrategy === s && finalGame === g.id ? '#2764B7' : '#FFFFFF',
                            color: swapStrategy === s && finalGame === g.id ? '#FFFFFF' : '#333333'
                          }}
                        >
                          {s.replace(/_/g, ' ')}
                        </button>
                      ))}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          <button
            onClick={() => {
              // Persist for analysis + continuity
              persistLastGameSelection({
                localDate: localYYYYMMDD(),
                timestamp: Date.now(),
                unitTarget: userProgress.currentUnit,
                planType: recommendation.planType,
                gameId: finalGame,
                settings,
                capacity: {
                  id: capacityPack.id,
                  label: capacityPack.label,
                  def: capacityPack.def,
                  match: capacityPack.match,
                  unitPrimary: unitTargets.primary,
                  unitSecondary: unitTargets.secondary
                }
              });

              // Save a restore snapshot so we can resume smoothly after unit completion / reloads
              try {
                sessionStorage.setItem('lastPlanState', JSON.stringify({
                  postBreathState,
                  trained3,
                  progress,
                  routine,
                  robustness,
                  click,
                  clickNote,
                  deploy,
                  spikeGap,
                  breaksFirst,
                  selectedChange,
                  swapChoice,
                  swapStrategy,
                  recommendation: { ...recommendation, game: finalGame, settings }
                }));
              } catch {}

              window.open(gameUrl, '_blank', 'noopener,noreferrer');
            }}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all shadow-md mb-3"
            style={{ backgroundColor: '#2764B7', color: '#FFFFFF' }}
          >
            Open today‚Äôs game (new tab)
          </button>

          <button
            onClick={() => {
              // Freeze finalGame + finalSettings into recommendation for the downstream bridge + unit launch
              const finalGameValue = finalGame;
              const finalSettings = settings;

              setRecommendation({ ...recommendation, game: finalGameValue, settings: finalSettings });
              setScreen('afterTraining');

              // Save restore snapshot (same shape as above)
              try {
                sessionStorage.setItem('lastPlanState', JSON.stringify({
                  postBreathState,
                  trained3,
                  progress,
                  routine,
                  robustness,
                  click,
                  clickNote,
                  deploy,
                  spikeGap,
                  breaksFirst,
                  selectedChange,
                  swapChoice,
                  swapStrategy,
                  recommendation: { ...recommendation, game: finalGameValue, settings: finalSettings }
                }));
              } catch {}
            }}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all"
            style={{ backgroundColor: '#FFFFFF', color: '#2764B7', border: '2px solid #2764B7' }}
          >
            I‚Äôve finished the game ‚Äî do the 20-second bridge
          </button>
        </div>
      </div>
    </div>
  );
}
// SCREEN: After Training
if (screen === 'afterTraining') {
  const settings = recommendation?.settings || { speed: false, interference: false, handSwitch: false };
  const totalSessionsToday = zoneCheckData?.dose?.sessions || 1;

  // Wheel unit is only ‚Äúthe next unit‚Äù when today‚Äôs game was the Anchor.
  // For swap sessions we show ‚ÄúChoose Mindware Unit‚Äù and let UnitWheel handle selection.
  const currentUnit = userProgress.currentUnit;

  const isAnchorSession = (recommendation?.game || '') === 'anchor_noncat';

  // Capacity highlight for THIS screen: tie to the wrapper actually played
  const capacityPack = pickCapacityPack({
    unitNumber: currentUnit,
    gameId: recommendation?.game || 'anchor_noncat',
    settings
  });
  const trainingFocus = capacityPack.label;

  const unitInfo =
    UNIT_METADATA[currentUnit] || { title: 'Mindware Practice', category: 'Mindware', time: '‚â§10 min' };

  const copyBridgeToClipboard = () => {
    const bridgeText =
      `Today I trained: ${trainingFocus}. ` +
      `In the game it looked like: ${bridgeObs}. ` +
      `In the next task I will use it by: ${bridgeMove}.`;

    navigator.clipboard
      .writeText(bridgeText)
      .then(() => alert('Bridge copied to clipboard!'))
      .catch((err) => console.error('Failed to copy:', err));
  };

  const bridgeComplete = bridgeObs.trim() && bridgeMove.trim();

  return (
    <div className="min-h-screen p-4 md:p-8" style={{ backgroundColor: '#E0E0E0' }}>
      <div className="max-w-2xl mx-auto">
        <div className="rounded-lg shadow-lg p-6 md:p-8" style={{ backgroundColor: '#FFFFFF' }}>
          <h1 className="text-3xl font-bold mb-2" style={{ color: '#333333' }}>
            Spike-capture bridge
          </h1>
          <p className="mb-6" style={{ color: '#6D6D6D' }}>
            20 seconds to lock in what you just trained.
          </p>

          {/* Visual indicator for multi-session flow */}
          {sessionsCompletedToday > 0 && (
            <div
              className="p-4 rounded-lg mb-6"
              style={{ backgroundColor: '#E8F4FF', border: '2px solid #2764B7' }}
            >
              <p className="font-semibold" style={{ color: '#333333' }}>
                ‚úì Session {sessionsCompletedToday} complete!
              </p>
              <p className="text-sm" style={{ color: '#6D6D6D' }}>
                Starting session {Math.min(sessionsCompletedToday + 1, totalSessionsToday)} of {totalSessionsToday}
              </p>
            </div>
          )}

          <div
            className="p-4 rounded-lg mb-6"
            style={{ backgroundColor: '#E8F4FF', border: '2px solid #2764B7' }}
          >
            <p className="font-semibold" style={{ color: '#333333' }}>
              Today I trained: <span style={{ color: '#2764B7' }}>{trainingFocus}</span>
            </p>

            <label className="block text-sm font-semibold mt-4 mb-2" style={{ color: '#333333' }}>
              In the game it looked like‚Ä¶ (one observation)
            </label>
            <input
              type="text"
              value={bridgeObs}
              onChange={(e) => setBridgeObs(e.target.value)}
              className="w-full p-3 rounded border-2"
              style={{ borderColor: '#E0E0E0' }}
              placeholder="E.g., 'I stopped guessing and waited for certainty'..."
            />

            <label className="block text-sm font-semibold mt-4 mb-2" style={{ color: '#333333' }}>
              In the next task I will use it by‚Ä¶ (one mindware move)
            </label>
            <input
              type="text"
              value={bridgeMove}
              onChange={(e) => setBridgeMove(e.target.value)}
              className="w-full p-3 rounded border-2 mb-4"
              style={{ borderColor: '#E0E0E0' }}
              placeholder="E.g., 'I‚Äôll write a 2-option trade-off table before deciding'..."
            />

            <div className="flex gap-2">
              <button
                onClick={copyBridgeToClipboard}
                disabled={!bridgeComplete}
                className="flex-1 py-2 px-4 rounded-lg font-semibold"
                style={{
                  backgroundColor: bridgeComplete ? '#22AAFF' : '#E0E0E0',
                  color: '#FFFFFF',
                  cursor: bridgeComplete ? 'pointer' : 'not-allowed'
                }}
              >
                Copy bridge
              </button>
            </div>
          </div>

          {/* Unit Exercise Section */}
          <div
            className="p-4 rounded-lg mb-6"
            style={{
              backgroundColor: isAnchorSession ? '#F5FFE6' : '#FFF3E0',
              border: `2px solid ${isAnchorSession ? '#CCFF66' : '#FFB020'}`
            }}
          >
            <p className="font-semibold mb-2" style={{ color: '#333333' }}>
              üìö Next: Mindware practice
            </p>

            {isAnchorSession ? (
              <>
                <p className="text-sm mb-1" style={{ color: '#333333' }}>
                  Complete Unit {currentUnit}: ‚Äú{unitInfo.title}‚Äù
                </p>
                <p className="text-sm mb-4" style={{ color: '#6D6D6D' }}>
                  {unitInfo.category} ‚Ä¢ {unitInfo.time} ‚Ä¢ Session{' '}
                  {Math.min(sessionsCompletedToday + 1, totalSessionsToday)} of {totalSessionsToday}
                </p>
              </>
            ) : (
              <>
                <p className="text-sm mb-3" style={{ color: '#333333' }}>
                  Choose a mindware unit to practise (manual selection)
                </p>
                <p className="text-sm mb-4" style={{ color: '#6D6D6D' }}>
                  Swap sessions don‚Äôt auto-advance the wheel.
                </p>
              </>
            )}

            <button
              onClick={() => {
                if (!bridgeComplete) {
                  alert('Please complete the spike-capture bridge first');
                  return;
                }

                // Record session ‚Äútype‚Äù for the completion handler
                try {
                  sessionStorage.setItem('currentSessionType', recommendation?.game || '');
                  sessionStorage.setItem('currentSessionTimestamp', String(Date.now()));
                } catch {}

                const unitTargets = getUnitTargets(currentUnit);

                // Persist capacity handoff (for unit app / analytics)
                persistCapacityHandoff({
                  localDate: localYYYYMMDD(),
                  timestamp: Date.now(),
                  unitNumber: currentUnit,
                  unitTitle: unitInfo.title,
                  planType: recommendation?.planType || '',
                  gameId: recommendation?.game || '',
                  settings,
                  zone: postBreathState,
                  swapStrategy: swapStrategy || '',
                  capacity: {
                    id: capacityPack.id,
                    label: capacityPack.label,
                    def: capacityPack.def,
                    match: capacityPack.match,
                    unitPrimary: unitTargets.primary,
                    unitSecondary: unitTargets.secondary
                  }
                });

                // Build unit context (used by buildOperatorUrl)
                const unitContext = {
                  // Unit app needs these
                  focus: trainingFocus,
                  plan: recommendation?.planType || '',
                  game: recommendation?.game || '',
                  settings,
                  zone: postBreathState,
                  strategy: swapStrategy || '',
                  obs: bridgeObs,
                  move: bridgeMove,
                  sessionsCompleted: sessionsCompletedToday,
                  totalSessions: totalSessionsToday,

                  // Capacity focus handoff (so Unit app can highlight the right skill)
                  capId: capacityPack.id,
                  capLabel: capacityPack.label,
                  capDef: capacityPack.def,
                  capMatch: capacityPack.match,

                  // Unit declared targets (Option B)
                  unitPrimaryCap: unitTargets.primary,
                  unitSecondaryCap: unitTargets.secondary
                };

                // Save restore snapshot for smooth return after unit completion / reload
                try {
                  sessionStorage.setItem(
                    'lastPlanState',
                    JSON.stringify({
                      postBreathState,
                      trained3,
                      progress,
                      routine,
                      robustness,
                      click,
                      clickNote,
                      deploy,
                      spikeGap,
                      breaksFirst,
                      selectedChange,
                      swapChoice,
                      swapStrategy,
                      recommendation: { ...recommendation, settings }
                    })
                  );
                } catch {}

                if (isAnchorSession) {
                  const unitUrl = buildOperatorUrl(currentUnit, unitContext);
                  window.location.href = unitUrl;
                } else {
                  // Swap sessions: go to Unit Wheel, and selection handler will persist + navigate
                  setScreen('unitWheel');
                }
              }}
              disabled={!bridgeComplete}
              className="w-full py-3 px-6 rounded-lg font-semibold transition-all"
              style={{
                backgroundColor: bridgeComplete ? '#2764B7' : '#E0E0E0',
                color: bridgeComplete ? '#FFFFFF' : '#6D6D6D',
                cursor: bridgeComplete ? 'pointer' : 'not-allowed'
              }}
            >
              {isAnchorSession ? `Start Unit ${currentUnit}` : 'Choose Mindware Unit'}
            </button>
          </div>

          {/* GPT Deployment Button */}
          <button
            onClick={() => window.open(GPT_URL, '_blank', 'noopener,noreferrer')}
            disabled={!bridgeComplete}
            className="w-full py-2 px-4 rounded-lg font-semibold border-2 mb-6"
            style={{
              borderColor: bridgeComplete ? '#2764B7' : '#E0E0E0',
              color: bridgeComplete ? '#2764B7' : '#6D6D6D',
              backgroundColor: '#FFFFFF',
              cursor: bridgeComplete ? 'pointer' : 'not-allowed'
            }}
          >
            Open real-world deployment (GPT)
          </button>

          {/* Reflection (unchanged) */}
          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>
              How did today‚Äôs session feel overall?
            </p>
            <div className="space-y-2">
              {[
                { id: 'smooth', label: 'Smooth and productive' },
                { id: 'ok', label: 'OK / mixed' },
                { id: 'struggle', label: 'Struggled / off' }
              ].map((opt) => (
                <button
                  key={opt.id}
                  onClick={() => setSessionFeel(opt.id)}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: sessionFeel === opt.id ? '#2764B7' : '#E0E0E0',
                    backgroundColor: sessionFeel === opt.id ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  {opt.label}
                </button>
              ))}
            </div>
          </div>

          <div className="mb-6">
            <p className="font-semibold mb-3" style={{ color: '#333333' }}>
              Did the n-back session carry over into the strategy practice?
            </p>
            <div className="space-y-2">
              {[
                { id: 'yes_clearer', label: 'Yes ‚Äî clearer thinking' },
                { id: 'yes_focus', label: 'Yes ‚Äî better focus / steadier' },
                { id: 'no_separate', label: 'No ‚Äî it felt separate today' },
                { id: 'no_practice', label: "I didn‚Äôt do the strategy practice" }
              ].map((opt) => (
                <button
                  key={opt.id}
                  onClick={() => setCarryOver(opt.id)}
                  className="w-full p-3 rounded-lg border-2 text-left transition-all"
                  style={{
                    borderColor: carryOver === opt.id ? '#2764B7' : '#E0E0E0',
                    backgroundColor: carryOver === opt.id ? '#E8F4FF' : '#FFFFFF',
                    color: '#333333'
                  }}
                >
                  {opt.label}
                </button>
              ))}
            </div>
            <p className="text-sm mt-2" style={{ color: '#6D6D6D' }}>
              Carry over = you could apply the mindware more cleanly right after training.
            </p>
          </div>

          <div className="p-4 rounded-lg mb-6" style={{ backgroundColor: '#FFF9E6', border: '1px solid #FFD700' }}>
            <p className="text-sm" style={{ color: '#333333' }}>
              üí° Before your next session, try the same mindware strategy once in real life. Think about the situation
              you might apply it in now, and what might cue it for you.
            </p>
          </div>

          {/* Progress Display */}
          <div className="p-4 rounded-lg mb-6" style={{ backgroundColor: '#F5F5F5' }}>
            <p className="text-sm font-semibold mb-2" style={{ color: '#333333' }}>
              Your progress:
            </p>
            <p className="text-sm" style={{ color: '#333333' }}>
              Anchor sessions: {userProgress.anchorSessionsCompleted} of 20 complete
            </p>
            <p className="text-sm" style={{ color: '#333333' }}>
              Current unit: {userProgress.currentUnit} of 20
            </p>
            {userProgress.swapSessionsCompleted > 0 && (
              <p className="text-sm" style={{ color: '#6D6D6D' }}>
                Swap sessions: {userProgress.swapSessionsCompleted}
              </p>
            )}
          </div>

          <button
            onClick={() => {
              // Reset state for next session (do NOT wipe today‚Äôs persisted counter)
              setScreen('postBreath');
              setRecommendation(null);
              setPostBreathState(null);
              setTrained3(null);
              setProgress(null);
              setRoutine(null);
              setRobustness(null);
              setClick(null);
              setClickNote('');
              setDeploy(null);
              setBreaksFirst(null);
              setSwapChoice(null);
              setSwapStrategy(null);
              setSessionFeel(null);
              setCarryOver(null);
              setSpikeGap(null);
              setBridgeObs('');
              setBridgeMove('');
              setSelectedChange('none');

              // Keep daily counter in sync (persisted)
              setSessionsCompletedToday(loadSessionsCompletedToday());
            }}
            className="w-full py-3 px-6 rounded-lg font-semibold transition-all"
            style={{ backgroundColor: '#2764B7', color: '#FFFFFF' }}
          >
            Done
          </button>
        </div>
      </div>
    </div>
  );
}

return null;
};

// Render the app (React 18 createRoot)
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<SessionSwitcher />);
</script>
</body>
</html>

