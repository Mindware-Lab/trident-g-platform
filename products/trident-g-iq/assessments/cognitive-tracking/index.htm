<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>G Tracker</title>

  <!-- Shared brand CSS (your deep blue header kit) -->
  <link rel="stylesheet" href="/trident-g-platform/branding/brand.css">

  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

  <style>
    /* Hub-specific helpers (keeps brand.css clean) */
    .grid { display: grid; gap: 12px; }
    .grid2 { grid-template-columns: 1fr; }

    .content{
      max-width: 940px;
      width: 100%;
      margin: 0 auto;
    }

    .sectionTitle{
      margin: 4px 2px 0;
      font-weight: 900;
      font-size: 22px;
      letter-spacing: 0.2px;
      color: #111;
    }

    .sectionNote{
      margin: 4px 2px 0;
      font-size: 18px;
      color: var(--grey-600);
      line-height: 1.45;
    }

    .testRow{
      display:flex;
      flex-direction: column;
      justify-content:flex-start;
      align-items:stretch;
      gap: 10px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(224,224,224,0.35);
      border: 1px solid rgba(0,0,0,0.05);
    }

    .testMeta{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width: 0;
    }

    .testName{
      font-weight: 900;
      font-size: 24px;
      margin: 0;
    }

    .testDesc{
      margin: 0;
      font-size: 18px;
      color: var(--grey-600);
      line-height: 1.45;
    }

    .tagRow{ display:flex; gap:6px; flex-wrap:wrap; margin-top: 4px; }
    .tag{
      font-size: 18px;
      font-weight: 800;
      padding: 7px 12px;
      border-radius: 999px;
      background: rgba(39,100,183,0.08);
      border: 1px solid rgba(39,100,183,0.18);
      color: var(--deep);
      white-space: nowrap;
    }
    .tagDone{
      background: rgba(204,255,102,0.95);
      border: 1px solid rgba(0,0,0,0.08);
      color:#0B1A0B;
    }

    .rightCol{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-start;
      flex: 0 0 auto;
    }

    .miniRow{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-start; }

    .btnSmall{
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 900;
    }

    .input{
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.10);
      padding: 8px 10px;
      font-size: 16px;
      outline: none;
    }
    .input:focus{
      border-color: rgba(34,170,255,0.65);
      box-shadow: 0 0 0 3px rgba(34,170,255,0.12);
    }

    .twoCol{
      display:grid;
      grid-template-columns: minmax(160px, 220px) minmax(260px, 1fr);
      gap: 8px;
      align-items: center;
      max-width: 640px;
    }

    @media (max-width: 720px){
      .twoCol{
        grid-template-columns: 1fr;
        max-width: none;
      }
    }

    .whenLine{
      margin: 8px 0 0 0;
      font-size: 16px;
      color: #111;
      line-height: 1.4;
    }

    .timepointRow{
      margin-top: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .timepointSelect{
      max-width: 260px;
    }

    .infoGrid{
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      max-width: 760px;
    }

    .infoBlock{
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 12px;
      background: rgba(255,255,255,0.4);
      padding: 8px 10px;
    }

    .infoBlock summary{
      cursor: pointer;
      font-weight: 800;
      font-size: 16px;
      color: #111;
      user-select: none;
    }

    .infoBlock p{
      margin: 8px 0 0 0;
    }

    .checkList{
      margin: 8px 0 0 18px;
      padding: 0;
      font-size: 16px;
      color: var(--grey-600);
      line-height: 1.35;
    }

    .contextHint{
      margin-top: 8px;
      font-size: 15px;
      color: #1E4F8A;
      font-weight: 700;
    }

    .historyHint{
      margin-top: 8px;
      font-size: 15px;
      color: var(--grey-600);
      line-height: 1.35;
    }

    .muted{
      font-size: 18px;
      color: var(--grey-600);
      line-height: 1.45;
      margin: 0;
    }

    .danger{
      background: rgba(0,0,0,0.04);
      border: 1px dashed rgba(0,0,0,0.15);
      padding: 10px 12px;
      border-radius: 14px;
    }

    .gSplashCard{
      max-width: 640px;
      margin: 0 auto;
      border-radius: 24px;
      border: none;
      background: var(--primary);
      color: #FFFFFF;
      text-align: center;
      padding: 26px 22px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.12);
    }

    .gSplashIcon{
      width: 56px;
      height: 56px;
      border-radius: 14px;
      background: rgba(255,255,255,0.88);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 12px auto;
      overflow: hidden;
    }

    .gSplashIcon img{
      width: 40px;
      height: 40px;
      object-fit: contain;
    }

    .gSplashTitle{
      margin: 0;
      font-size: 46px;
      line-height: 1;
      font-weight: 900;
      color: #FFFFFF;
    }

    .gSplashSub{
      margin: 12px 0 0 0;
      font-size: 24px;
      line-height: 1.35;
      color: rgba(255,255,255,0.96);
      font-weight: 600;
    }

    .gSplashBtn{
      margin-top: 18px;
      min-width: 230px;
    }

    .gSplashFoot{
      margin: 14px 0 0 0;
      color: rgba(255,255,255,0.95);
      font-size: 20px;
      font-weight: 700;
    }
  </style>
</head>

<body>
  <div id="root"></div>
  <script type="text/babel" data-presets="env,react">
    const { useEffect, useMemo, useState } = React;

    const HUB_VERSION = "ct_hub_v2";
    const STORAGE_KEY = "ctHub_v2_state";
    const APP_NAME = "G Tracker";
    const APP_SUBTITLE = "Track cognitive change over time (not a diagnosis)";
    const ICON_SRC = "/trident-g-platform/branding/Trident-G-Icon.svg";

    const FAIR_RESULTS_CHECKLIST = [
      "Use the same time of day when possible.",
      "Use a quiet space and turn notifications off.",
      "Keep sleep and caffeine conditions similar.",
      "Avoid testing right after heavy exercise or alcohol.",
      "If you are ill, very sleep deprived, or unusually stressed, log it in notes."
    ];

    const TIMEPOINT_LABELS = {
      PRE: "PRE",
      POST: "POST",
      MIDPOINT: "MIDPOINT",
      WEEKLY: "WEEKLY",
      FOLLOW_UP: "FOLLOW-UP"
    };

    const TESTS = [
      {
        id: "sgs12a",
        group: "IQ Performance",
        name: "Short IQ test 1 (before training)",
        url: "https://mindware-lab.github.io/iq-assessments/sgs12a/",
        kind: "internal",
        timing: "10-12 mins",
        schedule: "fixed",
        fixedTimepoint: "PRE",
        scheduleLabel: "PRE only",
        whenText: "Take once before training.",
        whatText: "Short internal IQ form A used as your pre-training anchor."
      },
      {
        id: "sgs12b",
        group: "IQ Performance",
        name: "Short IQ test 2 (after training)",
        url: "https://mindware-lab.github.io/iq-assessments/sgs12b/",
        kind: "internal",
        timing: "10-12 mins",
        schedule: "fixed",
        fixedTimepoint: "POST",
        scheduleLabel: "POST only",
        whenText: "Take once after training.",
        whatText: "Short internal IQ form B used at programme end for PRE vs POST comparison."
      },
      {
        id: "mensa_dk",
        group: "IQ Performance",
        name: "Mensa online matrix test (optional baseline)",
        url: "https://mensa.dk/iqtest/",
        kind: "external",
        timing: "25-30 mins",
        schedule: "fixed",
        fixedTimepoint: "PRE",
        scheduleLabel: "Optional baseline",
        whenText: "Optional baseline only.",
        whatText: "Unofficial online practice-style matrix test for a rough baseline indication."
      },
      {
        id: "mensa_no",
        group: "IQ Performance",
        name: "Mensa online matrix test (optional delayed re-test)",
        url: "https://test.mensa.no/home/test/en",
        kind: "external",
        timing: "20-25 mins",
        schedule: "fixed",
        fixedTimepoint: "FOLLOW_UP",
        scheduleLabel: "Optional delayed re-test",
        whenText: "Optional long-delayed re-test only (e.g., months later).",
        whatText: "Unofficial online practice-style matrix re-check for delayed comparison."
      },
      {
        id: "psi_cbs",
        group: "Bandwidth Tracking",
        name: "Psi-Band Cognitive Bandwidth Scale (Psi-CBS Core, 8 items)",
        url: "https://mindware-lab.github.io/iq-assessments/psi-cbs/",
        kind: "internal",
        timing: "2-4 mins",
        schedule: "repeatable",
        scheduleLabel: "PRE + weekly + POST + follow-up",
        whenText: "Take at PRE, weekly during training, POST, and optional 4-week follow-up.",
        whatText: "Self-report of real-world mental bandwidth across work, study, and life."
      },
      {
        id: "crs10",
        group: "Cognitive Resilience",
        name: "Cognitive resilience scale (CRS-10)",
        url: "https://mindware-lab.github.io/iq-assessments/crs10/",
        kind: "internal",
        timing: "3-6 mins",
        schedule: "pre_post_optional_checkin",
        scheduleLabel: "PRE + POST (optional check-ins)",
        whenText: "Take at PRE and POST, with optional midpoint or follow-up checks.",
        whatText: "Tracks how steadily you function under cognitive pressure."
      },
      {
        id: "edhs",
        group: "Decision Habits",
        name: "Everyday decision habits scale (EDHS)",
        url: "https://mindware-lab.github.io/iq-assessments/edhs/",
        kind: "internal",
        timing: "5-10 mins",
        schedule: "pre_post",
        scheduleLabel: "PRE + POST only",
        whenText: "Take once before training and once after training.",
        whatText: "Captures higher-level habit shift in everyday decision making across the programme."
      }
    ];

    const GROUP_ORDER = [
      "IQ Performance",
      "Bandwidth Tracking",
      "Cognitive Resilience",
      "Decision Habits"
    ];

    const BrandTopBar = ({ appName, subtitle, chipText, iconSrc }) => (
      <div className="topbar">
        <div className="brandleft">
          <div className="icon">
            <img src={iconSrc} alt="Trident icon" onError={(e)=>{ e.target.style.display = "none"; }} />
          </div>
          <div>
            <p className="title">{appName}</p>
            <p className="subtitle">{subtitle}</p>
          </div>
        </div>
        <div className="chip">{chipText}</div>
      </div>
    );

    function createDefaultState(){
      return {
        schemaVersion: HUB_VERSION,
        selectedTimepoints: {},
        tests: {
          // [testId]: { entries: [{measure_id,timepoint,date_ts,score_payload,notes}] }
        }
      };
    }

    const defaultState = createDefaultState();

    function createEntry(measureId, timepoint){
      return {
        measure_id: measureId,
        timepoint,
        date_ts: "",
        score_payload: { score: "", done: false },
        notes: ""
      };
    }

    function nowISO(){
      return new Date().toISOString();
    }

    function ensureTestRecord(state, testId){
      if(!state.tests[testId]){
        state.tests[testId] = { entries: [] };
      }
      return state.tests[testId];
    }

    function allowedTimepoints(test){
      if(test.fixedTimepoint) return [test.fixedTimepoint];
      if(test.schedule === "pre_post") return ["PRE", "POST"];
      if(test.schedule === "repeatable") return ["PRE", "WEEKLY", "POST", "FOLLOW_UP"];
      if(test.schedule === "pre_post_optional_checkin") return ["PRE", "MIDPOINT", "POST", "FOLLOW_UP"];
      return ["PRE"];
    }

    function defaultTimepoint(test){
      const options = allowedTimepoints(test);
      return options[0];
    }

    function allowsTimepoint(test, timepoint){
      if(test.fixedTimepoint) return timepoint === test.fixedTimepoint;
      if(test.schedule === "pre_post") return timepoint === "PRE" || timepoint === "POST";
      if(test.schedule === "repeatable") return ["PRE", "WEEKLY", "POST", "FOLLOW_UP"].includes(timepoint);
      if(test.schedule === "pre_post_optional_checkin") return ["PRE", "MIDPOINT", "POST", "FOLLOW_UP"].includes(timepoint);
      return false;
    }

    function supportsMultiEntries(test, timepoint){
      return (
        timepoint === "WEEKLY" &&
        test.schedule === "repeatable"
      );
    }

    function resolveTimepoint(test, selectedTimepoints){
      const selected = selectedTimepoints?.[test.id];
      if(selected && allowsTimepoint(test, selected)) return selected;
      return defaultTimepoint(test);
    }

    function listEntries(record, timepoint){
      if(!record?.entries) return [];
      return record.entries.filter(entry => entry.timepoint === timepoint);
    }

    function getDisplayEntry(record, test, timepoint){
      const matches = listEntries(record, timepoint);
      if(matches.length === 0) return null;
      if(supportsMultiEntries(test, timepoint)){
        for(let i = matches.length - 1; i >= 0; i--){
          if(!matches[i].score_payload?.done) return matches[i];
        }
      }
      return matches[matches.length - 1];
    }

    function getEditableEntry(record, test, timepoint, createIfMissing){
      const matches = listEntries(record, timepoint);
      if(matches.length === 0){
        if(!createIfMissing) return null;
        const fresh = createEntry(test.id, timepoint);
        record.entries.push(fresh);
        return fresh;
      }

      if(supportsMultiEntries(test, timepoint)){
        for(let i = matches.length - 1; i >= 0; i--){
          if(!matches[i].score_payload?.done) return matches[i];
        }
        if(createIfMissing){
          const fresh = createEntry(test.id, timepoint);
          record.entries.push(fresh);
          return fresh;
        }
      }

      return matches[matches.length - 1];
    }

    function completedCount(record, timepoint){
      return listEntries(record, timepoint).filter(entry => entry.score_payload?.done).length;
    }

    function timepointLabel(timepoint){
      return TIMEPOINT_LABELS[timepoint] || timepoint;
    }

    function migrateV1ToV2(v1State){
      const migrated = createDefaultState();

      for(const test of TESTS){
        const oldRecord = v1State?.tests?.[test.id];
        if(!oldRecord) continue;

        const rec = ensureTestRecord(migrated, test.id);
        const pushLegacy = (legacySlot, timepoint) => {
          if(!legacySlot) return;
          const hasValue =
            Boolean(legacySlot.done) ||
            Boolean((legacySlot.score || "").trim()) ||
            Boolean((legacySlot.notes || "").trim()) ||
            Boolean(legacySlot.ts);
          if(!hasValue) return;

          rec.entries.push({
            measure_id: test.id,
            timepoint,
            date_ts: legacySlot.ts || "",
            score_payload: {
              score: legacySlot.score || "",
              done: Boolean(legacySlot.done)
            },
            notes: legacySlot.notes || ""
          });
        };

        pushLegacy(oldRecord.pre, "PRE");
        pushLegacy(oldRecord.post, "POST");
        if(oldRecord.one){
          pushLegacy(oldRecord.one, test.fixedTimepoint || "PRE");
        }
      }

      return migrated;
    }

    function loadState(){
      try{
        const rawV2 = localStorage.getItem(STORAGE_KEY);
        if(rawV2){
          const parsed = JSON.parse(rawV2);
          if(parsed?.schemaVersion === HUB_VERSION){
            if(!parsed.selectedTimepoints) parsed.selectedTimepoints = {};
            return parsed;
          }
        }

        const rawV1 = localStorage.getItem("ctHub_v1_state");
        if(rawV1){
          const parsedV1 = JSON.parse(rawV1);
          if(parsedV1?.schemaVersion === "ct_hub_v1"){
            return migrateV1ToV2(parsedV1);
          }
        }
        return null;
      }catch{
        return null;
      }
    }

    function saveState(state){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function sectionCopy(groupName){
      if(groupName === "IQ Performance"){
        return "Short IQ forms are PRE and POST only. Mensa links are unofficial online practice-style checks (optional baseline plus optional delayed re-test).";
      }
      if(groupName === "Bandwidth Tracking"){
        return "Psi-CBS is the repeatable tracker: use PRE, weekly during training, POST, and optional follow-up.";
      }
      if(groupName === "Cognitive Resilience"){
        return "CRS-10 is PRE and POST by default, with optional midpoint or follow-up checks.";
      }
      if(groupName === "Decision Habits"){
        return "EDHS is PRE and POST only to track overall habit shift, not week-to-week noise.";
      }
      return "";
    }

    function App(){
      const [state, setState] = useState(() => loadState() || defaultState);
      const [toast, setToast] = useState("");
      const [showSplash, setShowSplash] = useState(true);

      useEffect(() => {
        saveState(state);
      }, [state]);

      useEffect(() => {
        if(!toast) return;
        const timer = setTimeout(() => setToast(""), 2200);
        return () => clearTimeout(timer);
      }, [toast]);

      const grouped = useMemo(() => {
        const map = {};
        for(const groupName of GROUP_ORDER) map[groupName] = [];
        for(const test of TESTS){
          if(!map[test.group]) map[test.group] = [];
          map[test.group].push(test);
        }
        return map;
      }, []);

      const setSelectedTimepoint = (testId, timepoint) => {
        setState(prev => ({
          ...prev,
          selectedTimepoints: {
            ...(prev.selectedTimepoints || {}),
            [testId]: timepoint
          }
        }));
      };

      const updateEntry = (test, timepoint, updater) => {
        setState(prev => {
          if(!allowsTimepoint(test, timepoint)) return prev;
          const next = JSON.parse(JSON.stringify(prev));
          const record = ensureTestRecord(next, test.id);
          const entry = getEditableEntry(record, test, timepoint, true);
          updater(entry, record);
          return next;
        });
      };

      const setScore = (test, timepoint, value) => {
        updateEntry(test, timepoint, entry => {
          entry.score_payload.score = value;
        });
      };

      const setNotes = (test, timepoint, value) => {
        updateEntry(test, timepoint, entry => {
          entry.notes = value;
        });
      };

      const markDone = (test, timepoint) => {
        updateEntry(test, timepoint, entry => {
          entry.score_payload.done = true;
          entry.date_ts = nowISO();
        });
        setToast("Saved");
      };

      const startNewCheckIn = (test, timepoint) => {
        if(!supportsMultiEntries(test, timepoint)) return;
        setState(prev => {
          const next = JSON.parse(JSON.stringify(prev));
          const record = ensureTestRecord(next, test.id);
          const matches = listEntries(record, timepoint);
          const latest = matches[matches.length - 1];
          if(latest && !latest.score_payload?.done){
            return prev;
          }
          record.entries.push(createEntry(test.id, timepoint));
          return next;
        });
        setToast("New check-in");
      };

      const openTest = (test) => {
        window.open(test.url, "_blank", "noopener,noreferrer");
      };

      const exportJSON = () => {
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "g-tracker-export.json";
        a.click();
        URL.revokeObjectURL(url);
      };

      const importJSON = () => {
        const raw = prompt("Paste exported JSON here:");
        if(!raw) return;
        try{
          const parsed = JSON.parse(raw);
          if(parsed?.schemaVersion === HUB_VERSION){
            setState(parsed);
            setToast("Imported");
            return;
          }
          if(parsed?.schemaVersion === "ct_hub_v1"){
            setState(migrateV1ToV2(parsed));
            setToast("Imported (migrated)");
            return;
          }
          alert("That JSON does not match this hub schema.");
        }catch{
          alert("Could not parse JSON.");
        }
      };

      const resetAll = () => {
        if(!confirm("Reset all locally saved hub data?")) return;
        localStorage.removeItem(STORAGE_KEY);
        setState(createDefaultState());
        setToast("Reset");
      };

      const getRec = (test, timepoint) => {
        const record = state.tests?.[test.id];
        if(!record) return null;
        return getDisplayEntry(record, test, timepoint);
      };

      const getDoneCount = (test, timepoint) => {
        const record = state.tests?.[test.id];
        if(!record) return 0;
        return completedCount(record, timepoint);
      };

      const statusTag = (entry) => {
        if(!entry) return <span className="tag">Not started</span>;
        if(entry.score_payload?.done) return <span className="tag tagDone">Completed</span>;
        if((entry.score_payload?.score || "").trim() || (entry.notes || "").trim()){
          return <span className="tag">In progress</span>;
        }
        return <span className="tag">Not started</span>;
      };

      const getLockMessage = (test, timepoint) => (
        allowsTimepoint(test, timepoint) ? "" : `This measure does not use ${timepointLabel(timepoint)} logging.`
      );

      if(showSplash){
        return (
          <div className="screen">
            <div className="content" style={{ justifyContent: "center", alignItems: "center" }}>
              <section className="gSplashCard">
                <div className="gSplashIcon">
                  <img src={ICON_SRC} alt="G Tracker icon" onError={(e)=>{ e.target.style.display = "none"; }} />
                </div>
                <h1 className="gSplashTitle">{APP_NAME}</h1>
                <p className="gSplashSub">Track your core cognitive assessments before and after training.</p>
                <button className="btn btnPrimary gSplashBtn" onClick={() => setShowSplash(false)}>Continue</button>
                <p className="gSplashFoot">Mindware Lab - IQ Mindware</p>
              </section>
            </div>
          </div>
        );
      }

      const chipText = "PER-TEST";

      return (
        <div className="screen">
          <BrandTopBar
            appName={APP_NAME}
            subtitle={APP_SUBTITLE}
            chipText={chipText}
            iconSrc={ICON_SRC}
          />

          <div className="content">
            <div className="card">
              <h1 className="h1">Your test battery</h1>
              <p className="p">
                Use this tracker to monitor change over time. It is not a diagnosis or medical tool.
              </p>

              <div className="btnRow">
                <button className="btn btnPrimary" onClick={exportJSON}>Export JSON</button>
                <button className="btn btnSecondary" onClick={importJSON}>Import JSON</button>
              </div>

              <div className="danger" style={{ marginTop: "10px" }}>
                <p className="muted">
                  Tip: if you switch devices or clear browser data, local results can be lost. Export JSON for backup.
                </p>
              </div>

              <div className="danger" style={{ marginTop: "10px" }}>
                <p className="muted">
                  Pick the timepoint on each test card before entering score/notes. Fixed tests lock to one timepoint automatically.
                </p>
              </div>

              <div className="danger" style={{ marginTop: "10px" }}>
                <p className="muted">
                  Suggested cadence: Week 0 PRE -> Psi-CBS, CRS-10, EDHS, Short IQ PRE (+ optional Mensa baseline). Weekly during training -> Psi-CBS. Optional midpoint -> CRS-10. End POST -> Psi-CBS, CRS-10, EDHS, Short IQ POST. Optional 4-week follow-up -> Psi-CBS (+ CRS-10).
                </p>
              </div>

              {toast && (
                <div style={{
                  marginTop: "10px",
                  padding: "10px 12px",
                  borderRadius: "14px",
                  background: "rgba(204,255,102,0.75)",
                  fontWeight: 900,
                  fontSize: "12px"
                }}>
                  {toast}
                </div>
              )}
            </div>

            <div className="grid grid2">
              {GROUP_ORDER.map(groupName => (
                <div className="card" key={groupName}>
                  <div className="sectionTitle">{groupName}</div>
                  <div className="sectionNote">{sectionCopy(groupName)}</div>

                  <div style={{ marginTop: "10px" }} className="grid">
                    {grouped[groupName].map(test => {
                      const activeTimepoint = resolveTimepoint(test, state.selectedTimepoints);
                      const availableTimepoints = allowedTimepoints(test);
                      const rec = getRec(test, activeTimepoint);
                      const lockMessage = getLockMessage(test, activeTimepoint);
                      const canHaveMultiple = supportsMultiEntries(test, activeTimepoint);
                      const doneLocked = Boolean(rec?.score_payload?.done) && !canHaveMultiple;
                      const disabled = Boolean(lockMessage) || doneLocked;

                      return (
                        <div className="testRow" key={test.id}>
                          <div className="testMeta">
                            <p className="testName">{test.name}</p>
                            <p className="testDesc">
                              {test.kind === "external" ? "External test" : "Internal test"} - {test.timing}
                            </p>

                            {availableTimepoints.length > 1 && (
                              <div className="timepointRow">
                                <span className="muted">Log this entry as:</span>
                                <select
                                  className="input timepointSelect"
                                  value={activeTimepoint}
                                  onChange={(e) => setSelectedTimepoint(test.id, e.target.value)}
                                >
                                  {availableTimepoints.map(tp => (
                                    <option key={tp} value={tp}>{timepointLabel(tp)}</option>
                                  ))}
                                </select>
                              </div>
                            )}

                            <div className="tagRow">
                              {statusTag(rec)}
                              <span className="tag">{test.scheduleLabel}</span>
                              <span className="tag">{test.kind === "external" ? "Manual score" : "Auto page"}</span>
                              <span className="tag">Logging: {timepointLabel(activeTimepoint)}</span>
                            </div>

                            <p className="whenLine">
                              <strong>When should I take this?</strong> {test.whenText}
                            </p>

                            <div className="infoGrid">
                              <details className="infoBlock">
                                <summary>What is this?</summary>
                                <p className="muted">{test.whatText}</p>
                              </details>

                              <details className="infoBlock">
                                <summary>How to take it (for fair results)</summary>
                                <ul className="checkList">
                                  {FAIR_RESULTS_CHECKLIST.map(item => <li key={item}>{item}</li>)}
                                </ul>
                              </details>
                            </div>

                            {lockMessage && (
                              <div className="contextHint">{lockMessage}</div>
                            )}

                            <div className="twoCol" style={{ marginTop: "10px" }}>
                              <input
                                className="input"
                                placeholder="Score (optional)"
                                value={rec?.score_payload?.score || ""}
                                onChange={(e)=>setScore(test, activeTimepoint, e.target.value)}
                                disabled={Boolean(lockMessage)}
                              />
                              <input
                                className="input"
                                placeholder='Notes (optional: "Sleep 5h, lots of interruptions, high stress day" or "Quiet morning, normal caffeine")'
                                value={rec?.notes || ""}
                                onChange={(e)=>setNotes(test, activeTimepoint, e.target.value)}
                                disabled={Boolean(lockMessage)}
                              />
                            </div>

                            {rec?.date_ts && (
                              <p className="muted" style={{ marginTop: "8px" }}>
                                Last marked complete: {new Date(rec.date_ts).toLocaleString()}
                              </p>
                            )}

                            {canHaveMultiple && (
                              <p className="historyHint">
                                Completed weekly check-ins: {getDoneCount(test, "WEEKLY")}
                              </p>
                            )}
                          </div>

                          <div className="rightCol">
                            <div className="miniRow">
                              <button className="btn btnPrimary btnSmall" onClick={()=>openTest(test)}>
                                Open
                              </button>
                              <button
                                className="btn btnSecondary btnSmall"
                                onClick={()=>markDone(test, activeTimepoint)}
                                disabled={disabled}
                                style={{
                                  opacity: disabled ? 0.6 : 1,
                                  cursor: disabled ? "not-allowed" : "pointer"
                                }}
                              >
                                {doneLocked ? "Locked" : "Mark complete"}
                              </button>
                              {canHaveMultiple && !lockMessage && (
                                <button
                                  className="btn btnSecondary btnSmall"
                                  onClick={() => startNewCheckIn(test, activeTimepoint)}
                                >
                                  New check-in
                                </button>
                              )}
                            </div>

                            <div className="muted" style={{ textAlign: "right", maxWidth: "250px" }}>
                              {test.kind === "external"
                                ? "Complete externally, then record your result manually here."
                                : "Open the test in a new tab, then return here to log it."
                              }
                            </div>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>

            <div className="card">
              <div className="sectionTitle">Admin</div>
              <p className="sectionNote">
                This only resets the hub's local tracking data, not the individual test apps' local storage.
              </p>
              <div className="btnRow">
                <button className="btn btnSecondary" onClick={resetAll}>Reset hub data</button>
                <a
                  className="btn btnPrimary"
                  style={{ textDecoration: "none", display: "inline-flex", alignItems: "center" }}
                  href="https://mindware-lab.github.io/iq-assessments/"
                >
                  Back to iq-assessments
                </a>
              </div>
            </div>
          </div>

          <div className="footer">
            <span>Local-first - Schema: {HUB_VERSION}</span>
            <a className="link" href="https://mindware-lab.github.io/iq-assessments/" target="_self">Home</a>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);
  </script>
</body>
</html>

